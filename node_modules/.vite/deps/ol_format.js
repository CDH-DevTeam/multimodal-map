import {
  EventType_default,
  ImageState_default,
  Object_default,
  Target_default,
  WORKER_OFFSCREEN_CANVAS,
  abstract,
  createCanvasContext2D,
  getUid,
  listen,
  listenImage,
  memoizeOne,
  unlistenByKey
} from "./chunk-SIZRBVPA.js";
import {
  ascending,
  binarySearch,
  extend as extend2,
  forEach,
  intersectsLineString,
  intersectsLineStringArray,
  intersectsLinearRingArray,
  intersectsLinearRingMultiArray,
  linearRingsContainsXY,
  linearRingssContainsXY,
  toSize
} from "./chunk-P6D7DH6X.js";
import {
  clamp,
  clear,
  equivalent,
  get2 as get,
  getTransform,
  isEmpty,
  lerp,
  padNumber,
  squaredDistance,
  squaredSegmentDistance,
  toRadians,
  transformExtent
} from "./chunk-QIMHJTII.js";
import {
  assert,
  boundingExtent,
  closestSquaredDistanceXY,
  containsExtent,
  containsXY,
  createEmpty,
  createOrUpdate,
  createOrUpdateEmpty,
  createOrUpdateFromCoordinate,
  createOrUpdateFromFlatCoordinates,
  extend,
  forEachCorner,
  getCenter,
  getHeight,
  intersects,
  returnOrUpdate
} from "./chunk-WLMN7Y7O.js";
import {
  Projection_default
} from "./chunk-RN7AUUEM.js";
import {
  __commonJS,
  __toESM
} from "./chunk-TWLJ45QX.js";

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset2, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset2 + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset2 + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset2 + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset2, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset2 + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset2 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset2 + i - d] |= s * 128;
    };
  }
});

// node_modules/pbf/index.js
var require_pbf = __commonJS({
  "node_modules/pbf/index.js"(exports, module) {
    "use strict";
    module.exports = Pbf;
    var ieee754 = require_ieee754();
    function Pbf(buf) {
      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
      this.pos = 0;
      this.type = 0;
      this.length = this.buf.length;
    }
    Pbf.Varint = 0;
    Pbf.Fixed64 = 1;
    Pbf.Bytes = 2;
    Pbf.Fixed32 = 5;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var TEXT_DECODER_MIN_LENGTH = 12;
    var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
    Pbf.prototype = {
      destroy: function() {
        this.buf = null;
      },
      readFields: function(readField, result, end) {
        end = end || this.length;
        while (this.pos < end) {
          var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
          this.type = val & 7;
          readField(tag, result, this);
          if (this.pos === startPos)
            this.skip(val);
        }
        return result;
      },
      readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
      },
      readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
      },
      readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
      },
      readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
      },
      readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
      },
      readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
      },
      readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
      },
      readVarint: function(isSigned) {
        var buf = this.buf, val, b;
        b = buf[this.pos++];
        val = b & 127;
        if (b < 128)
          return val;
        b = buf[this.pos++];
        val |= (b & 127) << 7;
        if (b < 128)
          return val;
        b = buf[this.pos++];
        val |= (b & 127) << 14;
        if (b < 128)
          return val;
        b = buf[this.pos++];
        val |= (b & 127) << 21;
        if (b < 128)
          return val;
        b = buf[this.pos];
        val |= (b & 15) << 28;
        return readVarintRemainder(val, isSigned, this);
      },
      readVarint64: function() {
        return this.readVarint(true);
      },
      readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2;
      },
      readBoolean: function() {
        return Boolean(this.readVarint());
      },
      readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;
        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
          return readUtf8TextDecoder(this.buf, pos, end);
        }
        return readUtf8(this.buf, pos, end);
      },
      readBytes: function() {
        var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
      },
      readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readVarint(isSigned));
        return arr;
      },
      readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSVarint());
        return arr;
      },
      readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readBoolean());
        return arr;
      },
      readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFloat());
        return arr;
      },
      readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readDouble());
        return arr;
      },
      readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFixed32());
        return arr;
      },
      readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSFixed32());
        return arr;
      },
      readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFixed64());
        return arr;
      },
      readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSFixed64());
        return arr;
      },
      skip: function(val) {
        var type = val & 7;
        if (type === Pbf.Varint)
          while (this.buf[this.pos++] > 127) {
          }
        else if (type === Pbf.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32)
          this.pos += 4;
        else if (type === Pbf.Fixed64)
          this.pos += 8;
        else
          throw new Error("Unimplemented type: " + type);
      },
      writeTag: function(tag, type) {
        this.writeVarint(tag << 3 | type);
      },
      realloc: function(min) {
        var length = this.length || 16;
        while (length < this.pos + min)
          length *= 2;
        if (length !== this.length) {
          var buf = new Uint8Array(length);
          buf.set(this.buf);
          this.buf = buf;
          this.length = length;
        }
      },
      finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
      },
      writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
      },
      writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
      },
      writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeVarint: function(val) {
        val = +val || 0;
        if (val > 268435455 || val < 0) {
          writeBigVarint(val, this);
          return;
        }
        this.realloc(4);
        this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
        if (val <= 127)
          return;
        this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
        if (val <= 127)
          return;
        this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
        if (val <= 127)
          return;
        this.buf[this.pos++] = val >>> 7 & 127;
      },
      writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
      },
      writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
      },
      writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);
        this.pos++;
        var startPos = this.pos;
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;
        if (len >= 128)
          makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
      },
      writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
      },
      writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++)
          this.buf[this.pos++] = buffer[i];
      },
      writeRawMessage: function(fn, obj) {
        this.pos++;
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;
        if (len >= 128)
          makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
      },
      writePackedVarint: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedVarint, arr);
      },
      writePackedSVarint: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSVarint, arr);
      },
      writePackedBoolean: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedBoolean, arr);
      },
      writePackedFloat: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFloat, arr);
      },
      writePackedDouble: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedDouble, arr);
      },
      writePackedFixed32: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFixed32, arr);
      },
      writePackedSFixed32: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSFixed32, arr);
      },
      writePackedFixed64: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFixed64, arr);
      },
      writePackedSFixed64: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSFixed64, arr);
      },
      writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
      },
      writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
      },
      writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
      },
      writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
      },
      writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
      },
      writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
      },
      writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
      },
      writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
      },
      writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
      },
      writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
      },
      writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
      }
    };
    function readVarintRemainder(l, s, p) {
      var buf = p.buf, h, b;
      b = buf[p.pos++];
      h = (b & 112) >> 4;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 3;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 10;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 17;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 24;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 1) << 31;
      if (b < 128)
        return toNum(l, h, s);
      throw new Error("Expected varint not more than 10 bytes");
    }
    function readPackedEnd(pbf) {
      return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
    }
    function toNum(low, high, isSigned) {
      if (isSigned) {
        return high * 4294967296 + (low >>> 0);
      }
      return (high >>> 0) * 4294967296 + (low >>> 0);
    }
    function writeBigVarint(val, pbf) {
      var low, high;
      if (val >= 0) {
        low = val % 4294967296 | 0;
        high = val / 4294967296 | 0;
      } else {
        low = ~(-val % 4294967296);
        high = ~(-val / 4294967296);
        if (low ^ 4294967295) {
          low = low + 1 | 0;
        } else {
          low = 0;
          high = high + 1 | 0;
        }
      }
      if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
        throw new Error("Given varint doesn't fit into 10 bytes");
      }
      pbf.realloc(10);
      writeBigVarintLow(low, high, pbf);
      writeBigVarintHigh(high, pbf);
    }
    function writeBigVarintLow(low, high, pbf) {
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos] = low & 127;
    }
    function writeBigVarintHigh(high, pbf) {
      var lsb = (high & 7) << 4;
      pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127;
    }
    function makeRoomForExtraLength(startPos, len, pbf) {
      var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
      pbf.realloc(extraLen);
      for (var i = pbf.pos - 1; i >= startPos; i--)
        pbf.buf[i + extraLen] = pbf.buf[i];
    }
    function writePackedVarint(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeVarint(arr[i]);
    }
    function writePackedSVarint(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeSVarint(arr[i]);
    }
    function writePackedFloat(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeFloat(arr[i]);
    }
    function writePackedDouble(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeDouble(arr[i]);
    }
    function writePackedBoolean(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeBoolean(arr[i]);
    }
    function writePackedFixed32(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeFixed32(arr[i]);
    }
    function writePackedSFixed32(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeSFixed32(arr[i]);
    }
    function writePackedFixed64(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeFixed64(arr[i]);
    }
    function writePackedSFixed64(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeSFixed64(arr[i]);
    }
    function readUInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
    }
    function writeInt32(buf, val, pos) {
      buf[pos] = val;
      buf[pos + 1] = val >>> 8;
      buf[pos + 2] = val >>> 16;
      buf[pos + 3] = val >>> 24;
    }
    function readInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
    }
    function readUtf8(buf, pos, end) {
      var str = "";
      var i = pos;
      while (i < end) {
        var b0 = buf[i];
        var c = null;
        var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
        if (i + bytesPerSequence > end)
          break;
        var b1, b2, b3;
        if (bytesPerSequence === 1) {
          if (b0 < 128) {
            c = b0;
          }
        } else if (bytesPerSequence === 2) {
          b1 = buf[i + 1];
          if ((b1 & 192) === 128) {
            c = (b0 & 31) << 6 | b1 & 63;
            if (c <= 127) {
              c = null;
            }
          }
        } else if (bytesPerSequence === 3) {
          b1 = buf[i + 1];
          b2 = buf[i + 2];
          if ((b1 & 192) === 128 && (b2 & 192) === 128) {
            c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
            if (c <= 2047 || c >= 55296 && c <= 57343) {
              c = null;
            }
          }
        } else if (bytesPerSequence === 4) {
          b1 = buf[i + 1];
          b2 = buf[i + 2];
          b3 = buf[i + 3];
          if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
            c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
            if (c <= 65535 || c >= 1114112) {
              c = null;
            }
          }
        }
        if (c === null) {
          c = 65533;
          bytesPerSequence = 1;
        } else if (c > 65535) {
          c -= 65536;
          str += String.fromCharCode(c >>> 10 & 1023 | 55296);
          c = 56320 | c & 1023;
        }
        str += String.fromCharCode(c);
        i += bytesPerSequence;
      }
      return str;
    }
    function readUtf8TextDecoder(buf, pos, end) {
      return utf8TextDecoder.decode(buf.subarray(pos, end));
    }
    function writeUtf8(buf, str, pos) {
      for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i);
        if (c > 55295 && c < 57344) {
          if (lead) {
            if (c < 56320) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
              lead = c;
              continue;
            } else {
              c = lead - 55296 << 10 | c - 56320 | 65536;
              lead = null;
            }
          } else {
            if (c > 56319 || i + 1 === str.length) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
            } else {
              lead = c;
            }
            continue;
          }
        } else if (lead) {
          buf[pos++] = 239;
          buf[pos++] = 191;
          buf[pos++] = 189;
          lead = null;
        }
        if (c < 128) {
          buf[pos++] = c;
        } else {
          if (c < 2048) {
            buf[pos++] = c >> 6 | 192;
          } else {
            if (c < 65536) {
              buf[pos++] = c >> 12 | 224;
            } else {
              buf[pos++] = c >> 18 | 240;
              buf[pos++] = c >> 12 & 63 | 128;
            }
            buf[pos++] = c >> 6 & 63 | 128;
          }
          buf[pos++] = c & 63 | 128;
        }
      }
      return pos;
    }
  }
});

// node_modules/ol/Feature.js
var Feature = class extends Object_default {
  constructor(geometryOrProperties) {
    super();
    this.on;
    this.once;
    this.un;
    this.id_ = void 0;
    this.geometryName_ = "geometry";
    this.style_ = null;
    this.styleFunction_ = void 0;
    this.geometryChangeKey_ = null;
    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
    if (geometryOrProperties) {
      if (typeof geometryOrProperties.getSimplifiedGeometry === "function") {
        const geometry = geometryOrProperties;
        this.setGeometry(geometry);
      } else {
        const properties = geometryOrProperties;
        this.setProperties(properties);
      }
    }
  }
  clone() {
    const clone = new Feature(this.hasProperties() ? this.getProperties() : null);
    clone.setGeometryName(this.getGeometryName());
    const geometry = this.getGeometry();
    if (geometry) {
      clone.setGeometry(geometry.clone());
    }
    const style = this.getStyle();
    if (style) {
      clone.setStyle(style);
    }
    return clone;
  }
  getGeometry() {
    return this.get(this.geometryName_);
  }
  getId() {
    return this.id_;
  }
  getGeometryName() {
    return this.geometryName_;
  }
  getStyle() {
    return this.style_;
  }
  getStyleFunction() {
    return this.styleFunction_;
  }
  handleGeometryChange_() {
    this.changed();
  }
  handleGeometryChanged_() {
    if (this.geometryChangeKey_) {
      unlistenByKey(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }
    const geometry = this.getGeometry();
    if (geometry) {
      this.geometryChangeKey_ = listen(
        geometry,
        EventType_default.CHANGE,
        this.handleGeometryChange_,
        this
      );
    }
    this.changed();
  }
  setGeometry(geometry) {
    this.set(this.geometryName_, geometry);
  }
  setStyle(style) {
    this.style_ = style;
    this.styleFunction_ = !style ? void 0 : createStyleFunction(style);
    this.changed();
  }
  setId(id) {
    this.id_ = id;
    this.changed();
  }
  setGeometryName(name) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.geometryName_ = name;
    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.handleGeometryChanged_();
  }
};
function createStyleFunction(obj) {
  if (typeof obj === "function") {
    return obj;
  }
  let styles;
  if (Array.isArray(obj)) {
    styles = obj;
  } else {
    assert(typeof obj.getZIndex === "function", 41);
    const style = obj;
    styles = [style];
  }
  return function() {
    return styles;
  };
}
var Feature_default = Feature;

// node_modules/ol/format/Feature.js
var FeatureFormat = class {
  constructor() {
    this.dataProjection = void 0;
    this.defaultFeatureProjection = void 0;
    this.supportedMediaTypes = null;
  }
  getReadOptions(source, options) {
    if (options) {
      let dataProjection = options.dataProjection ? get(options.dataProjection) : this.readProjection(source);
      if (options.extent && dataProjection && dataProjection.getUnits() === "tile-pixels") {
        dataProjection = get(dataProjection);
        dataProjection.setWorldExtent(options.extent);
      }
      options = {
        dataProjection,
        featureProjection: options.featureProjection
      };
    }
    return this.adaptOptions(options);
  }
  adaptOptions(options) {
    return Object.assign(
      {
        dataProjection: this.dataProjection,
        featureProjection: this.defaultFeatureProjection
      },
      options
    );
  }
  getType() {
    return abstract();
  }
  readFeature(source, options) {
    return abstract();
  }
  readFeatures(source, options) {
    return abstract();
  }
  readGeometry(source, options) {
    return abstract();
  }
  readProjection(source) {
    return abstract();
  }
  writeFeature(feature, options) {
    return abstract();
  }
  writeFeatures(features, options) {
    return abstract();
  }
  writeGeometry(geometry, options) {
    return abstract();
  }
};
var Feature_default2 = FeatureFormat;
function transformGeometryWithOptions(geometry, write, options) {
  const featureProjection = options ? get(options.featureProjection) : null;
  const dataProjection = options ? get(options.dataProjection) : null;
  let transformed;
  if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
    transformed = (write ? geometry.clone() : geometry).transform(
      write ? featureProjection : dataProjection,
      write ? dataProjection : featureProjection
    );
  } else {
    transformed = geometry;
  }
  if (write && options && options.decimals !== void 0) {
    const power = Math.pow(10, options.decimals);
    const transform = function(coordinates2) {
      for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
        coordinates2[i] = Math.round(coordinates2[i] * power) / power;
      }
      return coordinates2;
    };
    if (transformed === geometry) {
      transformed = geometry.clone();
    }
    transformed.applyTransform(transform);
  }
  return transformed;
}
function transformExtentWithOptions(extent, options) {
  const featureProjection = options ? get(options.featureProjection) : null;
  const dataProjection = options ? get(options.dataProjection) : null;
  if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
    return transformExtent(extent, dataProjection, featureProjection);
  }
  return extent;
}

// node_modules/ol/format/JSONFeature.js
var JSONFeature = class extends Feature_default2 {
  constructor() {
    super();
  }
  getType() {
    return "json";
  }
  readFeature(source, options) {
    return this.readFeatureFromObject(
      getObject(source),
      this.getReadOptions(source, options)
    );
  }
  readFeatures(source, options) {
    return this.readFeaturesFromObject(
      getObject(source),
      this.getReadOptions(source, options)
    );
  }
  readFeatureFromObject(object, options) {
    return abstract();
  }
  readFeaturesFromObject(object, options) {
    return abstract();
  }
  readGeometry(source, options) {
    return this.readGeometryFromObject(
      getObject(source),
      this.getReadOptions(source, options)
    );
  }
  readGeometryFromObject(object, options) {
    return abstract();
  }
  readProjection(source) {
    return this.readProjectionFromObject(getObject(source));
  }
  readProjectionFromObject(object) {
    return abstract();
  }
  writeFeature(feature, options) {
    return JSON.stringify(this.writeFeatureObject(feature, options));
  }
  writeFeatureObject(feature, options) {
    return abstract();
  }
  writeFeatures(features, options) {
    return JSON.stringify(this.writeFeaturesObject(features, options));
  }
  writeFeaturesObject(features, options) {
    return abstract();
  }
  writeGeometry(geometry, options) {
    return JSON.stringify(this.writeGeometryObject(geometry, options));
  }
  writeGeometryObject(geometry, options) {
    return abstract();
  }
};
function getObject(source) {
  if (typeof source === "string") {
    const object = JSON.parse(source);
    return object ? object : null;
  } else if (source !== null) {
    return source;
  }
  return null;
}
var JSONFeature_default = JSONFeature;

// node_modules/ol/transform.js
var tmp_ = new Array(6);
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
}

// node_modules/ol/geom/flat/transform.js
function transform2D(flatCoordinates, offset2, end, stride, transform, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    const x = flatCoordinates[j];
    const y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function rotate(flatCoordinates, offset2, end, stride, angle, anchor, dest) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function scale(flatCoordinates, offset2, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function translate(flatCoordinates, offset2, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

// node_modules/ol/geom/Geometry.js
var tmpTransform = create();
var Geometry = class extends Object_default {
  constructor() {
    super();
    this.extent_ = createEmpty();
    this.extentRevision_ = -1;
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = 0;
    this.simplifyTransformedInternal = memoizeOne(function(revision, squaredTolerance, transform) {
      if (!transform) {
        return this.getSimplifiedGeometry(squaredTolerance);
      }
      const clone = this.clone();
      clone.applyTransform(transform);
      return clone.getSimplifiedGeometry(squaredTolerance);
    });
  }
  simplifyTransformed(squaredTolerance, transform) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      squaredTolerance,
      transform
    );
  }
  clone() {
    return abstract();
  }
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    return abstract();
  }
  containsXY(x, y) {
    const coord = this.getClosestPoint([x, y]);
    return coord[0] === x && coord[1] === y;
  }
  getClosestPoint(point, closestPoint) {
    closestPoint = closestPoint ? closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  }
  intersectsCoordinate(coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  }
  computeExtent(extent) {
    return abstract();
  }
  getExtent(extent) {
    if (this.extentRevision_ != this.getRevision()) {
      const extent2 = this.computeExtent(this.extent_);
      if (isNaN(extent2[0]) || isNaN(extent2[1])) {
        createOrUpdateEmpty(extent2);
      }
      this.extentRevision_ = this.getRevision();
    }
    return returnOrUpdate(this.extent_, extent);
  }
  rotate(angle, anchor) {
    abstract();
  }
  scale(sx, sy, anchor) {
    abstract();
  }
  simplify(tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  }
  getSimplifiedGeometry(squaredTolerance) {
    return abstract();
  }
  getType() {
    return abstract();
  }
  applyTransform(transformFn) {
    abstract();
  }
  intersectsExtent(extent) {
    return abstract();
  }
  translate(deltaX, deltaY) {
    abstract();
  }
  transform(source, destination) {
    const sourceProj = get(source);
    const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
      const pixelExtent = sourceProj.getExtent();
      const projectedExtent = sourceProj.getWorldExtent();
      const scale2 = getHeight(projectedExtent) / getHeight(pixelExtent);
      compose(
        tmpTransform,
        projectedExtent[0],
        projectedExtent[3],
        scale2,
        -scale2,
        0,
        0,
        0
      );
      transform2D(
        inCoordinates,
        0,
        inCoordinates.length,
        stride,
        tmpTransform,
        outCoordinates
      );
      return getTransform(sourceProj, destination)(
        inCoordinates,
        outCoordinates,
        stride
      );
    } : getTransform(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  }
};
var Geometry_default = Geometry;

// node_modules/ol/geom/SimpleGeometry.js
var SimpleGeometry = class extends Geometry_default {
  constructor() {
    super();
    this.layout = "XY";
    this.stride = 2;
    this.flatCoordinates = null;
  }
  computeExtent(extent) {
    return createOrUpdateFromFlatCoordinates(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      extent
    );
  }
  getCoordinates() {
    return abstract();
  }
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  getLayout() {
    return this.layout;
  }
  getSimplifiedGeometry(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }
    const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      return simplifiedGeometry;
    }
    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
    return this;
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    return this;
  }
  getStride() {
    return this.stride;
  }
  setFlatCoordinates(layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  }
  setCoordinates(coordinates2, layout) {
    abstract();
  }
  setLayout(layout, coordinates2, nesting) {
    let stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (let i = 0; i < nesting; ++i) {
        if (coordinates2.length === 0) {
          this.layout = "XY";
          this.stride = 2;
          return;
        }
        coordinates2 = coordinates2[0];
      }
      stride = coordinates2.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  }
  applyTransform(transformFn) {
    if (this.flatCoordinates) {
      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
      this.changed();
    }
  }
  rotate(angle, anchor) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      rotate(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        angle,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }
  scale(sx, sy, anchor) {
    if (sy === void 0) {
      sy = sx;
    }
    if (!anchor) {
      anchor = getCenter(this.getExtent());
    }
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      scale(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        sx,
        sy,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }
  translate(deltaX, deltaY) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      translate(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        deltaX,
        deltaY,
        flatCoordinates
      );
      this.changed();
    }
  }
};
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = "XY";
  } else if (stride == 3) {
    layout = "XYZ";
  } else if (stride == 4) {
    layout = "XYZM";
  }
  return layout;
}
function getStrideForLayout(layout) {
  let stride;
  if (layout == "XY") {
    stride = 2;
  } else if (layout == "XYZ" || layout == "XYM") {
    stride = 3;
  } else if (layout == "XYZM") {
    stride = 4;
  }
  return stride;
}
var SimpleGeometry_default = SimpleGeometry;

// node_modules/ol/geom/flat/closest.js
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset3;
  if (dx === 0 && dy === 0) {
    offset3 = offset1;
  } else {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset3 = offset2;
    } else if (t > 0) {
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = lerp(
          flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i],
          t
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset3 = offset1;
    }
  }
  for (let i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset3 + i];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset2, end, stride, max) {
  let x1 = flatCoordinates[offset2];
  let y1 = flatCoordinates[offset2 + 1];
  for (offset2 += stride; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    const squaredDelta = squaredDistance(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset2, end, stride, max);
    offset2 = end;
  }
  return max;
}
function multiArrayMaxSquaredDelta(flatCoordinates, offset2, endss, stride, max) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    max = arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max);
    offset2 = ends[ends.length - 1];
  }
  return max;
}
function assignClosestPoint(flatCoordinates, offset2, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  if (offset2 == end) {
    return minSquaredDistance;
  }
  let i, squaredDistance2;
  if (maxDelta === 0) {
    squaredDistance2 = squaredDistance(
      x,
      y,
      flatCoordinates[offset2],
      flatCoordinates[offset2 + 1]
    );
    if (squaredDistance2 < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset2 + i];
      }
      closestPoint.length = stride;
      return squaredDistance2;
    }
    return minSquaredDistance;
  }
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  let index = offset2 + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates,
      index - stride,
      index,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance2 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      index += stride * Math.max(
        (Math.sqrt(squaredDistance2) - Math.sqrt(minSquaredDistance)) / maxDelta | 0,
        1
      );
    }
  }
  if (isRing) {
    assignClosest(
      flatCoordinates,
      end - stride,
      offset2,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance2 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance2 < minSquaredDistance) {
      minSquaredDistance = squaredDistance2;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset2, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset2,
      end,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset2 = end;
  }
  return minSquaredDistance;
}
function assignClosestMultiArrayPoint(flatCoordinates, offset2, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(
      flatCoordinates,
      offset2,
      ends,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset2 = ends[ends.length - 1];
  }
  return minSquaredDistance;
}

// node_modules/ol/geom/flat/deflate.js
function deflateCoordinate(flatCoordinates, offset2, coordinate, stride) {
  for (let i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset2++] = coordinate[i];
  }
  return offset2;
}
function deflateCoordinates(flatCoordinates, offset2, coordinates2, stride) {
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    const coordinate = coordinates2[i];
    for (let j = 0; j < stride; ++j) {
      flatCoordinates[offset2++] = coordinate[j];
    }
  }
  return offset2;
}
function deflateCoordinatesArray(flatCoordinates, offset2, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  let i = 0;
  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset2,
      coordinatess[j],
      stride
    );
    ends[i++] = end;
    offset2 = end;
  }
  ends.length = i;
  return ends;
}
function deflateMultiCoordinatesArray(flatCoordinates, offset2, coordinatesss, stride, endss) {
  endss = endss ? endss : [];
  let i = 0;
  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {
    const ends = deflateCoordinatesArray(
      flatCoordinates,
      offset2,
      coordinatesss[j],
      stride,
      endss[i]
    );
    if (ends.length === 0) {
      ends[0] = offset2;
    }
    endss[i++] = ends;
    offset2 = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
}

// node_modules/ol/geom/flat/simplify.js
function douglasPeucker(flatCoordinates, offset2, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  const n = (end - offset2) / stride;
  if (n < 3) {
    for (; offset2 < end; offset2 += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + 1];
    }
    return simplifiedOffset;
  }
  const markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  const stack = [offset2, end - stride];
  let index = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x2 = flatCoordinates[last];
    const y2 = flatCoordinates[last + 1];
    for (let i = first + stride; i < last; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      const squaredDistance2 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
      if (squaredDistance2 > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance2;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset2) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (let i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i * stride + 1];
    }
  }
  return simplifiedOffset;
}
function douglasPeuckerArray(flatCoordinates, offset2, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = douglasPeucker(
      flatCoordinates,
      offset2,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset2 = end;
  }
  return simplifiedOffset;
}
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset2, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset2 == end) {
    return simplifiedOffset;
  }
  let x1 = snap(flatCoordinates[offset2], tolerance);
  let y1 = snap(flatCoordinates[offset2 + 1], tolerance);
  offset2 += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2, y2;
  do {
    x2 = snap(flatCoordinates[offset2], tolerance);
    y2 = snap(flatCoordinates[offset2 + 1], tolerance);
    offset2 += stride;
    if (offset2 == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset2 < end) {
    const x3 = snap(flatCoordinates[offset2], tolerance);
    const y3 = snap(flatCoordinates[offset2 + 1], tolerance);
    offset2 += stride;
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    const dx2 = x3 - x1;
    const dy2 = y3 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x2 = x3;
      y2 = y3;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset2, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset2,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset2 = end;
  }
  return simplifiedOffset;
}
function quantizeMultiArray(flatCoordinates, offset2, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    const simplifiedEnds = [];
    simplifiedOffset = quantizeArray(
      flatCoordinates,
      offset2,
      ends,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
      simplifiedEnds
    );
    simplifiedEndss.push(simplifiedEnds);
    offset2 = ends[ends.length - 1];
  }
  return simplifiedOffset;
}

// node_modules/ol/geom/flat/inflate.js
function inflateCoordinates(flatCoordinates, offset2, end, stride, coordinates2) {
  coordinates2 = coordinates2 !== void 0 ? coordinates2 : [];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    coordinates2[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates2.length = i;
  return coordinates2;
}
function inflateCoordinatesArray(flatCoordinates, offset2, ends, stride, coordinatess) {
  coordinatess = coordinatess !== void 0 ? coordinatess : [];
  let i = 0;
  for (let j = 0, jj = ends.length; j < jj; ++j) {
    const end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates,
      offset2,
      end,
      stride,
      coordinatess[i]
    );
    offset2 = end;
  }
  coordinatess.length = i;
  return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset2, endss, stride, coordinatesss) {
  coordinatesss = coordinatesss !== void 0 ? coordinatesss : [];
  let i = 0;
  for (let j = 0, jj = endss.length; j < jj; ++j) {
    const ends = endss[j];
    coordinatesss[i++] = ends.length === 1 && ends[0] === offset2 ? [] : inflateCoordinatesArray(
      flatCoordinates,
      offset2,
      ends,
      stride,
      coordinatesss[i]
    );
    offset2 = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}

// node_modules/ol/geom/flat/interpolate.js
function interpolatePoint(flatCoordinates, offset2, end, stride, fraction, dest, dimension) {
  let o, t;
  const n = (end - offset2) / stride;
  if (n === 1) {
    o = offset2;
  } else if (n === 2) {
    o = offset2;
    t = fraction;
  } else if (n !== 0) {
    let x1 = flatCoordinates[offset2];
    let y1 = flatCoordinates[offset2 + 1];
    let length = 0;
    const cumulativeLengths = [0];
    for (let i = offset2 + stride; i < end; i += stride) {
      const x2 = flatCoordinates[i];
      const y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    const target = fraction * length;
    const index = binarySearch(cumulativeLengths, target);
    if (index < 0) {
      t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      o = offset2 + (-index - 2) * stride;
    } else {
      o = offset2 + index * stride;
    }
  }
  dimension = dimension > 1 ? dimension : 2;
  dest = dest ? dest : new Array(dimension);
  for (let i = 0; i < dimension; ++i) {
    dest[i] = o === void 0 ? NaN : t === void 0 ? flatCoordinates[o + i] : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
  }
  return dest;
}
function lineStringCoordinateAtM(flatCoordinates, offset2, end, stride, m, extrapolate) {
  if (end == offset2) {
    return null;
  }
  let coordinate;
  if (m < flatCoordinates[offset2 + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset2, offset2 + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  } else if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (m == flatCoordinates[offset2 + stride - 1]) {
    return flatCoordinates.slice(offset2, offset2 + stride);
  }
  let lo = offset2 / stride;
  let hi = end / stride;
  while (lo < hi) {
    const mid = lo + hi >> 1;
    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  const m0 = flatCoordinates[lo * stride - 1];
  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  const m1 = flatCoordinates[(lo + 1) * stride - 1];
  const t = (m - m0) / (m1 - m0);
  coordinate = [];
  for (let i = 0; i < stride - 1; ++i) {
    coordinate.push(
      lerp(
        flatCoordinates[(lo - 1) * stride + i],
        flatCoordinates[lo * stride + i],
        t
      )
    );
  }
  coordinate.push(m);
  return coordinate;
}
function lineStringsCoordinateAtM(flatCoordinates, offset2, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(
      flatCoordinates,
      offset2,
      ends[ends.length - 1],
      stride,
      m,
      extrapolate
    );
  }
  let coordinate;
  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    if (offset2 == end) {
      continue;
    }
    if (m < flatCoordinates[offset2 + stride - 1]) {
      return null;
    } else if (m <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(
        flatCoordinates,
        offset2,
        end,
        stride,
        m,
        false
      );
    }
    offset2 = end;
  }
  return null;
}

// node_modules/ol/geom/flat/length.js
function lineStringLength(flatCoordinates, offset2, end, stride) {
  let x1 = flatCoordinates[offset2];
  let y1 = flatCoordinates[offset2 + 1];
  let length = 0;
  for (let i = offset2 + stride; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}

// node_modules/ol/geom/LineString.js
var LineString = class extends SimpleGeometry_default {
  constructor(coordinates2, layout) {
    super();
    this.flatMidpoint_ = null;
    this.flatMidpointRevision_ = -1;
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
      this.setFlatCoordinates(
        layout,
        coordinates2
      );
    } else {
      this.setCoordinates(
        coordinates2,
        layout
      );
    }
  }
  appendCoordinate(coordinate) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = coordinate.slice();
    } else {
      extend2(this.flatCoordinates, coordinate);
    }
    this.changed();
  }
  clone() {
    const lineString = new LineString(
      this.flatCoordinates.slice(),
      this.layout
    );
    lineString.applyProperties(this);
    return lineString;
  }
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        maxSquaredDelta(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestPoint(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      false,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  forEachSegment(callback) {
    return forEach(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      callback
    );
  }
  getCoordinateAtM(m, extrapolate) {
    if (this.layout != "XYM" && this.layout != "XYZM") {
      return null;
    }
    extrapolate = extrapolate !== void 0 ? extrapolate : false;
    return lineStringCoordinateAtM(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      m,
      extrapolate
    );
  }
  getCoordinates() {
    return inflateCoordinates(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  getCoordinateAt(fraction, dest) {
    return interpolatePoint(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      fraction,
      dest,
      this.stride
    );
  }
  getLength() {
    return lineStringLength(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  getFlatMidpoint() {
    if (this.flatMidpointRevision_ != this.getRevision()) {
      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
      this.flatMidpointRevision_ = this.getRevision();
    }
    return this.flatMidpoint_;
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = douglasPeucker(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    return new LineString(simplifiedFlatCoordinates, "XY");
  }
  getType() {
    return "LineString";
  }
  intersectsExtent(extent) {
    return intersectsLineString(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      extent
    );
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinates(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride
    );
    this.changed();
  }
};
var LineString_default = LineString;

// node_modules/ol/geom/flat/area.js
function linearRing(flatCoordinates, offset2, end, stride) {
  let twiceArea = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset2, ends, stride) {
  let area = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    area += linearRing(flatCoordinates, offset2, end, stride);
    offset2 = end;
  }
  return area;
}
function linearRingss(flatCoordinates, offset2, endss, stride) {
  let area = 0;
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    area += linearRings(flatCoordinates, offset2, ends, stride);
    offset2 = ends[ends.length - 1];
  }
  return area;
}

// node_modules/ol/geom/LinearRing.js
var LinearRing = class extends SimpleGeometry_default {
  constructor(coordinates2, layout) {
    super();
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
      this.setFlatCoordinates(
        layout,
        coordinates2
      );
    } else {
      this.setCoordinates(
        coordinates2,
        layout
      );
    }
  }
  clone() {
    return new LinearRing(this.flatCoordinates.slice(), this.layout);
  }
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        maxSquaredDelta(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestPoint(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  getArea() {
    return linearRing(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  getCoordinates() {
    return inflateCoordinates(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = douglasPeucker(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    return new LinearRing(simplifiedFlatCoordinates, "XY");
  }
  getType() {
    return "LinearRing";
  }
  intersectsExtent(extent) {
    return false;
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinates(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride
    );
    this.changed();
  }
};
var LinearRing_default = LinearRing;

// node_modules/ol/geom/MultiLineString.js
var MultiLineString = class extends SimpleGeometry_default {
  constructor(coordinates2, layout, ends) {
    super();
    this.ends_ = [];
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    if (Array.isArray(coordinates2[0])) {
      this.setCoordinates(
        coordinates2,
        layout
      );
    } else if (layout !== void 0 && ends) {
      this.setFlatCoordinates(
        layout,
        coordinates2
      );
      this.ends_ = ends;
    } else {
      let layout2 = this.getLayout();
      const lineStrings = coordinates2;
      const flatCoordinates = [];
      const ends2 = [];
      for (let i = 0, ii = lineStrings.length; i < ii; ++i) {
        const lineString = lineStrings[i];
        if (i === 0) {
          layout2 = lineString.getLayout();
        }
        extend2(flatCoordinates, lineString.getFlatCoordinates());
        ends2.push(flatCoordinates.length);
      }
      this.setFlatCoordinates(layout2, flatCoordinates);
      this.ends_ = ends2;
    }
  }
  appendLineString(lineString) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = lineString.getFlatCoordinates().slice();
    } else {
      extend2(this.flatCoordinates, lineString.getFlatCoordinates().slice());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  }
  clone() {
    const multiLineString = new MultiLineString(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    multiLineString.applyProperties(this);
    return multiLineString;
  }
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        arrayMaxSquaredDelta(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestArrayPoint(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      false,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  getCoordinateAtM(m, extrapolate, interpolate) {
    if (this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0) {
      return null;
    }
    extrapolate = extrapolate !== void 0 ? extrapolate : false;
    interpolate = interpolate !== void 0 ? interpolate : false;
    return lineStringsCoordinateAtM(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      m,
      extrapolate,
      interpolate
    );
  }
  getCoordinates() {
    return inflateCoordinatesArray(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }
  getEnds() {
    return this.ends_;
  }
  getLineString(index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new LineString_default(
      this.flatCoordinates.slice(
        index === 0 ? 0 : this.ends_[index - 1],
        this.ends_[index]
      ),
      this.layout
    );
  }
  getLineStrings() {
    const flatCoordinates = this.flatCoordinates;
    const ends = this.ends_;
    const layout = this.layout;
    const lineStrings = [];
    let offset2 = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const lineString = new LineString_default(
        flatCoordinates.slice(offset2, end),
        layout
      );
      lineStrings.push(lineString);
      offset2 = end;
    }
    return lineStrings;
  }
  getFlatMidpoints() {
    const midpoints = [];
    const flatCoordinates = this.flatCoordinates;
    let offset2 = 0;
    const ends = this.ends_;
    const stride = this.stride;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const midpoint = interpolatePoint(
        flatCoordinates,
        offset2,
        end,
        stride,
        0.5
      );
      extend2(midpoints, midpoint);
      offset2 = end;
    }
    return midpoints;
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    const simplifiedEnds = [];
    simplifiedFlatCoordinates.length = douglasPeuckerArray(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0,
      simplifiedEnds
    );
    return new MultiLineString(simplifiedFlatCoordinates, "XY", simplifiedEnds);
  }
  getType() {
    return "MultiLineString";
  }
  intersectsExtent(extent) {
    return intersectsLineStringArray(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      extent
    );
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const ends = deflateCoordinatesArray(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};
var MultiLineString_default = MultiLineString;

// node_modules/ol/geom/Point.js
var Point = class extends SimpleGeometry_default {
  constructor(coordinates2, layout) {
    super();
    this.setCoordinates(coordinates2, layout);
  }
  clone() {
    const point = new Point(this.flatCoordinates.slice(), this.layout);
    point.applyProperties(this);
    return point;
  }
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    const flatCoordinates = this.flatCoordinates;
    const squaredDistance2 = squaredDistance(
      x,
      y,
      flatCoordinates[0],
      flatCoordinates[1]
    );
    if (squaredDistance2 < minSquaredDistance) {
      const stride = this.stride;
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
      closestPoint.length = stride;
      return squaredDistance2;
    }
    return minSquaredDistance;
  }
  getCoordinates() {
    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
  }
  computeExtent(extent) {
    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
  }
  getType() {
    return "Point";
  }
  intersectsExtent(extent) {
    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinate(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride
    );
    this.changed();
  }
};
var Point_default = Point;

// node_modules/ol/geom/MultiPoint.js
var MultiPoint = class extends SimpleGeometry_default {
  constructor(coordinates2, layout) {
    super();
    if (layout && !Array.isArray(coordinates2[0])) {
      this.setFlatCoordinates(
        layout,
        coordinates2
      );
    } else {
      this.setCoordinates(
        coordinates2,
        layout
      );
    }
  }
  appendPoint(point) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = point.getFlatCoordinates().slice();
    } else {
      extend2(this.flatCoordinates, point.getFlatCoordinates());
    }
    this.changed();
  }
  clone() {
    const multiPoint = new MultiPoint(
      this.flatCoordinates.slice(),
      this.layout
    );
    multiPoint.applyProperties(this);
    return multiPoint;
  }
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    const flatCoordinates = this.flatCoordinates;
    const stride = this.stride;
    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      const squaredDistance2 = squaredDistance(
        x,
        y,
        flatCoordinates[i],
        flatCoordinates[i + 1]
      );
      if (squaredDistance2 < minSquaredDistance) {
        minSquaredDistance = squaredDistance2;
        for (let j = 0; j < stride; ++j) {
          closestPoint[j] = flatCoordinates[i + j];
        }
        closestPoint.length = stride;
      }
    }
    return minSquaredDistance;
  }
  getCoordinates() {
    return inflateCoordinates(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  getPoint(index) {
    const n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
    if (index < 0 || n <= index) {
      return null;
    }
    return new Point_default(
      this.flatCoordinates.slice(
        index * this.stride,
        (index + 1) * this.stride
      ),
      this.layout
    );
  }
  getPoints() {
    const flatCoordinates = this.flatCoordinates;
    const layout = this.layout;
    const stride = this.stride;
    const points = [];
    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      const point = new Point_default(flatCoordinates.slice(i, i + stride), layout);
      points.push(point);
    }
    return points;
  }
  getType() {
    return "MultiPoint";
  }
  intersectsExtent(extent) {
    const flatCoordinates = this.flatCoordinates;
    const stride = this.stride;
    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      if (containsXY(extent, x, y)) {
        return true;
      }
    }
    return false;
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinates(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride
    );
    this.changed();
  }
};
var MultiPoint_default = MultiPoint;

// node_modules/ol/geom/flat/interiorpoint.js
function getInteriorPointOfArray(flatCoordinates, offset2, ends, stride, flatCenters, flatCentersOffset, dest) {
  let i, ii, x, x1, x2, y1, y2;
  const y = flatCenters[flatCentersOffset + 1];
  const intersections = [];
  for (let r = 0, rr = ends.length; r < rr; ++r) {
    const end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset2; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(ascending);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    const segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y, maxSegmentLength);
    return dest;
  }
  return [pointX, y, maxSegmentLength];
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset2, endss, stride, flatCenters) {
  let interiorPoints = [];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    interiorPoints = getInteriorPointOfArray(
      flatCoordinates,
      offset2,
      ends,
      stride,
      flatCenters,
      2 * i,
      interiorPoints
    );
    offset2 = ends[ends.length - 1];
  }
  return interiorPoints;
}

// node_modules/ol/geom/flat/reverse.js
function coordinates(flatCoordinates, offset2, end, stride) {
  while (offset2 < end - stride) {
    for (let i = 0; i < stride; ++i) {
      const tmp = flatCoordinates[offset2 + i];
      flatCoordinates[offset2 + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset2 += stride;
    end -= stride;
  }
}

// node_modules/ol/geom/flat/orient.js
function linearRingIsClockwise(flatCoordinates, offset2, end, stride) {
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset2, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset2,
      end,
      stride
    );
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset2 = end;
  }
  return true;
}
function linearRingssAreOriented(flatCoordinates, offset2, endss, stride, right) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (!linearRingsAreOriented(flatCoordinates, offset2, ends, stride, right)) {
      return false;
    }
    if (ends.length) {
      offset2 = ends[ends.length - 1];
    }
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset2, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset2,
      end,
      stride
    );
    const reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      coordinates(flatCoordinates, offset2, end, stride);
    }
    offset2 = end;
  }
  return offset2;
}
function orientLinearRingsArray(flatCoordinates, offset2, endss, stride, right) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    offset2 = orientLinearRings(
      flatCoordinates,
      offset2,
      endss[i],
      stride,
      right
    );
  }
  return offset2;
}
function inflateEnds(flatCoordinates, ends) {
  const endss = [];
  let offset2 = 0;
  let prevEndIndex = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    if (!linearRingIsClockwise(flatCoordinates, offset2, end, 2)) {
      endss.push(ends.slice(prevEndIndex, i + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }
      endss[endss.length - 1].push(ends[prevEndIndex]);
    }
    prevEndIndex = i + 1;
    offset2 = end;
  }
  return endss;
}

// node_modules/ol/geom/Polygon.js
var Polygon = class extends SimpleGeometry_default {
  constructor(coordinates2, layout, ends) {
    super();
    this.ends_ = [];
    this.flatInteriorPointRevision_ = -1;
    this.flatInteriorPoint_ = null;
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    this.orientedRevision_ = -1;
    this.orientedFlatCoordinates_ = null;
    if (layout !== void 0 && ends) {
      this.setFlatCoordinates(
        layout,
        coordinates2
      );
      this.ends_ = ends;
    } else {
      this.setCoordinates(
        coordinates2,
        layout
      );
    }
  }
  appendLinearRing(linearRing2) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
    } else {
      extend2(this.flatCoordinates, linearRing2.getFlatCoordinates());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  }
  clone() {
    const polygon = new Polygon(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    polygon.applyProperties(this);
    return polygon;
  }
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        arrayMaxSquaredDelta(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestArrayPoint(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  containsXY(x, y) {
    return linearRingsContainsXY(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      x,
      y
    );
  }
  getArea() {
    return linearRings(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  getCoordinates(right) {
    let flatCoordinates;
    if (right !== void 0) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }
    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
  }
  getEnds() {
    return this.ends_;
  }
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const flatCenter = getCenter(this.getExtent());
      this.flatInteriorPoint_ = getInteriorPointOfArray(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        flatCenter,
        0
      );
      this.flatInteriorPointRevision_ = this.getRevision();
    }
    return this.flatInteriorPoint_;
  }
  getInteriorPoint() {
    return new Point_default(this.getFlatInteriorPoint(), "XYM");
  }
  getLinearRingCount() {
    return this.ends_.length;
  }
  getLinearRing(index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new LinearRing_default(
      this.flatCoordinates.slice(
        index === 0 ? 0 : this.ends_[index - 1],
        this.ends_[index]
      ),
      this.layout
    );
  }
  getLinearRings() {
    const layout = this.layout;
    const flatCoordinates = this.flatCoordinates;
    const ends = this.ends_;
    const linearRings2 = [];
    let offset2 = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const linearRing2 = new LinearRing_default(
        flatCoordinates.slice(offset2, end),
        layout
      );
      linearRings2.push(linearRing2);
      offset2 = end;
    }
    return linearRings2;
  }
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const flatCoordinates = this.flatCoordinates;
      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = orientLinearRings(
          this.orientedFlatCoordinates_,
          0,
          this.ends_,
          this.stride
        );
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    const simplifiedEnds = [];
    simplifiedFlatCoordinates.length = quantizeArray(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates,
      0,
      simplifiedEnds
    );
    return new Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
  }
  getType() {
    return "Polygon";
  }
  intersectsExtent(extent) {
    return intersectsLinearRingArray(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      extent
    );
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const ends = deflateCoordinatesArray(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};
var Polygon_default = Polygon;

// node_modules/ol/geom/flat/center.js
function linearRingss2(flatCoordinates, offset2, endss, stride) {
  const flatCenters = [];
  let extent = createEmpty();
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    extent = createOrUpdateFromFlatCoordinates(
      flatCoordinates,
      offset2,
      ends[0],
      stride
    );
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset2 = ends[ends.length - 1];
  }
  return flatCenters;
}

// node_modules/ol/geom/MultiPolygon.js
var MultiPolygon = class extends SimpleGeometry_default {
  constructor(coordinates2, layout, endss) {
    super();
    this.endss_ = [];
    this.flatInteriorPointsRevision_ = -1;
    this.flatInteriorPoints_ = null;
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    this.orientedRevision_ = -1;
    this.orientedFlatCoordinates_ = null;
    if (!endss && !Array.isArray(coordinates2[0])) {
      let thisLayout = this.getLayout();
      const polygons = coordinates2;
      const flatCoordinates = [];
      const thisEndss = [];
      for (let i = 0, ii = polygons.length; i < ii; ++i) {
        const polygon = polygons[i];
        if (i === 0) {
          thisLayout = polygon.getLayout();
        }
        const offset2 = flatCoordinates.length;
        const ends = polygon.getEnds();
        for (let j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] += offset2;
        }
        extend2(flatCoordinates, polygon.getFlatCoordinates());
        thisEndss.push(ends);
      }
      layout = thisLayout;
      coordinates2 = flatCoordinates;
      endss = thisEndss;
    }
    if (layout !== void 0 && endss) {
      this.setFlatCoordinates(
        layout,
        coordinates2
      );
      this.endss_ = endss;
    } else {
      this.setCoordinates(
        coordinates2,
        layout
      );
    }
  }
  appendPolygon(polygon) {
    let ends;
    if (!this.flatCoordinates) {
      this.flatCoordinates = polygon.getFlatCoordinates().slice();
      ends = polygon.getEnds().slice();
      this.endss_.push();
    } else {
      const offset2 = this.flatCoordinates.length;
      extend2(this.flatCoordinates, polygon.getFlatCoordinates());
      ends = polygon.getEnds().slice();
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] += offset2;
      }
    }
    this.endss_.push(ends);
    this.changed();
  }
  clone() {
    const len = this.endss_.length;
    const newEndss = new Array(len);
    for (let i = 0; i < len; ++i) {
      newEndss[i] = this.endss_[i].slice();
    }
    const multiPolygon = new MultiPolygon(
      this.flatCoordinates.slice(),
      this.layout,
      newEndss
    );
    multiPolygon.applyProperties(this);
    return multiPolygon;
  }
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        multiArrayMaxSquaredDelta(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestMultiArrayPoint(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  containsXY(x, y) {
    return linearRingssContainsXY(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      x,
      y
    );
  }
  getArea() {
    return linearRingss(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }
  getCoordinates(right) {
    let flatCoordinates;
    if (right !== void 0) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      orientLinearRingsArray(
        flatCoordinates,
        0,
        this.endss_,
        this.stride,
        right
      );
    } else {
      flatCoordinates = this.flatCoordinates;
    }
    return inflateMultiCoordinatesArray(
      flatCoordinates,
      0,
      this.endss_,
      this.stride
    );
  }
  getEndss() {
    return this.endss_;
  }
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const flatCenters = linearRingss2(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        flatCenters
      );
      this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return this.flatInteriorPoints_;
  }
  getInteriorPoints() {
    return new MultiPoint_default(this.getFlatInteriorPoints().slice(), "XYM");
  }
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const flatCoordinates = this.flatCoordinates;
      if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = orientLinearRingsArray(
          this.orientedFlatCoordinates_,
          0,
          this.endss_,
          this.stride
        );
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    const simplifiedEndss = [];
    simplifiedFlatCoordinates.length = quantizeMultiArray(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates,
      0,
      simplifiedEndss
    );
    return new MultiPolygon(simplifiedFlatCoordinates, "XY", simplifiedEndss);
  }
  getPolygon(index) {
    if (index < 0 || this.endss_.length <= index) {
      return null;
    }
    let offset2;
    if (index === 0) {
      offset2 = 0;
    } else {
      const prevEnds = this.endss_[index - 1];
      offset2 = prevEnds[prevEnds.length - 1];
    }
    const ends = this.endss_[index].slice();
    const end = ends[ends.length - 1];
    if (offset2 !== 0) {
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] -= offset2;
      }
    }
    return new Polygon_default(
      this.flatCoordinates.slice(offset2, end),
      this.layout,
      ends
    );
  }
  getPolygons() {
    const layout = this.layout;
    const flatCoordinates = this.flatCoordinates;
    const endss = this.endss_;
    const polygons = [];
    let offset2 = 0;
    for (let i = 0, ii = endss.length; i < ii; ++i) {
      const ends = endss[i].slice();
      const end = ends[ends.length - 1];
      if (offset2 !== 0) {
        for (let j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] -= offset2;
        }
      }
      const polygon = new Polygon_default(
        flatCoordinates.slice(offset2, end),
        layout,
        ends
      );
      polygons.push(polygon);
      offset2 = end;
    }
    return polygons;
  }
  getType() {
    return "MultiPolygon";
  }
  intersectsExtent(extent) {
    return intersectsLinearRingMultiArray(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      extent
    );
  }
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 3);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const endss = deflateMultiCoordinatesArray(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride,
      this.endss_
    );
    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      const lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
    }
    this.changed();
  }
};
var MultiPolygon_default = MultiPolygon;

// node_modules/ol/format/EsriJSON.js
var GEOMETRY_READERS = {
  Point: readPointGeometry,
  LineString: readLineStringGeometry,
  Polygon: readPolygonGeometry,
  MultiPoint: readMultiPointGeometry,
  MultiLineString: readMultiLineStringGeometry,
  MultiPolygon: readMultiPolygonGeometry
};
var GEOMETRY_WRITERS = {
  Point: writePointGeometry,
  LineString: writeLineStringGeometry,
  Polygon: writePolygonGeometry,
  MultiPoint: writeMultiPointGeometry,
  MultiLineString: writeMultiLineStringGeometry,
  MultiPolygon: writeMultiPolygonGeometry
};
var EsriJSON = class extends JSONFeature_default {
  constructor(options) {
    options = options ? options : {};
    super();
    this.geometryName_ = options.geometryName;
  }
  readFeatureFromObject(object, options, idField) {
    const esriJSONFeature = object;
    const geometry = readGeometry(esriJSONFeature.geometry, options);
    const feature = new Feature_default();
    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    }
    feature.setGeometry(geometry);
    if (esriJSONFeature.attributes) {
      feature.setProperties(esriJSONFeature.attributes, true);
      const id = esriJSONFeature.attributes[idField];
      if (id !== void 0) {
        feature.setId(id);
      }
    }
    return feature;
  }
  readFeaturesFromObject(object, options) {
    options = options ? options : {};
    if (object["features"]) {
      const esriJSONFeatureSet = object;
      const features = [];
      const esriJSONFeatures = esriJSONFeatureSet.features;
      for (let i = 0, ii = esriJSONFeatures.length; i < ii; ++i) {
        features.push(
          this.readFeatureFromObject(
            esriJSONFeatures[i],
            options,
            object.objectIdFieldName
          )
        );
      }
      return features;
    }
    return [this.readFeatureFromObject(object, options)];
  }
  readGeometryFromObject(object, options) {
    return readGeometry(object, options);
  }
  readProjectionFromObject(object) {
    if (object["spatialReference"] && object["spatialReference"]["wkid"] !== void 0) {
      const spatialReference = object["spatialReference"];
      const crs = spatialReference.wkid;
      return get("EPSG:" + crs);
    }
    return null;
  }
  writeGeometryObject(geometry, options) {
    return writeGeometry(geometry, this.adaptOptions(options));
  }
  writeFeatureObject(feature, options) {
    options = this.adaptOptions(options);
    const object = {};
    if (!feature.hasProperties()) {
      object["attributes"] = {};
      return object;
    }
    const properties = feature.getProperties();
    const geometry = feature.getGeometry();
    if (geometry) {
      object["geometry"] = writeGeometry(geometry, options);
      const projection = options && (options.dataProjection || options.featureProjection);
      if (projection) {
        object["geometry"]["spatialReference"] = {
          wkid: Number(get(projection).getCode().split(":").pop())
        };
      }
      delete properties[feature.getGeometryName()];
    }
    if (!isEmpty(properties)) {
      object["attributes"] = properties;
    } else {
      object["attributes"] = {};
    }
    return object;
  }
  writeFeaturesObject(features, options) {
    options = this.adaptOptions(options);
    const objects = [];
    for (let i = 0, ii = features.length; i < ii; ++i) {
      objects.push(this.writeFeatureObject(features[i], options));
    }
    return {
      "features": objects
    };
  }
};
function readGeometry(object, options) {
  if (!object) {
    return null;
  }
  let type;
  if (typeof object["x"] === "number" && typeof object["y"] === "number") {
    type = "Point";
  } else if (object["points"]) {
    type = "MultiPoint";
  } else if (object["paths"]) {
    const esriJSONPolyline = object;
    if (esriJSONPolyline.paths.length === 1) {
      type = "LineString";
    } else {
      type = "MultiLineString";
    }
  } else if (object["rings"]) {
    const esriJSONPolygon = object;
    const layout = getGeometryLayout(esriJSONPolygon);
    const rings = convertRings(esriJSONPolygon.rings, layout);
    if (rings.length === 1) {
      type = "Polygon";
      object = Object.assign({}, object, { ["rings"]: rings[0] });
    } else {
      type = "MultiPolygon";
      object = Object.assign({}, object, { ["rings"]: rings });
    }
  }
  const geometryReader = GEOMETRY_READERS[type];
  return transformGeometryWithOptions(geometryReader(object), false, options);
}
function convertRings(rings, layout) {
  const flatRing = [];
  const outerRings = [];
  const holes = [];
  let i, ii;
  for (i = 0, ii = rings.length; i < ii; ++i) {
    flatRing.length = 0;
    deflateCoordinates(flatRing, 0, rings[i], layout.length);
    const clockwise = linearRingIsClockwise(
      flatRing,
      0,
      flatRing.length,
      layout.length
    );
    if (clockwise) {
      outerRings.push([rings[i]]);
    } else {
      holes.push(rings[i]);
    }
  }
  while (holes.length) {
    const hole = holes.shift();
    let matched = false;
    for (i = outerRings.length - 1; i >= 0; i--) {
      const outerRing = outerRings[i][0];
      const containsHole = containsExtent(
        new LinearRing_default(outerRing).getExtent(),
        new LinearRing_default(hole).getExtent()
      );
      if (containsHole) {
        outerRings[i].push(hole);
        matched = true;
        break;
      }
    }
    if (!matched) {
      outerRings.push([hole.reverse()]);
    }
  }
  return outerRings;
}
function readPointGeometry(object) {
  let point;
  if (object.m !== void 0 && object.z !== void 0) {
    point = new Point_default([object.x, object.y, object.z, object.m], "XYZM");
  } else if (object.z !== void 0) {
    point = new Point_default([object.x, object.y, object.z], "XYZ");
  } else if (object.m !== void 0) {
    point = new Point_default([object.x, object.y, object.m], "XYM");
  } else {
    point = new Point_default([object.x, object.y]);
  }
  return point;
}
function readLineStringGeometry(object) {
  const layout = getGeometryLayout(object);
  return new LineString_default(object.paths[0], layout);
}
function readMultiLineStringGeometry(object) {
  const layout = getGeometryLayout(object);
  return new MultiLineString_default(object.paths, layout);
}
function getGeometryLayout(object) {
  let layout = "XY";
  if (object.hasZ === true && object.hasM === true) {
    layout = "XYZM";
  } else if (object.hasZ === true) {
    layout = "XYZ";
  } else if (object.hasM === true) {
    layout = "XYM";
  }
  return layout;
}
function readMultiPointGeometry(object) {
  const layout = getGeometryLayout(object);
  return new MultiPoint_default(object.points, layout);
}
function readMultiPolygonGeometry(object) {
  const layout = getGeometryLayout(object);
  return new MultiPolygon_default(object.rings, layout);
}
function readPolygonGeometry(object) {
  const layout = getGeometryLayout(object);
  return new Polygon_default(object.rings, layout);
}
function writePointGeometry(geometry, options) {
  const coordinates2 = geometry.getCoordinates();
  let esriJSON;
  const layout = geometry.getLayout();
  if (layout === "XYZ") {
    esriJSON = {
      x: coordinates2[0],
      y: coordinates2[1],
      z: coordinates2[2]
    };
  } else if (layout === "XYM") {
    esriJSON = {
      x: coordinates2[0],
      y: coordinates2[1],
      m: coordinates2[2]
    };
  } else if (layout === "XYZM") {
    esriJSON = {
      x: coordinates2[0],
      y: coordinates2[1],
      z: coordinates2[2],
      m: coordinates2[3]
    };
  } else if (layout === "XY") {
    esriJSON = {
      x: coordinates2[0],
      y: coordinates2[1]
    };
  } else {
    assert(false, 34);
  }
  return esriJSON;
}
function getHasZM(geometry) {
  const layout = geometry.getLayout();
  return {
    hasZ: layout === "XYZ" || layout === "XYZM",
    hasM: layout === "XYM" || layout === "XYZM"
  };
}
function writeLineStringGeometry(lineString, options) {
  const hasZM = getHasZM(lineString);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    paths: [
      lineString.getCoordinates()
    ]
  };
}
function writePolygonGeometry(polygon, options) {
  const hasZM = getHasZM(polygon);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    rings: polygon.getCoordinates(false)
  };
}
function writeMultiLineStringGeometry(multiLineString, options) {
  const hasZM = getHasZM(multiLineString);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    paths: multiLineString.getCoordinates()
  };
}
function writeMultiPointGeometry(multiPoint, options) {
  const hasZM = getHasZM(multiPoint);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    points: multiPoint.getCoordinates()
  };
}
function writeMultiPolygonGeometry(geometry, options) {
  const hasZM = getHasZM(geometry);
  const coordinates2 = geometry.getCoordinates(false);
  const output = [];
  for (let i = 0; i < coordinates2.length; i++) {
    for (let x = coordinates2[i].length - 1; x >= 0; x--) {
      output.push(coordinates2[i][x]);
    }
  }
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    rings: output
  };
}
function writeGeometry(geometry, options) {
  const geometryWriter = GEOMETRY_WRITERS[geometry.getType()];
  return geometryWriter(
    transformGeometryWithOptions(geometry, true, options),
    options
  );
}
var EsriJSON_default = EsriJSON;

// node_modules/ol/geom/GeometryCollection.js
var GeometryCollection = class extends Geometry_default {
  constructor(geometries) {
    super();
    this.geometries_ = geometries ? geometries : null;
    this.changeEventsKeys_ = [];
    this.listenGeometriesChange_();
  }
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(unlistenByKey);
    this.changeEventsKeys_.length = 0;
  }
  listenGeometriesChange_() {
    if (!this.geometries_) {
      return;
    }
    for (let i = 0, ii = this.geometries_.length; i < ii; ++i) {
      this.changeEventsKeys_.push(
        listen(this.geometries_[i], EventType_default.CHANGE, this.changed, this)
      );
    }
  }
  clone() {
    const geometryCollection = new GeometryCollection(null);
    geometryCollection.setGeometries(this.geometries_);
    geometryCollection.applyProperties(this);
    return geometryCollection;
  }
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      minSquaredDistance = geometries[i].closestPointXY(
        x,
        y,
        closestPoint,
        minSquaredDistance
      );
    }
    return minSquaredDistance;
  }
  containsXY(x, y) {
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].containsXY(x, y)) {
        return true;
      }
    }
    return false;
  }
  computeExtent(extent) {
    createOrUpdateEmpty(extent);
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      extend(extent, geometries[i].getExtent());
    }
    return extent;
  }
  getGeometries() {
    return cloneGeometries(this.geometries_);
  }
  getGeometriesArray() {
    return this.geometries_;
  }
  getGeometriesArrayRecursive() {
    let geometriesArray = [];
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].getType() === this.getType()) {
        geometriesArray = geometriesArray.concat(
          geometries[i].getGeometriesArrayRecursive()
        );
      } else {
        geometriesArray.push(geometries[i]);
      }
    }
    return geometriesArray;
  }
  getSimplifiedGeometry(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }
    const simplifiedGeometries = [];
    const geometries = this.geometries_;
    let simplified = false;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      const geometry = geometries[i];
      const simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
      simplifiedGeometries.push(simplifiedGeometry);
      if (simplifiedGeometry !== geometry) {
        simplified = true;
      }
    }
    if (simplified) {
      const simplifiedGeometryCollection = new GeometryCollection(null);
      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
      return simplifiedGeometryCollection;
    }
    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
    return this;
  }
  getType() {
    return "GeometryCollection";
  }
  intersectsExtent(extent) {
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].intersectsExtent(extent)) {
        return true;
      }
    }
    return false;
  }
  isEmpty() {
    return this.geometries_.length === 0;
  }
  rotate(angle, anchor) {
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].rotate(angle, anchor);
    }
    this.changed();
  }
  scale(sx, sy, anchor) {
    if (!anchor) {
      anchor = getCenter(this.getExtent());
    }
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].scale(sx, sy, anchor);
    }
    this.changed();
  }
  setGeometries(geometries) {
    this.setGeometriesArray(cloneGeometries(geometries));
  }
  setGeometriesArray(geometries) {
    this.unlistenGeometriesChange_();
    this.geometries_ = geometries;
    this.listenGeometriesChange_();
    this.changed();
  }
  applyTransform(transformFn) {
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].applyTransform(transformFn);
    }
    this.changed();
  }
  translate(deltaX, deltaY) {
    const geometries = this.geometries_;
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].translate(deltaX, deltaY);
    }
    this.changed();
  }
  disposeInternal() {
    this.unlistenGeometriesChange_();
    super.disposeInternal();
  }
};
function cloneGeometries(geometries) {
  const clonedGeometries = [];
  for (let i = 0, ii = geometries.length; i < ii; ++i) {
    clonedGeometries.push(geometries[i].clone());
  }
  return clonedGeometries;
}
var GeometryCollection_default = GeometryCollection;

// node_modules/ol/format/GeoJSON.js
var GeoJSON = class extends JSONFeature_default {
  constructor(options) {
    options = options ? options : {};
    super();
    this.dataProjection = get(
      options.dataProjection ? options.dataProjection : "EPSG:4326"
    );
    if (options.featureProjection) {
      this.defaultFeatureProjection = get(options.featureProjection);
    }
    this.geometryName_ = options.geometryName;
    this.extractGeometryName_ = options.extractGeometryName;
    this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
  }
  readFeatureFromObject(object, options) {
    let geoJSONFeature = null;
    if (object["type"] === "Feature") {
      geoJSONFeature = object;
    } else {
      geoJSONFeature = {
        "type": "Feature",
        "geometry": object,
        "properties": null
      };
    }
    const geometry = readGeometry2(geoJSONFeature["geometry"], options);
    const feature = new Feature_default();
    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    } else if (this.extractGeometryName_ && "geometry_name" in geoJSONFeature !== void 0) {
      feature.setGeometryName(geoJSONFeature["geometry_name"]);
    }
    feature.setGeometry(geometry);
    if ("id" in geoJSONFeature) {
      feature.setId(geoJSONFeature["id"]);
    }
    if (geoJSONFeature["properties"]) {
      feature.setProperties(geoJSONFeature["properties"], true);
    }
    return feature;
  }
  readFeaturesFromObject(object, options) {
    const geoJSONObject = object;
    let features = null;
    if (geoJSONObject["type"] === "FeatureCollection") {
      const geoJSONFeatureCollection = object;
      features = [];
      const geoJSONFeatures = geoJSONFeatureCollection["features"];
      for (let i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
        features.push(this.readFeatureFromObject(geoJSONFeatures[i], options));
      }
    } else {
      features = [this.readFeatureFromObject(object, options)];
    }
    return features;
  }
  readGeometryFromObject(object, options) {
    return readGeometry2(object, options);
  }
  readProjectionFromObject(object) {
    const crs = object["crs"];
    let projection;
    if (crs) {
      if (crs["type"] == "name") {
        projection = get(crs["properties"]["name"]);
      } else if (crs["type"] === "EPSG") {
        projection = get("EPSG:" + crs["properties"]["code"]);
      } else {
        assert(false, 36);
      }
    } else {
      projection = this.dataProjection;
    }
    return projection;
  }
  writeFeatureObject(feature, options) {
    options = this.adaptOptions(options);
    const object = {
      "type": "Feature",
      geometry: null,
      properties: null
    };
    const id = feature.getId();
    if (id !== void 0) {
      object.id = id;
    }
    if (!feature.hasProperties()) {
      return object;
    }
    const properties = feature.getProperties();
    const geometry = feature.getGeometry();
    if (geometry) {
      object.geometry = writeGeometry2(geometry, options);
      delete properties[feature.getGeometryName()];
    }
    if (!isEmpty(properties)) {
      object.properties = properties;
    }
    return object;
  }
  writeFeaturesObject(features, options) {
    options = this.adaptOptions(options);
    const objects = [];
    for (let i = 0, ii = features.length; i < ii; ++i) {
      objects.push(this.writeFeatureObject(features[i], options));
    }
    return {
      type: "FeatureCollection",
      features: objects
    };
  }
  writeGeometryObject(geometry, options) {
    return writeGeometry2(geometry, this.adaptOptions(options));
  }
};
function readGeometry2(object, options) {
  if (!object) {
    return null;
  }
  let geometry;
  switch (object["type"]) {
    case "Point": {
      geometry = readPointGeometry2(object);
      break;
    }
    case "LineString": {
      geometry = readLineStringGeometry2(
        object
      );
      break;
    }
    case "Polygon": {
      geometry = readPolygonGeometry2(object);
      break;
    }
    case "MultiPoint": {
      geometry = readMultiPointGeometry2(
        object
      );
      break;
    }
    case "MultiLineString": {
      geometry = readMultiLineStringGeometry2(
        object
      );
      break;
    }
    case "MultiPolygon": {
      geometry = readMultiPolygonGeometry2(
        object
      );
      break;
    }
    case "GeometryCollection": {
      geometry = readGeometryCollectionGeometry(
        object
      );
      break;
    }
    default: {
      throw new Error("Unsupported GeoJSON type: " + object["type"]);
    }
  }
  return transformGeometryWithOptions(geometry, false, options);
}
function readGeometryCollectionGeometry(object, options) {
  const geometries = object["geometries"].map(
    function(geometry) {
      return readGeometry2(geometry, options);
    }
  );
  return new GeometryCollection_default(geometries);
}
function readPointGeometry2(object) {
  return new Point_default(object["coordinates"]);
}
function readLineStringGeometry2(object) {
  return new LineString_default(object["coordinates"]);
}
function readMultiLineStringGeometry2(object) {
  return new MultiLineString_default(object["coordinates"]);
}
function readMultiPointGeometry2(object) {
  return new MultiPoint_default(object["coordinates"]);
}
function readMultiPolygonGeometry2(object) {
  return new MultiPolygon_default(object["coordinates"]);
}
function readPolygonGeometry2(object) {
  return new Polygon_default(object["coordinates"]);
}
function writeGeometry2(geometry, options) {
  geometry = transformGeometryWithOptions(geometry, true, options);
  const type = geometry.getType();
  let geoJSON;
  switch (type) {
    case "Point": {
      geoJSON = writePointGeometry2(geometry, options);
      break;
    }
    case "LineString": {
      geoJSON = writeLineStringGeometry2(
        geometry,
        options
      );
      break;
    }
    case "Polygon": {
      geoJSON = writePolygonGeometry2(
        geometry,
        options
      );
      break;
    }
    case "MultiPoint": {
      geoJSON = writeMultiPointGeometry2(
        geometry,
        options
      );
      break;
    }
    case "MultiLineString": {
      geoJSON = writeMultiLineStringGeometry2(
        geometry,
        options
      );
      break;
    }
    case "MultiPolygon": {
      geoJSON = writeMultiPolygonGeometry2(
        geometry,
        options
      );
      break;
    }
    case "GeometryCollection": {
      geoJSON = writeGeometryCollectionGeometry(
        geometry,
        options
      );
      break;
    }
    case "Circle": {
      geoJSON = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default: {
      throw new Error("Unsupported geometry type: " + type);
    }
  }
  return geoJSON;
}
function writeGeometryCollectionGeometry(geometry, options) {
  options = Object.assign({}, options);
  delete options.featureProjection;
  const geometries = geometry.getGeometriesArray().map(function(geometry2) {
    return writeGeometry2(geometry2, options);
  });
  return {
    type: "GeometryCollection",
    geometries
  };
}
function writeLineStringGeometry2(geometry, options) {
  return {
    type: "LineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiLineStringGeometry2(geometry, options) {
  return {
    type: "MultiLineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPointGeometry2(geometry, options) {
  return {
    type: "MultiPoint",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPolygonGeometry2(geometry, options) {
  let right;
  if (options) {
    right = options.rightHanded;
  }
  return {
    type: "MultiPolygon",
    coordinates: geometry.getCoordinates(right)
  };
}
function writePointGeometry2(geometry, options) {
  return {
    type: "Point",
    coordinates: geometry.getCoordinates()
  };
}
function writePolygonGeometry2(geometry, options) {
  let right;
  if (options) {
    right = options.rightHanded;
  }
  return {
    type: "Polygon",
    coordinates: geometry.getCoordinates(right)
  };
}
var GeoJSON_default = GeoJSON;

// node_modules/ol/xml.js
var XML_SCHEMA_INSTANCE_URI = "http://www.w3.org/2001/XMLSchema-instance";
function createElementNS(namespaceURI, qualifiedName) {
  return getDocument().createElementNS(namespaceURI, qualifiedName);
}
function getAllTextContent(node, normalizeWhitespace) {
  return getAllTextContent_(node, normalizeWhitespace, []).join("");
}
function getAllTextContent_(node, normalizeWhitespace, accumulator) {
  if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {
    if (normalizeWhitespace) {
      accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ""));
    } else {
      accumulator.push(node.nodeValue);
    }
  } else {
    let n;
    for (n = node.firstChild; n; n = n.nextSibling) {
      getAllTextContent_(n, normalizeWhitespace, accumulator);
    }
  }
  return accumulator;
}
function isDocument(object) {
  return "documentElement" in object;
}
function getAttributeNS(node, namespaceURI, name) {
  return node.getAttributeNS(namespaceURI, name) || "";
}
function parse(xml) {
  return new DOMParser().parseFromString(xml, "application/xml");
}
function makeArrayExtender(valueReader, thisArg) {
  return function(node, objectStack) {
    const value = valueReader.call(
      thisArg !== void 0 ? thisArg : this,
      node,
      objectStack
    );
    if (value !== void 0) {
      const array = objectStack[objectStack.length - 1];
      extend2(array, value);
    }
  };
}
function makeArrayPusher(valueReader, thisArg) {
  return function(node, objectStack) {
    const value = valueReader.call(
      thisArg !== void 0 ? thisArg : this,
      node,
      objectStack
    );
    if (value !== void 0) {
      const array = objectStack[objectStack.length - 1];
      array.push(value);
    }
  };
}
function makeReplacer(valueReader, thisArg) {
  return function(node, objectStack) {
    const value = valueReader.call(
      thisArg !== void 0 ? thisArg : this,
      node,
      objectStack
    );
    if (value !== void 0) {
      objectStack[objectStack.length - 1] = value;
    }
  };
}
function makeObjectPropertyPusher(valueReader, property, thisArg) {
  return function(node, objectStack) {
    const value = valueReader.call(
      thisArg !== void 0 ? thisArg : this,
      node,
      objectStack
    );
    if (value !== void 0) {
      const object = objectStack[objectStack.length - 1];
      const name = property !== void 0 ? property : node.localName;
      let array;
      if (name in object) {
        array = object[name];
      } else {
        array = [];
        object[name] = array;
      }
      array.push(value);
    }
  };
}
function makeObjectPropertySetter(valueReader, property, thisArg) {
  return function(node, objectStack) {
    const value = valueReader.call(
      thisArg !== void 0 ? thisArg : this,
      node,
      objectStack
    );
    if (value !== void 0) {
      const object = objectStack[objectStack.length - 1];
      const name = property !== void 0 ? property : node.localName;
      object[name] = value;
    }
  };
}
function makeChildAppender(nodeWriter, thisArg) {
  return function(node, value, objectStack) {
    nodeWriter.call(
      thisArg !== void 0 ? thisArg : this,
      node,
      value,
      objectStack
    );
    const parent = objectStack[objectStack.length - 1];
    const parentNode = parent.node;
    parentNode.appendChild(node);
  };
}
function makeArraySerializer(nodeWriter, thisArg) {
  let serializersNS, nodeFactory;
  return function(node, value, objectStack) {
    if (serializersNS === void 0) {
      serializersNS = {};
      const serializers = {};
      serializers[node.localName] = nodeWriter;
      serializersNS[node.namespaceURI] = serializers;
      nodeFactory = makeSimpleNodeFactory(node.localName);
    }
    serialize(serializersNS, nodeFactory, value, objectStack);
  };
}
function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {
  return function(value, objectStack, newNodeName) {
    const context = objectStack[objectStack.length - 1];
    const node = context.node;
    let nodeName = fixedNodeName;
    if (nodeName === void 0) {
      nodeName = newNodeName;
    }
    const namespaceURI = fixedNamespaceURI !== void 0 ? fixedNamespaceURI : node.namespaceURI;
    return createElementNS(namespaceURI, nodeName);
  };
}
var OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();
function makeSequence(object, orderedKeys) {
  const length = orderedKeys.length;
  const sequence = new Array(length);
  for (let i = 0; i < length; ++i) {
    sequence[i] = object[orderedKeys[i]];
  }
  return sequence;
}
function makeStructureNS(namespaceURIs, structure, structureNS) {
  structureNS = structureNS !== void 0 ? structureNS : {};
  let i, ii;
  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
    structureNS[namespaceURIs[i]] = structure;
  }
  return structureNS;
}
function parseNode(parsersNS, node, objectStack, thisArg) {
  let n;
  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    const parsers = parsersNS[n.namespaceURI];
    if (parsers !== void 0) {
      const parser = parsers[n.localName];
      if (parser !== void 0) {
        parser.call(thisArg, n, objectStack);
      }
    }
  }
}
function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {
  objectStack.push(object);
  parseNode(parsersNS, node, objectStack, thisArg);
  return objectStack.pop();
}
function serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg) {
  const length = (keys !== void 0 ? keys : values).length;
  let value, node;
  for (let i = 0; i < length; ++i) {
    value = values[i];
    if (value !== void 0) {
      node = nodeFactory.call(
        thisArg !== void 0 ? thisArg : this,
        value,
        objectStack,
        keys !== void 0 ? keys[i] : void 0
      );
      if (node !== void 0) {
        serializersNS[node.namespaceURI][node.localName].call(
          thisArg,
          node,
          value,
          objectStack
        );
      }
    }
  }
}
function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, keys, thisArg) {
  objectStack.push(object);
  serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);
  return objectStack.pop();
}
var xmlSerializer_ = void 0;
function getXMLSerializer() {
  if (xmlSerializer_ === void 0 && typeof XMLSerializer !== "undefined") {
    xmlSerializer_ = new XMLSerializer();
  }
  return xmlSerializer_;
}
var document_ = void 0;
function getDocument() {
  if (document_ === void 0 && typeof document !== "undefined") {
    document_ = document.implementation.createDocument("", "", null);
  }
  return document_;
}

// node_modules/ol/format/XMLFeature.js
var XMLFeature = class extends Feature_default2 {
  constructor() {
    super();
    this.xmlSerializer_ = getXMLSerializer();
  }
  getType() {
    return "xml";
  }
  readFeature(source, options) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      const doc = parse(source);
      return this.readFeatureFromDocument(doc, options);
    } else if (isDocument(source)) {
      return this.readFeatureFromDocument(
        source,
        options
      );
    }
    return this.readFeatureFromNode(source, options);
  }
  readFeatureFromDocument(doc, options) {
    const features = this.readFeaturesFromDocument(doc, options);
    if (features.length > 0) {
      return features[0];
    }
    return null;
  }
  readFeatureFromNode(node, options) {
    return null;
  }
  readFeatures(source, options) {
    if (!source) {
      return [];
    } else if (typeof source === "string") {
      const doc = parse(source);
      return this.readFeaturesFromDocument(doc, options);
    } else if (isDocument(source)) {
      return this.readFeaturesFromDocument(
        source,
        options
      );
    }
    return this.readFeaturesFromNode(source, options);
  }
  readFeaturesFromDocument(doc, options) {
    const features = [];
    for (let n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        extend2(
          features,
          this.readFeaturesFromNode(n, options)
        );
      }
    }
    return features;
  }
  readFeaturesFromNode(node, options) {
    return abstract();
  }
  readGeometry(source, options) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      const doc = parse(source);
      return this.readGeometryFromDocument(doc, options);
    } else if (isDocument(source)) {
      return this.readGeometryFromDocument(
        source,
        options
      );
    }
    return this.readGeometryFromNode(source, options);
  }
  readGeometryFromDocument(doc, options) {
    return null;
  }
  readGeometryFromNode(node, options) {
    return null;
  }
  readProjection(source) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      const doc = parse(source);
      return this.readProjectionFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readProjectionFromDocument(source);
    }
    return this.readProjectionFromNode(source);
  }
  readProjectionFromDocument(doc) {
    return this.dataProjection;
  }
  readProjectionFromNode(node) {
    return this.dataProjection;
  }
  writeFeature(feature, options) {
    const node = this.writeFeatureNode(feature, options);
    return this.xmlSerializer_.serializeToString(node);
  }
  writeFeatureNode(feature, options) {
    return null;
  }
  writeFeatures(features, options) {
    const node = this.writeFeaturesNode(features, options);
    return this.xmlSerializer_.serializeToString(node);
  }
  writeFeaturesNode(features, options) {
    return null;
  }
  writeGeometry(geometry, options) {
    const node = this.writeGeometryNode(geometry, options);
    return this.xmlSerializer_.serializeToString(node);
  }
  writeGeometryNode(geometry, options) {
    return null;
  }
};
var XMLFeature_default = XMLFeature;

// node_modules/ol/format/GMLBase.js
var GMLNS = "http://www.opengis.net/gml";
var ONLY_WHITESPACE_RE = /^\s*$/;
var GMLBase = class extends XMLFeature_default {
  constructor(options) {
    super();
    options = options ? options : {};
    this.featureType = options.featureType;
    this.featureNS = options.featureNS;
    this.srsName = options.srsName;
    this.schemaLocation = "";
    this.FEATURE_COLLECTION_PARSERS = {};
    this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
      "featureMember": makeArrayPusher(this.readFeaturesInternal),
      "featureMembers": makeReplacer(this.readFeaturesInternal)
    };
    this.supportedMediaTypes = ["application/gml+xml"];
  }
  readFeaturesInternal(node, objectStack) {
    const localName = node.localName;
    let features = null;
    if (localName == "FeatureCollection") {
      features = pushParseAndPop(
        [],
        this.FEATURE_COLLECTION_PARSERS,
        node,
        objectStack,
        this
      );
    } else if (localName == "featureMembers" || localName == "featureMember" || localName == "member") {
      const context = objectStack[0];
      let featureType = context["featureType"];
      let featureNS = context["featureNS"];
      const prefix = "p";
      const defaultPrefix = "p0";
      if (!featureType && node.childNodes) {
        featureType = [], featureNS = {};
        for (let i = 0, ii = node.childNodes.length; i < ii; ++i) {
          const child = node.childNodes[i];
          if (child.nodeType === 1) {
            const ft = child.nodeName.split(":").pop();
            if (!featureType.includes(ft)) {
              let key = "";
              let count = 0;
              const uri = child.namespaceURI;
              for (const candidate in featureNS) {
                if (featureNS[candidate] === uri) {
                  key = candidate;
                  break;
                }
                ++count;
              }
              if (!key) {
                key = prefix + count;
                featureNS[key] = uri;
              }
              featureType.push(key + ":" + ft);
            }
          }
        }
        if (localName != "featureMember") {
          context["featureType"] = featureType;
          context["featureNS"] = featureNS;
        }
      }
      if (typeof featureNS === "string") {
        const ns = featureNS;
        featureNS = {};
        featureNS[defaultPrefix] = ns;
      }
      const parsersNS = {};
      const featureTypes = Array.isArray(featureType) ? featureType : [featureType];
      for (const p in featureNS) {
        const parsers = {};
        for (let i = 0, ii = featureTypes.length; i < ii; ++i) {
          const featurePrefix = featureTypes[i].includes(":") ? featureTypes[i].split(":")[0] : defaultPrefix;
          if (featurePrefix === p) {
            parsers[featureTypes[i].split(":").pop()] = localName == "featureMembers" ? makeArrayPusher(this.readFeatureElement, this) : makeReplacer(this.readFeatureElement, this);
          }
        }
        parsersNS[featureNS[p]] = parsers;
      }
      if (localName == "featureMember" || localName == "member") {
        features = pushParseAndPop(void 0, parsersNS, node, objectStack);
      } else {
        features = pushParseAndPop([], parsersNS, node, objectStack);
      }
    }
    if (features === null) {
      features = [];
    }
    return features;
  }
  readGeometryOrExtent(node, objectStack) {
    const context = objectStack[0];
    context["srsName"] = node.firstElementChild.getAttribute("srsName");
    context["srsDimension"] = node.firstElementChild.getAttribute("srsDimension");
    return pushParseAndPop(
      null,
      this.GEOMETRY_PARSERS,
      node,
      objectStack,
      this
    );
  }
  readExtentElement(node, objectStack) {
    const context = objectStack[0];
    const extent = this.readGeometryOrExtent(node, objectStack);
    return extent ? transformExtentWithOptions(extent, context) : void 0;
  }
  readGeometryElement(node, objectStack) {
    const context = objectStack[0];
    const geometry = this.readGeometryOrExtent(node, objectStack);
    return geometry ? transformGeometryWithOptions(geometry, false, context) : void 0;
  }
  readFeatureElementInternal(node, objectStack, asFeature) {
    let geometryName;
    const values = {};
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      let value;
      const localName = n.localName;
      if (n.childNodes.length === 0 || n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4)) {
        value = getAllTextContent(n, false);
        if (ONLY_WHITESPACE_RE.test(value)) {
          value = void 0;
        }
      } else {
        if (asFeature) {
          value = localName === "boundedBy" ? this.readExtentElement(n, objectStack) : this.readGeometryElement(n, objectStack);
        }
        if (!value) {
          value = this.readFeatureElementInternal(n, objectStack, false);
        } else if (localName !== "boundedBy") {
          geometryName = localName;
        }
      }
      const len = n.attributes.length;
      if (len > 0 && !(value instanceof Geometry_default)) {
        value = { _content_: value };
        for (let i = 0; i < len; i++) {
          const attName = n.attributes[i].name;
          value[attName] = n.attributes[i].value;
        }
      }
      if (values[localName]) {
        if (!(values[localName] instanceof Array)) {
          values[localName] = [values[localName]];
        }
        values[localName].push(value);
      } else {
        values[localName] = value;
      }
    }
    if (!asFeature) {
      return values;
    }
    const feature = new Feature_default(values);
    if (geometryName) {
      feature.setGeometryName(geometryName);
    }
    const fid = node.getAttribute("fid") || getAttributeNS(node, this.namespace, "id");
    if (fid) {
      feature.setId(fid);
    }
    return feature;
  }
  readFeatureElement(node, objectStack) {
    return this.readFeatureElementInternal(node, objectStack, true);
  }
  readPoint(node, objectStack) {
    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
    if (flatCoordinates) {
      return new Point_default(flatCoordinates, "XYZ");
    }
  }
  readMultiPoint(node, objectStack) {
    const coordinates2 = pushParseAndPop(
      [],
      this.MULTIPOINT_PARSERS,
      node,
      objectStack,
      this
    );
    if (coordinates2) {
      return new MultiPoint_default(coordinates2);
    }
    return void 0;
  }
  readMultiLineString(node, objectStack) {
    const lineStrings = pushParseAndPop(
      [],
      this.MULTILINESTRING_PARSERS,
      node,
      objectStack,
      this
    );
    if (lineStrings) {
      return new MultiLineString_default(lineStrings);
    }
  }
  readMultiPolygon(node, objectStack) {
    const polygons = pushParseAndPop(
      [],
      this.MULTIPOLYGON_PARSERS,
      node,
      objectStack,
      this
    );
    if (polygons) {
      return new MultiPolygon_default(polygons);
    }
  }
  pointMemberParser(node, objectStack) {
    parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);
  }
  lineStringMemberParser(node, objectStack) {
    parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);
  }
  polygonMemberParser(node, objectStack) {
    parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);
  }
  readLineString(node, objectStack) {
    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
    if (flatCoordinates) {
      const lineString = new LineString_default(flatCoordinates, "XYZ");
      return lineString;
    }
    return void 0;
  }
  readFlatLinearRing(node, objectStack) {
    const ring = pushParseAndPop(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      node,
      objectStack,
      this
    );
    if (ring) {
      return ring;
    }
    return void 0;
  }
  readLinearRing(node, objectStack) {
    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
    if (flatCoordinates) {
      return new LinearRing_default(flatCoordinates, "XYZ");
    }
  }
  readPolygon(node, objectStack) {
    const flatLinearRings = pushParseAndPop(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      node,
      objectStack,
      this
    );
    if (flatLinearRings && flatLinearRings[0]) {
      const flatCoordinates = flatLinearRings[0];
      const ends = [flatCoordinates.length];
      let i, ii;
      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
        extend2(flatCoordinates, flatLinearRings[i]);
        ends.push(flatCoordinates.length);
      }
      return new Polygon_default(flatCoordinates, "XYZ", ends);
    }
    return void 0;
  }
  readFlatCoordinatesFromNode(node, objectStack) {
    return pushParseAndPop(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      node,
      objectStack,
      this
    );
  }
  readGeometryFromNode(node, options) {
    const geometry = this.readGeometryElement(node, [
      this.getReadOptions(node, options ? options : {})
    ]);
    return geometry ? geometry : null;
  }
  readFeaturesFromNode(node, options) {
    const internalOptions = {
      featureType: this.featureType,
      featureNS: this.featureNS
    };
    if (internalOptions) {
      Object.assign(internalOptions, this.getReadOptions(node, options));
    }
    const features = this.readFeaturesInternal(node, [internalOptions]);
    return features || [];
  }
  readProjectionFromNode(node) {
    return get(
      this.srsName ? this.srsName : node.firstElementChild.getAttribute("srsName")
    );
  }
};
GMLBase.prototype.namespace = GMLNS;
GMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {}
};
GMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {}
};
GMLBase.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {}
};
GMLBase.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml": {
    "pointMember": makeArrayPusher(GMLBase.prototype.pointMemberParser),
    "pointMembers": makeArrayPusher(GMLBase.prototype.pointMemberParser)
  }
};
GMLBase.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml": {
    "lineStringMember": makeArrayPusher(
      GMLBase.prototype.lineStringMemberParser
    ),
    "lineStringMembers": makeArrayPusher(
      GMLBase.prototype.lineStringMemberParser
    )
  }
};
GMLBase.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml": {
    "polygonMember": makeArrayPusher(GMLBase.prototype.polygonMemberParser),
    "polygonMembers": makeArrayPusher(GMLBase.prototype.polygonMemberParser)
  }
};
GMLBase.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "Point": makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode)
  }
};
GMLBase.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "LineString": makeArrayPusher(GMLBase.prototype.readLineString)
  }
};
GMLBase.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "Polygon": makeArrayPusher(GMLBase.prototype.readPolygon)
  }
};
GMLBase.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    "LinearRing": makeReplacer(GMLBase.prototype.readFlatLinearRing)
  }
};
var GMLBase_default = GMLBase;

// node_modules/ol/format/xsd.js
function readBoolean(node) {
  const s = getAllTextContent(node, false);
  return readBooleanString(s);
}
function readBooleanString(string) {
  const m = /^\s*(true|1)|(false|0)\s*$/.exec(string);
  if (m) {
    return m[1] !== void 0 || false;
  }
  return void 0;
}
function readDateTime(node) {
  const s = getAllTextContent(node, false);
  const dateTime = Date.parse(s);
  return isNaN(dateTime) ? void 0 : dateTime / 1e3;
}
function readDecimal(node) {
  const s = getAllTextContent(node, false);
  return readDecimalString(s);
}
function readDecimalString(string) {
  const m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
  if (m) {
    return parseFloat(m[1]);
  }
  return void 0;
}
function readPositiveInteger(node) {
  const s = getAllTextContent(node, false);
  return readNonNegativeIntegerString(s);
}
function readNonNegativeIntegerString(string) {
  const m = /^\s*(\d+)\s*$/.exec(string);
  if (m) {
    return parseInt(m[1], 10);
  }
  return void 0;
}
function readString(node) {
  return getAllTextContent(node, false).trim();
}
function writeBooleanTextNode(node, bool) {
  writeStringTextNode(node, bool ? "1" : "0");
}
function writeCDATASection(node, string) {
  node.appendChild(getDocument().createCDATASection(string));
}
function writeDateTimeTextNode(node, dateTime) {
  const date = new Date(dateTime * 1e3);
  const string = date.getUTCFullYear() + "-" + padNumber(date.getUTCMonth() + 1, 2) + "-" + padNumber(date.getUTCDate(), 2) + "T" + padNumber(date.getUTCHours(), 2) + ":" + padNumber(date.getUTCMinutes(), 2) + ":" + padNumber(date.getUTCSeconds(), 2) + "Z";
  node.appendChild(getDocument().createTextNode(string));
}
function writeDecimalTextNode(node, decimal) {
  const string = decimal.toPrecision();
  node.appendChild(getDocument().createTextNode(string));
}
function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {
  const string = nonNegativeInteger.toString();
  node.appendChild(getDocument().createTextNode(string));
}
function writeStringTextNode(node, string) {
  node.appendChild(getDocument().createTextNode(string));
}

// node_modules/ol/format/GML2.js
var schemaLocation = GMLNS + " http://schemas.opengis.net/gml/2.1.2/feature.xsd";
var MULTIGEOMETRY_TO_MEMBER_NODENAME = {
  "MultiLineString": "lineStringMember",
  "MultiCurve": "curveMember",
  "MultiPolygon": "polygonMember",
  "MultiSurface": "surfaceMember"
};
var GML2 = class extends GMLBase_default {
  constructor(options) {
    options = options ? options : {};
    super(options);
    this.FEATURE_COLLECTION_PARSERS[GMLNS]["featureMember"] = makeArrayPusher(
      this.readFeaturesInternal
    );
    this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;
  }
  readFlatCoordinates(node, objectStack) {
    const s = getAllTextContent(node, false).replace(/^\s*|\s*$/g, "");
    const context = objectStack[0];
    const containerSrs = context["srsName"];
    let axisOrientation = "enu";
    if (containerSrs) {
      const proj = get(containerSrs);
      if (proj) {
        axisOrientation = proj.getAxisOrientation();
      }
    }
    const coordsGroups = s.trim().split(/\s+/);
    const flatCoordinates = [];
    for (let i = 0, ii = coordsGroups.length; i < ii; i++) {
      const coords = coordsGroups[i].split(/,+/);
      const x = parseFloat(coords[0]);
      const y = parseFloat(coords[1]);
      const z = coords.length === 3 ? parseFloat(coords[2]) : 0;
      if (axisOrientation.substr(0, 2) === "en") {
        flatCoordinates.push(x, y, z);
      } else {
        flatCoordinates.push(y, x, z);
      }
    }
    return flatCoordinates;
  }
  readBox(node, objectStack) {
    const flatCoordinates = pushParseAndPop(
      [null],
      this.BOX_PARSERS_,
      node,
      objectStack,
      this
    );
    return createOrUpdate(
      flatCoordinates[1][0],
      flatCoordinates[1][1],
      flatCoordinates[1][3],
      flatCoordinates[1][4]
    );
  }
  innerBoundaryIsParser(node, objectStack) {
    const flatLinearRing = pushParseAndPop(
      void 0,
      this.RING_PARSERS,
      node,
      objectStack,
      this
    );
    if (flatLinearRing) {
      const flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings.push(flatLinearRing);
    }
  }
  outerBoundaryIsParser(node, objectStack) {
    const flatLinearRing = pushParseAndPop(
      void 0,
      this.RING_PARSERS,
      node,
      objectStack,
      this
    );
    if (flatLinearRing) {
      const flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings[0] = flatLinearRing;
    }
  }
  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {
    const context = objectStack[objectStack.length - 1];
    const multiSurface = context["multiSurface"];
    const surface = context["surface"];
    const multiCurve = context["multiCurve"];
    if (!Array.isArray(value)) {
      nodeName = value.getType();
      if (nodeName === "MultiPolygon" && multiSurface === true) {
        nodeName = "MultiSurface";
      } else if (nodeName === "Polygon" && surface === true) {
        nodeName = "Surface";
      } else if (nodeName === "MultiLineString" && multiCurve === true) {
        nodeName = "MultiCurve";
      }
    } else {
      nodeName = "Envelope";
    }
    return createElementNS("http://www.opengis.net/gml", nodeName);
  }
  writeFeatureElement(node, feature, objectStack) {
    const fid = feature.getId();
    if (fid) {
      node.setAttribute("fid", fid);
    }
    const context = objectStack[objectStack.length - 1];
    const featureNS = context["featureNS"];
    const geometryName = feature.getGeometryName();
    if (!context.serializers) {
      context.serializers = {};
      context.serializers[featureNS] = {};
    }
    const keys = [];
    const values = [];
    if (feature.hasProperties()) {
      const properties = feature.getProperties();
      for (const key in properties) {
        const value = properties[key];
        if (value !== null) {
          keys.push(key);
          values.push(value);
          if (key == geometryName || typeof value.getSimplifiedGeometry === "function") {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = makeChildAppender(
                this.writeGeometryElement,
                this
              );
            }
          } else {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);
            }
          }
        }
      }
    }
    const item = Object.assign({}, context);
    item.node = node;
    pushSerializeAndPop(
      item,
      context.serializers,
      makeSimpleNodeFactory(void 0, featureNS),
      values,
      objectStack,
      keys
    );
  }
  writeCurveOrLineString(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context["srsName"];
    if (node.nodeName !== "LineStringSegment" && srsName) {
      node.setAttribute("srsName", srsName);
    }
    if (node.nodeName === "LineString" || node.nodeName === "LineStringSegment") {
      const coordinates2 = this.createCoordinatesNode_(node.namespaceURI);
      node.appendChild(coordinates2);
      this.writeCoordinates_(coordinates2, geometry, objectStack);
    } else if (node.nodeName === "Curve") {
      const segments = createElementNS(node.namespaceURI, "segments");
      node.appendChild(segments);
      this.writeCurveSegments_(segments, geometry, objectStack);
    }
  }
  writeLineStringOrCurveMember(node, line, objectStack) {
    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
    if (child) {
      node.appendChild(child);
      this.writeCurveOrLineString(child, line, objectStack);
    }
  }
  writeMultiCurveOrLineString(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context["hasZ"];
    const srsName = context["srsName"];
    const curve = context["curve"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    const lines = geometry.getLineStrings();
    pushSerializeAndPop(
      { node, hasZ, srsName, curve },
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      lines,
      objectStack,
      void 0,
      this
    );
  }
  writeGeometryElement(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const item = Object.assign({}, context);
    item["node"] = node;
    let value;
    if (Array.isArray(geometry)) {
      value = transformExtentWithOptions(
        geometry,
        context
      );
    } else {
      value = transformGeometryWithOptions(
        geometry,
        true,
        context
      );
    }
    pushSerializeAndPop(
      item,
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [value],
      objectStack,
      void 0,
      this
    );
  }
  createCoordinatesNode_(namespaceURI) {
    const coordinates2 = createElementNS(namespaceURI, "coordinates");
    coordinates2.setAttribute("decimal", ".");
    coordinates2.setAttribute("cs", ",");
    coordinates2.setAttribute("ts", " ");
    return coordinates2;
  }
  writeCoordinates_(node, value, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context["hasZ"];
    const srsName = context["srsName"];
    const points = value.getCoordinates();
    const len = points.length;
    const parts = new Array(len);
    for (let i = 0; i < len; ++i) {
      const point = points[i];
      parts[i] = this.getCoords_(point, srsName, hasZ);
    }
    writeStringTextNode(node, parts.join(" "));
  }
  writeCurveSegments_(node, line, objectStack) {
    const child = createElementNS(node.namespaceURI, "LineStringSegment");
    node.appendChild(child);
    this.writeCurveOrLineString(child, line, objectStack);
  }
  writeSurfaceOrPolygon(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context["hasZ"];
    const srsName = context["srsName"];
    if (node.nodeName !== "PolygonPatch" && srsName) {
      node.setAttribute("srsName", srsName);
    }
    if (node.nodeName === "Polygon" || node.nodeName === "PolygonPatch") {
      const rings = geometry.getLinearRings();
      pushSerializeAndPop(
        { node, hasZ, srsName },
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        rings,
        objectStack,
        void 0,
        this
      );
    } else if (node.nodeName === "Surface") {
      const patches = createElementNS(node.namespaceURI, "patches");
      node.appendChild(patches);
      this.writeSurfacePatches_(patches, geometry, objectStack);
    }
  }
  RING_NODE_FACTORY_(value, objectStack, nodeName) {
    const context = objectStack[objectStack.length - 1];
    const parentNode = context.node;
    const exteriorWritten = context["exteriorWritten"];
    if (exteriorWritten === void 0) {
      context["exteriorWritten"] = true;
    }
    return createElementNS(
      parentNode.namespaceURI,
      exteriorWritten !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs"
    );
  }
  writeSurfacePatches_(node, polygon, objectStack) {
    const child = createElementNS(node.namespaceURI, "PolygonPatch");
    node.appendChild(child);
    this.writeSurfaceOrPolygon(child, polygon, objectStack);
  }
  writeRing(node, ring, objectStack) {
    const linearRing2 = createElementNS(node.namespaceURI, "LinearRing");
    node.appendChild(linearRing2);
    this.writeLinearRing(linearRing2, ring, objectStack);
  }
  getCoords_(point, srsName, hasZ) {
    let axisOrientation = "enu";
    if (srsName) {
      axisOrientation = get(srsName).getAxisOrientation();
    }
    let coords = axisOrientation.substr(0, 2) === "en" ? point[0] + "," + point[1] : point[1] + "," + point[0];
    if (hasZ) {
      const z = point[2] || 0;
      coords += "," + z;
    }
    return coords;
  }
  writePoint(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context["hasZ"];
    const srsName = context["srsName"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    const coordinates2 = this.createCoordinatesNode_(node.namespaceURI);
    node.appendChild(coordinates2);
    const point = geometry.getCoordinates();
    const coord = this.getCoords_(point, srsName, hasZ);
    writeStringTextNode(coordinates2, coord);
  }
  writeMultiPoint(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context["hasZ"];
    const srsName = context["srsName"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    const points = geometry.getPoints();
    pushSerializeAndPop(
      { node, hasZ, srsName },
      this.POINTMEMBER_SERIALIZERS,
      makeSimpleNodeFactory("pointMember"),
      points,
      objectStack,
      void 0,
      this
    );
  }
  writePointMember(node, point, objectStack) {
    const child = createElementNS(node.namespaceURI, "Point");
    node.appendChild(child);
    this.writePoint(child, point, objectStack);
  }
  writeLinearRing(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context["srsName"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    const coordinates2 = this.createCoordinatesNode_(node.namespaceURI);
    node.appendChild(coordinates2);
    this.writeCoordinates_(coordinates2, geometry, objectStack);
  }
  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context["hasZ"];
    const srsName = context["srsName"];
    const surface = context["surface"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    const polygons = geometry.getPolygons();
    pushSerializeAndPop(
      { node, hasZ, srsName, surface },
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      polygons,
      objectStack,
      void 0,
      this
    );
  }
  writeSurfaceOrPolygonMember(node, polygon, objectStack) {
    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
    if (child) {
      node.appendChild(child);
      this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
  }
  writeEnvelope(node, extent, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context["srsName"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    const keys = ["lowerCorner", "upperCorner"];
    const values = [extent[0] + " " + extent[1], extent[2] + " " + extent[3]];
    pushSerializeAndPop(
      { node },
      this.ENVELOPE_SERIALIZERS,
      OBJECT_PROPERTY_NODE_FACTORY,
      values,
      objectStack,
      keys,
      this
    );
  }
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {
    const parentNode = objectStack[objectStack.length - 1].node;
    return createElementNS(
      "http://www.opengis.net/gml",
      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]
    );
  }
};
GML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    "coordinates": makeReplacer(GML2.prototype.readFlatCoordinates)
  }
};
GML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    "innerBoundaryIs": GML2.prototype.innerBoundaryIsParser,
    "outerBoundaryIs": GML2.prototype.outerBoundaryIsParser
  }
};
GML2.prototype.BOX_PARSERS_ = {
  "http://www.opengis.net/gml": {
    "coordinates": makeArrayPusher(GML2.prototype.readFlatCoordinates)
  }
};
GML2.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    "Point": makeReplacer(GMLBase_default.prototype.readPoint),
    "MultiPoint": makeReplacer(GMLBase_default.prototype.readMultiPoint),
    "LineString": makeReplacer(GMLBase_default.prototype.readLineString),
    "MultiLineString": makeReplacer(GMLBase_default.prototype.readMultiLineString),
    "LinearRing": makeReplacer(GMLBase_default.prototype.readLinearRing),
    "Polygon": makeReplacer(GMLBase_default.prototype.readPolygon),
    "MultiPolygon": makeReplacer(GMLBase_default.prototype.readMultiPolygon),
    "Box": makeReplacer(GML2.prototype.readBox)
  }
};
GML2.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "Curve": makeChildAppender(GML2.prototype.writeCurveOrLineString),
    "MultiCurve": makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),
    "Point": makeChildAppender(GML2.prototype.writePoint),
    "MultiPoint": makeChildAppender(GML2.prototype.writeMultiPoint),
    "LineString": makeChildAppender(GML2.prototype.writeCurveOrLineString),
    "MultiLineString": makeChildAppender(
      GML2.prototype.writeMultiCurveOrLineString
    ),
    "LinearRing": makeChildAppender(GML2.prototype.writeLinearRing),
    "Polygon": makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),
    "MultiPolygon": makeChildAppender(
      GML2.prototype.writeMultiSurfaceOrPolygon
    ),
    "Surface": makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),
    "MultiSurface": makeChildAppender(
      GML2.prototype.writeMultiSurfaceOrPolygon
    ),
    "Envelope": makeChildAppender(GML2.prototype.writeEnvelope)
  }
};
GML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lineStringMember": makeChildAppender(
      GML2.prototype.writeLineStringOrCurveMember
    ),
    "curveMember": makeChildAppender(
      GML2.prototype.writeLineStringOrCurveMember
    )
  }
};
GML2.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "outerBoundaryIs": makeChildAppender(GML2.prototype.writeRing),
    "innerBoundaryIs": makeChildAppender(GML2.prototype.writeRing)
  }
};
GML2.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "pointMember": makeChildAppender(GML2.prototype.writePointMember)
  }
};
GML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "surfaceMember": makeChildAppender(
      GML2.prototype.writeSurfaceOrPolygonMember
    ),
    "polygonMember": makeChildAppender(
      GML2.prototype.writeSurfaceOrPolygonMember
    )
  }
};
GML2.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lowerCorner": makeChildAppender(writeStringTextNode),
    "upperCorner": makeChildAppender(writeStringTextNode)
  }
};
var GML2_default = GML2;

// node_modules/ol/format/GML3.js
var schemaLocation2 = GMLNS + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd";
var MULTIGEOMETRY_TO_MEMBER_NODENAME2 = {
  "MultiLineString": "lineStringMember",
  "MultiCurve": "curveMember",
  "MultiPolygon": "polygonMember",
  "MultiSurface": "surfaceMember"
};
var GML3 = class extends GMLBase_default {
  constructor(options) {
    options = options ? options : {};
    super(options);
    this.surface_ = options.surface !== void 0 ? options.surface : false;
    this.curve_ = options.curve !== void 0 ? options.curve : false;
    this.multiCurve_ = options.multiCurve !== void 0 ? options.multiCurve : true;
    this.multiSurface_ = options.multiSurface !== void 0 ? options.multiSurface : true;
    this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation2;
    this.hasZ = options.hasZ !== void 0 ? options.hasZ : false;
  }
  readMultiCurve(node, objectStack) {
    const lineStrings = pushParseAndPop(
      [],
      this.MULTICURVE_PARSERS,
      node,
      objectStack,
      this
    );
    if (lineStrings) {
      const multiLineString = new MultiLineString_default(lineStrings);
      return multiLineString;
    }
    return void 0;
  }
  readFlatCurveRing(node, objectStack) {
    const lineStrings = pushParseAndPop(
      [],
      this.MULTICURVE_PARSERS,
      node,
      objectStack,
      this
    );
    const flatCoordinates = [];
    for (let i = 0, ii = lineStrings.length; i < ii; ++i) {
      extend2(flatCoordinates, lineStrings[i].getFlatCoordinates());
    }
    return flatCoordinates;
  }
  readMultiSurface(node, objectStack) {
    const polygons = pushParseAndPop(
      [],
      this.MULTISURFACE_PARSERS,
      node,
      objectStack,
      this
    );
    if (polygons) {
      return new MultiPolygon_default(polygons);
    }
  }
  curveMemberParser(node, objectStack) {
    parseNode(this.CURVEMEMBER_PARSERS, node, objectStack, this);
  }
  surfaceMemberParser(node, objectStack) {
    parseNode(this.SURFACEMEMBER_PARSERS, node, objectStack, this);
  }
  readPatch(node, objectStack) {
    return pushParseAndPop(
      [null],
      this.PATCHES_PARSERS,
      node,
      objectStack,
      this
    );
  }
  readSegment(node, objectStack) {
    return pushParseAndPop([], this.SEGMENTS_PARSERS, node, objectStack, this);
  }
  readPolygonPatch(node, objectStack) {
    return pushParseAndPop(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      node,
      objectStack,
      this
    );
  }
  readLineStringSegment(node, objectStack) {
    return pushParseAndPop(
      [null],
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      node,
      objectStack,
      this
    );
  }
  interiorParser(node, objectStack) {
    const flatLinearRing = pushParseAndPop(
      void 0,
      this.RING_PARSERS,
      node,
      objectStack,
      this
    );
    if (flatLinearRing) {
      const flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings.push(flatLinearRing);
    }
  }
  exteriorParser(node, objectStack) {
    const flatLinearRing = pushParseAndPop(
      void 0,
      this.RING_PARSERS,
      node,
      objectStack,
      this
    );
    if (flatLinearRing) {
      const flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings[0] = flatLinearRing;
    }
  }
  readSurface(node, objectStack) {
    const flatLinearRings = pushParseAndPop(
      [null],
      this.SURFACE_PARSERS,
      node,
      objectStack,
      this
    );
    if (flatLinearRings && flatLinearRings[0]) {
      const flatCoordinates = flatLinearRings[0];
      const ends = [flatCoordinates.length];
      let i, ii;
      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
        extend2(flatCoordinates, flatLinearRings[i]);
        ends.push(flatCoordinates.length);
      }
      return new Polygon_default(flatCoordinates, "XYZ", ends);
    }
    return void 0;
  }
  readCurve(node, objectStack) {
    const flatCoordinates = pushParseAndPop(
      [null],
      this.CURVE_PARSERS,
      node,
      objectStack,
      this
    );
    if (flatCoordinates) {
      const lineString = new LineString_default(flatCoordinates, "XYZ");
      return lineString;
    }
    return void 0;
  }
  readEnvelope(node, objectStack) {
    const flatCoordinates = pushParseAndPop(
      [null],
      this.ENVELOPE_PARSERS,
      node,
      objectStack,
      this
    );
    return createOrUpdate(
      flatCoordinates[1][0],
      flatCoordinates[1][1],
      flatCoordinates[2][0],
      flatCoordinates[2][1]
    );
  }
  readFlatPos(node, objectStack) {
    let s = getAllTextContent(node, false);
    const re = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/;
    const flatCoordinates = [];
    let m;
    while (m = re.exec(s)) {
      flatCoordinates.push(parseFloat(m[1]));
      s = s.substr(m[0].length);
    }
    if (s !== "") {
      return void 0;
    }
    const context = objectStack[0];
    const containerSrs = context["srsName"];
    let axisOrientation = "enu";
    if (containerSrs) {
      const proj = get(containerSrs);
      axisOrientation = proj.getAxisOrientation();
    }
    if (axisOrientation === "neu") {
      let i, ii;
      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {
        const y = flatCoordinates[i];
        const x = flatCoordinates[i + 1];
        flatCoordinates[i] = x;
        flatCoordinates[i + 1] = y;
      }
    }
    const len = flatCoordinates.length;
    if (len == 2) {
      flatCoordinates.push(0);
    }
    if (len === 0) {
      return void 0;
    }
    return flatCoordinates;
  }
  readFlatPosList(node, objectStack) {
    const s = getAllTextContent(node, false).replace(/^\s*|\s*$/g, "");
    const context = objectStack[0];
    const containerSrs = context["srsName"];
    const contextDimension = context["srsDimension"];
    let axisOrientation = "enu";
    if (containerSrs) {
      const proj = get(containerSrs);
      axisOrientation = proj.getAxisOrientation();
    }
    const coords = s.split(/\s+/);
    let dim = 2;
    if (node.getAttribute("srsDimension")) {
      dim = readNonNegativeIntegerString(node.getAttribute("srsDimension"));
    } else if (node.getAttribute("dimension")) {
      dim = readNonNegativeIntegerString(node.getAttribute("dimension"));
    } else if (node.parentNode.getAttribute("srsDimension")) {
      dim = readNonNegativeIntegerString(
        node.parentNode.getAttribute("srsDimension")
      );
    } else if (contextDimension) {
      dim = readNonNegativeIntegerString(contextDimension);
    }
    let x, y, z;
    const flatCoordinates = [];
    for (let i = 0, ii = coords.length; i < ii; i += dim) {
      x = parseFloat(coords[i]);
      y = parseFloat(coords[i + 1]);
      z = dim === 3 ? parseFloat(coords[i + 2]) : 0;
      if (axisOrientation.substr(0, 2) === "en") {
        flatCoordinates.push(x, y, z);
      } else {
        flatCoordinates.push(y, x, z);
      }
    }
    return flatCoordinates;
  }
  writePos_(node, value, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context["hasZ"];
    const srsDimension = hasZ ? "3" : "2";
    node.setAttribute("srsDimension", srsDimension);
    const srsName = context["srsName"];
    let axisOrientation = "enu";
    if (srsName) {
      axisOrientation = get(srsName).getAxisOrientation();
    }
    const point = value.getCoordinates();
    let coords;
    if (axisOrientation.substr(0, 2) === "en") {
      coords = point[0] + " " + point[1];
    } else {
      coords = point[1] + " " + point[0];
    }
    if (hasZ) {
      const z = point[2] || 0;
      coords += " " + z;
    }
    writeStringTextNode(node, coords);
  }
  getCoords_(point, srsName, hasZ) {
    let axisOrientation = "enu";
    if (srsName) {
      axisOrientation = get(srsName).getAxisOrientation();
    }
    let coords = axisOrientation.substr(0, 2) === "en" ? point[0] + " " + point[1] : point[1] + " " + point[0];
    if (hasZ) {
      const z = point[2] || 0;
      coords += " " + z;
    }
    return coords;
  }
  writePosList_(node, value, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context["hasZ"];
    const srsDimension = hasZ ? "3" : "2";
    node.setAttribute("srsDimension", srsDimension);
    const srsName = context["srsName"];
    const points = value.getCoordinates();
    const len = points.length;
    const parts = new Array(len);
    let point;
    for (let i = 0; i < len; ++i) {
      point = points[i];
      parts[i] = this.getCoords_(point, srsName, hasZ);
    }
    writeStringTextNode(node, parts.join(" "));
  }
  writePoint(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context["srsName"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    const pos = createElementNS(node.namespaceURI, "pos");
    node.appendChild(pos);
    this.writePos_(pos, geometry, objectStack);
  }
  writeEnvelope(node, extent, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context["srsName"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    const keys = ["lowerCorner", "upperCorner"];
    const values = [extent[0] + " " + extent[1], extent[2] + " " + extent[3]];
    pushSerializeAndPop(
      { node },
      this.ENVELOPE_SERIALIZERS,
      OBJECT_PROPERTY_NODE_FACTORY,
      values,
      objectStack,
      keys,
      this
    );
  }
  writeLinearRing(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context["srsName"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    const posList = createElementNS(node.namespaceURI, "posList");
    node.appendChild(posList);
    this.writePosList_(posList, geometry, objectStack);
  }
  RING_NODE_FACTORY_(value, objectStack, nodeName) {
    const context = objectStack[objectStack.length - 1];
    const parentNode = context.node;
    const exteriorWritten = context["exteriorWritten"];
    if (exteriorWritten === void 0) {
      context["exteriorWritten"] = true;
    }
    return createElementNS(
      parentNode.namespaceURI,
      exteriorWritten !== void 0 ? "interior" : "exterior"
    );
  }
  writeSurfaceOrPolygon(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context["hasZ"];
    const srsName = context["srsName"];
    if (node.nodeName !== "PolygonPatch" && srsName) {
      node.setAttribute("srsName", srsName);
    }
    if (node.nodeName === "Polygon" || node.nodeName === "PolygonPatch") {
      const rings = geometry.getLinearRings();
      pushSerializeAndPop(
        { node, hasZ, srsName },
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        rings,
        objectStack,
        void 0,
        this
      );
    } else if (node.nodeName === "Surface") {
      const patches = createElementNS(node.namespaceURI, "patches");
      node.appendChild(patches);
      this.writeSurfacePatches_(patches, geometry, objectStack);
    }
  }
  writeCurveOrLineString(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context["srsName"];
    if (node.nodeName !== "LineStringSegment" && srsName) {
      node.setAttribute("srsName", srsName);
    }
    if (node.nodeName === "LineString" || node.nodeName === "LineStringSegment") {
      const posList = createElementNS(node.namespaceURI, "posList");
      node.appendChild(posList);
      this.writePosList_(posList, geometry, objectStack);
    } else if (node.nodeName === "Curve") {
      const segments = createElementNS(node.namespaceURI, "segments");
      node.appendChild(segments);
      this.writeCurveSegments_(segments, geometry, objectStack);
    }
  }
  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context["hasZ"];
    const srsName = context["srsName"];
    const surface = context["surface"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    const polygons = geometry.getPolygons();
    pushSerializeAndPop(
      { node, hasZ, srsName, surface },
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      polygons,
      objectStack,
      void 0,
      this
    );
  }
  writeMultiPoint(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const srsName = context["srsName"];
    const hasZ = context["hasZ"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    const points = geometry.getPoints();
    pushSerializeAndPop(
      { node, hasZ, srsName },
      this.POINTMEMBER_SERIALIZERS,
      makeSimpleNodeFactory("pointMember"),
      points,
      objectStack,
      void 0,
      this
    );
  }
  writeMultiCurveOrLineString(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const hasZ = context["hasZ"];
    const srsName = context["srsName"];
    const curve = context["curve"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    const lines = geometry.getLineStrings();
    pushSerializeAndPop(
      { node, hasZ, srsName, curve },
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      lines,
      objectStack,
      void 0,
      this
    );
  }
  writeRing(node, ring, objectStack) {
    const linearRing2 = createElementNS(node.namespaceURI, "LinearRing");
    node.appendChild(linearRing2);
    this.writeLinearRing(linearRing2, ring, objectStack);
  }
  writeSurfaceOrPolygonMember(node, polygon, objectStack) {
    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
    if (child) {
      node.appendChild(child);
      this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
  }
  writePointMember(node, point, objectStack) {
    const child = createElementNS(node.namespaceURI, "Point");
    node.appendChild(child);
    this.writePoint(child, point, objectStack);
  }
  writeLineStringOrCurveMember(node, line, objectStack) {
    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
    if (child) {
      node.appendChild(child);
      this.writeCurveOrLineString(child, line, objectStack);
    }
  }
  writeSurfacePatches_(node, polygon, objectStack) {
    const child = createElementNS(node.namespaceURI, "PolygonPatch");
    node.appendChild(child);
    this.writeSurfaceOrPolygon(child, polygon, objectStack);
  }
  writeCurveSegments_(node, line, objectStack) {
    const child = createElementNS(node.namespaceURI, "LineStringSegment");
    node.appendChild(child);
    this.writeCurveOrLineString(child, line, objectStack);
  }
  writeGeometryElement(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const item = Object.assign({}, context);
    item["node"] = node;
    let value;
    if (Array.isArray(geometry)) {
      value = transformExtentWithOptions(
        geometry,
        context
      );
    } else {
      value = transformGeometryWithOptions(
        geometry,
        true,
        context
      );
    }
    pushSerializeAndPop(
      item,
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [value],
      objectStack,
      void 0,
      this
    );
  }
  writeFeatureElement(node, feature, objectStack) {
    const fid = feature.getId();
    if (fid) {
      node.setAttribute("fid", fid);
    }
    const context = objectStack[objectStack.length - 1];
    const featureNS = context["featureNS"];
    const geometryName = feature.getGeometryName();
    if (!context.serializers) {
      context.serializers = {};
      context.serializers[featureNS] = {};
    }
    const keys = [];
    const values = [];
    if (feature.hasProperties()) {
      const properties = feature.getProperties();
      for (const key in properties) {
        const value = properties[key];
        if (value !== null) {
          keys.push(key);
          values.push(value);
          if (key == geometryName || typeof value.getSimplifiedGeometry === "function") {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = makeChildAppender(
                this.writeGeometryElement,
                this
              );
            }
          } else {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);
            }
          }
        }
      }
    }
    const item = Object.assign({}, context);
    item.node = node;
    pushSerializeAndPop(
      item,
      context.serializers,
      makeSimpleNodeFactory(void 0, featureNS),
      values,
      objectStack,
      keys
    );
  }
  writeFeatureMembers_(node, features, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const featureType = context["featureType"];
    const featureNS = context["featureNS"];
    const serializers = {};
    serializers[featureNS] = {};
    serializers[featureNS][featureType] = makeChildAppender(
      this.writeFeatureElement,
      this
    );
    const item = Object.assign({}, context);
    item.node = node;
    pushSerializeAndPop(
      item,
      serializers,
      makeSimpleNodeFactory(featureType, featureNS),
      features,
      objectStack
    );
  }
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {
    const parentNode = objectStack[objectStack.length - 1].node;
    return createElementNS(
      this.namespace,
      MULTIGEOMETRY_TO_MEMBER_NODENAME2[parentNode.nodeName]
    );
  }
  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {
    const context = objectStack[objectStack.length - 1];
    const multiSurface = context["multiSurface"];
    const surface = context["surface"];
    const curve = context["curve"];
    const multiCurve = context["multiCurve"];
    if (!Array.isArray(value)) {
      nodeName = value.getType();
      if (nodeName === "MultiPolygon" && multiSurface === true) {
        nodeName = "MultiSurface";
      } else if (nodeName === "Polygon" && surface === true) {
        nodeName = "Surface";
      } else if (nodeName === "LineString" && curve === true) {
        nodeName = "Curve";
      } else if (nodeName === "MultiLineString" && multiCurve === true) {
        nodeName = "MultiCurve";
      }
    } else {
      nodeName = "Envelope";
    }
    return createElementNS(this.namespace, nodeName);
  }
  writeGeometryNode(geometry, options) {
    options = this.adaptOptions(options);
    const geom = createElementNS(this.namespace, "geom");
    const context = {
      node: geom,
      hasZ: this.hasZ,
      srsName: this.srsName,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_
    };
    if (options) {
      Object.assign(context, options);
    }
    this.writeGeometryElement(geom, geometry, [context]);
    return geom;
  }
  writeFeaturesNode(features, options) {
    options = this.adaptOptions(options);
    const node = createElementNS(this.namespace, "featureMembers");
    node.setAttributeNS(
      XML_SCHEMA_INSTANCE_URI,
      "xsi:schemaLocation",
      this.schemaLocation
    );
    const context = {
      srsName: this.srsName,
      hasZ: this.hasZ,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_,
      featureNS: this.featureNS,
      featureType: this.featureType
    };
    if (options) {
      Object.assign(context, options);
    }
    this.writeFeatureMembers_(node, features, [context]);
    return node;
  }
};
GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    "pos": makeReplacer(GML3.prototype.readFlatPos),
    "posList": makeReplacer(GML3.prototype.readFlatPosList),
    "coordinates": makeReplacer(GML2_default.prototype.readFlatCoordinates)
  }
};
GML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    "interior": GML3.prototype.interiorParser,
    "exterior": GML3.prototype.exteriorParser
  }
};
GML3.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    "Point": makeReplacer(GMLBase_default.prototype.readPoint),
    "MultiPoint": makeReplacer(GMLBase_default.prototype.readMultiPoint),
    "LineString": makeReplacer(GMLBase_default.prototype.readLineString),
    "MultiLineString": makeReplacer(GMLBase_default.prototype.readMultiLineString),
    "LinearRing": makeReplacer(GMLBase_default.prototype.readLinearRing),
    "Polygon": makeReplacer(GMLBase_default.prototype.readPolygon),
    "MultiPolygon": makeReplacer(GMLBase_default.prototype.readMultiPolygon),
    "Surface": makeReplacer(GML3.prototype.readSurface),
    "MultiSurface": makeReplacer(GML3.prototype.readMultiSurface),
    "Curve": makeReplacer(GML3.prototype.readCurve),
    "MultiCurve": makeReplacer(GML3.prototype.readMultiCurve),
    "Envelope": makeReplacer(GML3.prototype.readEnvelope)
  }
};
GML3.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    "curveMember": makeArrayPusher(GML3.prototype.curveMemberParser),
    "curveMembers": makeArrayPusher(GML3.prototype.curveMemberParser)
  }
};
GML3.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    "surfaceMember": makeArrayPusher(GML3.prototype.surfaceMemberParser),
    "surfaceMembers": makeArrayPusher(GML3.prototype.surfaceMemberParser)
  }
};
GML3.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "LineString": makeArrayPusher(GMLBase_default.prototype.readLineString),
    "Curve": makeArrayPusher(GML3.prototype.readCurve)
  }
};
GML3.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "Polygon": makeArrayPusher(GMLBase_default.prototype.readPolygon),
    "Surface": makeArrayPusher(GML3.prototype.readSurface)
  }
};
GML3.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    "patches": makeReplacer(GML3.prototype.readPatch)
  }
};
GML3.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    "segments": makeReplacer(GML3.prototype.readSegment)
  }
};
GML3.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml": {
    "lowerCorner": makeArrayPusher(GML3.prototype.readFlatPosList),
    "upperCorner": makeArrayPusher(GML3.prototype.readFlatPosList)
  }
};
GML3.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml": {
    "PolygonPatch": makeReplacer(GML3.prototype.readPolygonPatch)
  }
};
GML3.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml": {
    "LineStringSegment": makeArrayExtender(
      GML3.prototype.readLineStringSegment
    )
  }
};
GMLBase_default.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    "LinearRing": makeReplacer(GMLBase_default.prototype.readFlatLinearRing),
    "Ring": makeReplacer(GML3.prototype.readFlatCurveRing)
  }
};
GML3.prototype.writeFeatures;
GML3.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "exterior": makeChildAppender(GML3.prototype.writeRing),
    "interior": makeChildAppender(GML3.prototype.writeRing)
  }
};
GML3.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lowerCorner": makeChildAppender(writeStringTextNode),
    "upperCorner": makeChildAppender(writeStringTextNode)
  }
};
GML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "surfaceMember": makeChildAppender(
      GML3.prototype.writeSurfaceOrPolygonMember
    ),
    "polygonMember": makeChildAppender(
      GML3.prototype.writeSurfaceOrPolygonMember
    )
  }
};
GML3.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "pointMember": makeChildAppender(GML3.prototype.writePointMember)
  }
};
GML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lineStringMember": makeChildAppender(
      GML3.prototype.writeLineStringOrCurveMember
    ),
    "curveMember": makeChildAppender(
      GML3.prototype.writeLineStringOrCurveMember
    )
  }
};
GML3.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "Curve": makeChildAppender(GML3.prototype.writeCurveOrLineString),
    "MultiCurve": makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),
    "Point": makeChildAppender(GML3.prototype.writePoint),
    "MultiPoint": makeChildAppender(GML3.prototype.writeMultiPoint),
    "LineString": makeChildAppender(GML3.prototype.writeCurveOrLineString),
    "MultiLineString": makeChildAppender(
      GML3.prototype.writeMultiCurveOrLineString
    ),
    "LinearRing": makeChildAppender(GML3.prototype.writeLinearRing),
    "Polygon": makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),
    "MultiPolygon": makeChildAppender(
      GML3.prototype.writeMultiSurfaceOrPolygon
    ),
    "Surface": makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),
    "MultiSurface": makeChildAppender(
      GML3.prototype.writeMultiSurfaceOrPolygon
    ),
    "Envelope": makeChildAppender(GML3.prototype.writeEnvelope)
  }
};
var GML3_default = GML3;

// node_modules/ol/format/GML.js
var GML = GML3_default;
GML.prototype.writeFeatures;
GML.prototype.writeFeaturesNode;
var GML_default = GML;

// node_modules/ol/format/GPX.js
var NAMESPACE_URIS = [
  null,
  "http://www.topografix.com/GPX/1/0",
  "http://www.topografix.com/GPX/1/1"
];
var SCHEMA_LOCATION = "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd";
var FEATURE_READER = {
  "rte": readRte,
  "trk": readTrk,
  "wpt": readWpt
};
var GPX_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "rte": makeArrayPusher(readRte),
  "trk": makeArrayPusher(readTrk),
  "wpt": makeArrayPusher(readWpt)
});
var LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "text": makeObjectPropertySetter(readString, "linkText"),
  "type": makeObjectPropertySetter(readString, "linkType")
});
var GPX_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "rte": makeChildAppender(writeRte),
  "trk": makeChildAppender(writeTrk),
  "wpt": makeChildAppender(writeWpt)
});
var GPX = class extends XMLFeature_default {
  constructor(options) {
    super();
    options = options ? options : {};
    this.dataProjection = get("EPSG:4326");
    this.readExtensions_ = options.readExtensions;
  }
  handleReadExtensions_(features) {
    if (!features) {
      features = [];
    }
    for (let i = 0, ii = features.length; i < ii; ++i) {
      const feature = features[i];
      if (this.readExtensions_) {
        const extensionsNode = feature.get("extensionsNode_") || null;
        this.readExtensions_(feature, extensionsNode);
      }
      feature.set("extensionsNode_", void 0);
    }
  }
  readFeatureFromNode(node, options) {
    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {
      return null;
    }
    const featureReader = FEATURE_READER[node.localName];
    if (!featureReader) {
      return null;
    }
    const feature = featureReader(node, [this.getReadOptions(node, options)]);
    if (!feature) {
      return null;
    }
    this.handleReadExtensions_([feature]);
    return feature;
  }
  readFeaturesFromNode(node, options) {
    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {
      return [];
    }
    if (node.localName == "gpx") {
      const features = pushParseAndPop([], GPX_PARSERS, node, [
        this.getReadOptions(node, options)
      ]);
      if (features) {
        this.handleReadExtensions_(features);
        return features;
      }
      return [];
    }
    return [];
  }
  writeFeaturesNode(features, options) {
    options = this.adaptOptions(options);
    const gpx = createElementNS("http://www.topografix.com/GPX/1/1", "gpx");
    const xmlnsUri = "http://www.w3.org/2000/xmlns/";
    gpx.setAttributeNS(xmlnsUri, "xmlns:xsi", XML_SCHEMA_INSTANCE_URI);
    gpx.setAttributeNS(
      XML_SCHEMA_INSTANCE_URI,
      "xsi:schemaLocation",
      SCHEMA_LOCATION
    );
    gpx.setAttribute("version", "1.1");
    gpx.setAttribute("creator", "OpenLayers");
    pushSerializeAndPop(
      { node: gpx },
      GPX_SERIALIZERS,
      GPX_NODE_FACTORY,
      features,
      [options]
    );
    return gpx;
  }
};
var RTE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "number": makeObjectPropertySetter(readPositiveInteger),
  "extensions": parseExtensions,
  "type": makeObjectPropertySetter(readString),
  "rtept": parseRtePt
});
var RTEPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime)
});
var TRK_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "number": makeObjectPropertySetter(readPositiveInteger),
  "type": makeObjectPropertySetter(readString),
  "extensions": parseExtensions,
  "trkseg": parseTrkSeg
});
var TRKSEG_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "trkpt": parseTrkPt
});
var TRKPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime)
});
var WPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime),
  "magvar": makeObjectPropertySetter(readDecimal),
  "geoidheight": makeObjectPropertySetter(readDecimal),
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "sym": makeObjectPropertySetter(readString),
  "type": makeObjectPropertySetter(readString),
  "fix": makeObjectPropertySetter(readString),
  "sat": makeObjectPropertySetter(readPositiveInteger),
  "hdop": makeObjectPropertySetter(readDecimal),
  "vdop": makeObjectPropertySetter(readDecimal),
  "pdop": makeObjectPropertySetter(readDecimal),
  "ageofdgpsdata": makeObjectPropertySetter(readDecimal),
  "dgpsid": makeObjectPropertySetter(readPositiveInteger),
  "extensions": parseExtensions
});
var LINK_SEQUENCE = ["text", "type"];
var LINK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "text": makeChildAppender(writeStringTextNode),
  "type": makeChildAppender(writeStringTextNode)
});
var RTE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "number",
  "type",
  "rtept"
]);
var RTE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "number": makeChildAppender(writeNonNegativeIntegerTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "rtept": makeArraySerializer(makeChildAppender(writeWptType))
});
var RTEPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ["ele", "time"]);
var TRK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "number",
  "type",
  "trkseg"
]);
var TRK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "number": makeChildAppender(writeNonNegativeIntegerTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "trkseg": makeArraySerializer(makeChildAppender(writeTrkSeg))
});
var TRKSEG_NODE_FACTORY = makeSimpleNodeFactory("trkpt");
var TRKSEG_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "trkpt": makeChildAppender(writeWptType)
});
var WPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
  "ele",
  "time",
  "magvar",
  "geoidheight",
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "sym",
  "type",
  "fix",
  "sat",
  "hdop",
  "vdop",
  "pdop",
  "ageofdgpsdata",
  "dgpsid"
]);
var WPT_TYPE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "ele": makeChildAppender(writeDecimalTextNode),
  "time": makeChildAppender(writeDateTimeTextNode),
  "magvar": makeChildAppender(writeDecimalTextNode),
  "geoidheight": makeChildAppender(writeDecimalTextNode),
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "sym": makeChildAppender(writeStringTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "fix": makeChildAppender(writeStringTextNode),
  "sat": makeChildAppender(writeNonNegativeIntegerTextNode),
  "hdop": makeChildAppender(writeDecimalTextNode),
  "vdop": makeChildAppender(writeDecimalTextNode),
  "pdop": makeChildAppender(writeDecimalTextNode),
  "ageofdgpsdata": makeChildAppender(writeDecimalTextNode),
  "dgpsid": makeChildAppender(writeNonNegativeIntegerTextNode)
});
var GEOMETRY_TYPE_TO_NODENAME = {
  "Point": "wpt",
  "LineString": "rte",
  "MultiLineString": "trk"
};
function GPX_NODE_FACTORY(value, objectStack, nodeName) {
  const geometry = value.getGeometry();
  if (geometry) {
    const nodeName2 = GEOMETRY_TYPE_TO_NODENAME[geometry.getType()];
    if (nodeName2) {
      const parentNode = objectStack[objectStack.length - 1].node;
      return createElementNS(parentNode.namespaceURI, nodeName2);
    }
  }
}
function appendCoordinate(flatCoordinates, layoutOptions, node, values) {
  flatCoordinates.push(
    parseFloat(node.getAttribute("lon")),
    parseFloat(node.getAttribute("lat"))
  );
  if ("ele" in values) {
    flatCoordinates.push(values["ele"]);
    delete values["ele"];
    layoutOptions.hasZ = true;
  } else {
    flatCoordinates.push(0);
  }
  if ("time" in values) {
    flatCoordinates.push(values["time"]);
    delete values["time"];
    layoutOptions.hasM = true;
  } else {
    flatCoordinates.push(0);
  }
  return flatCoordinates;
}
function applyLayoutOptions(layoutOptions, flatCoordinates, ends) {
  let layout = "XY";
  let stride = 2;
  if (layoutOptions.hasZ && layoutOptions.hasM) {
    layout = "XYZM";
    stride = 4;
  } else if (layoutOptions.hasZ) {
    layout = "XYZ";
    stride = 3;
  } else if (layoutOptions.hasM) {
    layout = "XYM";
    stride = 3;
  }
  if (stride !== 4) {
    for (let i = 0, ii = flatCoordinates.length / 4; i < ii; i++) {
      flatCoordinates[i * stride] = flatCoordinates[i * 4];
      flatCoordinates[i * stride + 1] = flatCoordinates[i * 4 + 1];
      if (layoutOptions.hasZ) {
        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 2];
      }
      if (layoutOptions.hasM) {
        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 3];
      }
    }
    flatCoordinates.length = flatCoordinates.length / 4 * stride;
    if (ends) {
      for (let i = 0, ii = ends.length; i < ii; i++) {
        ends[i] = ends[i] / 4 * stride;
      }
    }
  }
  return layout;
}
function parseLink(node, objectStack) {
  const values = objectStack[objectStack.length - 1];
  const href = node.getAttribute("href");
  if (href !== null) {
    values["link"] = href;
  }
  parseNode(LINK_PARSERS, node, objectStack);
}
function parseExtensions(node, objectStack) {
  const values = objectStack[objectStack.length - 1];
  values["extensionsNode_"] = node;
}
function parseRtePt(node, objectStack) {
  const values = pushParseAndPop({}, RTEPT_PARSERS, node, objectStack);
  if (values) {
    const rteValues = objectStack[objectStack.length - 1];
    const flatCoordinates = rteValues["flatCoordinates"];
    const layoutOptions = rteValues["layoutOptions"];
    appendCoordinate(flatCoordinates, layoutOptions, node, values);
  }
}
function parseTrkPt(node, objectStack) {
  const values = pushParseAndPop({}, TRKPT_PARSERS, node, objectStack);
  if (values) {
    const trkValues = objectStack[objectStack.length - 1];
    const flatCoordinates = trkValues["flatCoordinates"];
    const layoutOptions = trkValues["layoutOptions"];
    appendCoordinate(flatCoordinates, layoutOptions, node, values);
  }
}
function parseTrkSeg(node, objectStack) {
  const values = objectStack[objectStack.length - 1];
  parseNode(TRKSEG_PARSERS, node, objectStack);
  const flatCoordinates = values["flatCoordinates"];
  const ends = values["ends"];
  ends.push(flatCoordinates.length);
}
function readRte(node, objectStack) {
  const options = objectStack[0];
  const values = pushParseAndPop(
    {
      "flatCoordinates": [],
      "layoutOptions": {}
    },
    RTE_PARSERS,
    node,
    objectStack
  );
  if (!values) {
    return void 0;
  }
  const flatCoordinates = values["flatCoordinates"];
  delete values["flatCoordinates"];
  const layoutOptions = values["layoutOptions"];
  delete values["layoutOptions"];
  const layout = applyLayoutOptions(layoutOptions, flatCoordinates);
  const geometry = new LineString_default(flatCoordinates, layout);
  transformGeometryWithOptions(geometry, false, options);
  const feature = new Feature_default(geometry);
  feature.setProperties(values, true);
  return feature;
}
function readTrk(node, objectStack) {
  const options = objectStack[0];
  const values = pushParseAndPop(
    {
      "flatCoordinates": [],
      "ends": [],
      "layoutOptions": {}
    },
    TRK_PARSERS,
    node,
    objectStack
  );
  if (!values) {
    return void 0;
  }
  const flatCoordinates = values["flatCoordinates"];
  delete values["flatCoordinates"];
  const ends = values["ends"];
  delete values["ends"];
  const layoutOptions = values["layoutOptions"];
  delete values["layoutOptions"];
  const layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);
  const geometry = new MultiLineString_default(flatCoordinates, layout, ends);
  transformGeometryWithOptions(geometry, false, options);
  const feature = new Feature_default(geometry);
  feature.setProperties(values, true);
  return feature;
}
function readWpt(node, objectStack) {
  const options = objectStack[0];
  const values = pushParseAndPop({}, WPT_PARSERS, node, objectStack);
  if (!values) {
    return void 0;
  }
  const layoutOptions = {};
  const coordinates2 = appendCoordinate([], layoutOptions, node, values);
  const layout = applyLayoutOptions(layoutOptions, coordinates2);
  const geometry = new Point_default(coordinates2, layout);
  transformGeometryWithOptions(geometry, false, options);
  const feature = new Feature_default(geometry);
  feature.setProperties(values, true);
  return feature;
}
function writeLink(node, value, objectStack) {
  node.setAttribute("href", value);
  const context = objectStack[objectStack.length - 1];
  const properties = context["properties"];
  const link = [properties["linkText"], properties["linkType"]];
  pushSerializeAndPop(
    { node },
    LINK_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    link,
    objectStack,
    LINK_SEQUENCE
  );
}
function writeWptType(node, coordinate, objectStack) {
  const context = objectStack[objectStack.length - 1];
  const parentNode = context.node;
  const namespaceURI = parentNode.namespaceURI;
  const properties = context["properties"];
  node.setAttributeNS(null, "lat", String(coordinate[1]));
  node.setAttributeNS(null, "lon", String(coordinate[0]));
  const geometryLayout = context["geometryLayout"];
  switch (geometryLayout) {
    case "XYZM":
      if (coordinate[3] !== 0) {
        properties["time"] = coordinate[3];
      }
    case "XYZ":
      if (coordinate[2] !== 0) {
        properties["ele"] = coordinate[2];
      }
      break;
    case "XYM":
      if (coordinate[2] !== 0) {
        properties["time"] = coordinate[2];
      }
      break;
    default:
  }
  const orderedKeys = node.nodeName == "rtept" ? RTEPT_TYPE_SEQUENCE[namespaceURI] : WPT_TYPE_SEQUENCE[namespaceURI];
  const values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(
    { node, "properties": properties },
    WPT_TYPE_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
}
function writeRte(node, feature, objectStack) {
  const options = objectStack[0];
  const properties = feature.getProperties();
  const context = { node };
  context["properties"] = properties;
  const geometry = feature.getGeometry();
  if (geometry.getType() == "LineString") {
    const lineString = transformGeometryWithOptions(geometry, true, options);
    context["geometryLayout"] = lineString.getLayout();
    properties["rtept"] = lineString.getCoordinates();
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];
  const values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(
    context,
    RTE_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
}
function writeTrk(node, feature, objectStack) {
  const options = objectStack[0];
  const properties = feature.getProperties();
  const context = { node };
  context["properties"] = properties;
  const geometry = feature.getGeometry();
  if (geometry.getType() == "MultiLineString") {
    const multiLineString = transformGeometryWithOptions(geometry, true, options);
    properties["trkseg"] = multiLineString.getLineStrings();
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];
  const values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(
    context,
    TRK_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
}
function writeTrkSeg(node, lineString, objectStack) {
  const context = { node };
  context["geometryLayout"] = lineString.getLayout();
  context["properties"] = {};
  pushSerializeAndPop(
    context,
    TRKSEG_SERIALIZERS,
    TRKSEG_NODE_FACTORY,
    lineString.getCoordinates(),
    objectStack
  );
}
function writeWpt(node, feature, objectStack) {
  const options = objectStack[0];
  const context = objectStack[objectStack.length - 1];
  context["properties"] = feature.getProperties();
  const geometry = feature.getGeometry();
  if (geometry.getType() == "Point") {
    const point = transformGeometryWithOptions(geometry, true, options);
    context["geometryLayout"] = point.getLayout();
    writeWptType(node, point.getCoordinates(), objectStack);
  }
}
var GPX_default = GPX;

// node_modules/ol/format/TextFeature.js
var TextFeature = class extends Feature_default2 {
  constructor() {
    super();
  }
  getType() {
    return "text";
  }
  readFeature(source, options) {
    return this.readFeatureFromText(
      getText(source),
      this.adaptOptions(options)
    );
  }
  readFeatureFromText(text, options) {
    return abstract();
  }
  readFeatures(source, options) {
    return this.readFeaturesFromText(
      getText(source),
      this.adaptOptions(options)
    );
  }
  readFeaturesFromText(text, options) {
    return abstract();
  }
  readGeometry(source, options) {
    return this.readGeometryFromText(
      getText(source),
      this.adaptOptions(options)
    );
  }
  readGeometryFromText(text, options) {
    return abstract();
  }
  readProjection(source) {
    return this.readProjectionFromText(getText(source));
  }
  readProjectionFromText(text) {
    return this.dataProjection;
  }
  writeFeature(feature, options) {
    return this.writeFeatureText(feature, this.adaptOptions(options));
  }
  writeFeatureText(feature, options) {
    return abstract();
  }
  writeFeatures(features, options) {
    return this.writeFeaturesText(features, this.adaptOptions(options));
  }
  writeFeaturesText(features, options) {
    return abstract();
  }
  writeGeometry(geometry, options) {
    return this.writeGeometryText(geometry, this.adaptOptions(options));
  }
  writeGeometryText(geometry, options) {
    return abstract();
  }
};
function getText(source) {
  if (typeof source === "string") {
    return source;
  }
  return "";
}
var TextFeature_default = TextFeature;

// node_modules/ol/format/IGC.js
var B_RECORD_RE = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/;
var H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;
var HFDTE_RECORD_RE = /^HFDTE(\d{2})(\d{2})(\d{2})/;
var NEWLINE_RE = /\r\n|\r|\n/;
var IGC = class extends TextFeature_default {
  constructor(options) {
    super();
    options = options ? options : {};
    this.dataProjection = get("EPSG:4326");
    this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : "none";
  }
  readFeatureFromText(text, options) {
    const altitudeMode = this.altitudeMode_;
    const lines = text.split(NEWLINE_RE);
    const properties = {};
    const flatCoordinates = [];
    let year = 2e3;
    let month = 0;
    let day = 1;
    let lastDateTime = -1;
    let i, ii;
    for (i = 0, ii = lines.length; i < ii; ++i) {
      const line = lines[i];
      let m;
      if (line.charAt(0) == "B") {
        m = B_RECORD_RE.exec(line);
        if (m) {
          const hour = parseInt(m[1], 10);
          const minute = parseInt(m[2], 10);
          const second = parseInt(m[3], 10);
          let y = parseInt(m[4], 10) + parseInt(m[5], 10) / 6e4;
          if (m[6] == "S") {
            y = -y;
          }
          let x = parseInt(m[7], 10) + parseInt(m[8], 10) / 6e4;
          if (m[9] == "W") {
            x = -x;
          }
          flatCoordinates.push(x, y);
          if (altitudeMode != "none") {
            let z;
            if (altitudeMode == "gps") {
              z = parseInt(m[11], 10);
            } else if (altitudeMode == "barometric") {
              z = parseInt(m[12], 10);
            } else {
              z = 0;
            }
            flatCoordinates.push(z);
          }
          let dateTime = Date.UTC(year, month, day, hour, minute, second);
          if (dateTime < lastDateTime) {
            dateTime = Date.UTC(year, month, day + 1, hour, minute, second);
          }
          flatCoordinates.push(dateTime / 1e3);
          lastDateTime = dateTime;
        }
      } else if (line.charAt(0) == "H") {
        m = HFDTE_RECORD_RE.exec(line);
        if (m) {
          day = parseInt(m[1], 10);
          month = parseInt(m[2], 10) - 1;
          year = 2e3 + parseInt(m[3], 10);
        } else {
          m = H_RECORD_RE.exec(line);
          if (m) {
            properties[m[1]] = m[2].trim();
          }
        }
      }
    }
    if (flatCoordinates.length === 0) {
      return null;
    }
    const layout = altitudeMode == "none" ? "XYM" : "XYZM";
    const lineString = new LineString_default(flatCoordinates, layout);
    const feature = new Feature_default(
      transformGeometryWithOptions(lineString, false, options)
    );
    feature.setProperties(properties, true);
    return feature;
  }
  readFeaturesFromText(text, options) {
    const feature = this.readFeatureFromText(text, options);
    if (feature) {
      return [feature];
    }
    return [];
  }
};
var IGC_default = IGC;

// node_modules/ol/format/IIIFInfo.js
var Versions = {
  VERSION1: "version1",
  VERSION2: "version2",
  VERSION3: "version3"
};
var IIIF_PROFILE_VALUES = {};
IIIF_PROFILE_VALUES[Versions.VERSION1] = {
  "level0": {
    supports: [],
    formats: [],
    qualities: ["native"]
  },
  "level1": {
    supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
    formats: ["jpg"],
    qualities: ["native"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["native", "color", "grey", "bitonal"]
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION2] = {
  "level0": {
    supports: [],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level1": {
    supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByDistortedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["default", "bitonal"]
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION3] = {
  "level0": {
    supports: [],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level1": {
    supports: ["regionByPx", "regionSquare", "sizeByW", "sizeByH", "sizeByWh"],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionSquare",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["default"]
  }
};
IIIF_PROFILE_VALUES["none"] = {
  "none": {
    supports: [],
    formats: [],
    qualities: []
  }
};
var COMPLIANCE_VERSION1 = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/;
var COMPLIANCE_VERSION2 = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/;
var COMPLIANCE_VERSION3 = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;
function generateVersion1Options(iiifInfo) {
  let levelProfile = iiifInfo.getComplianceLevelSupportedFeatures();
  if (levelProfile === void 0) {
    levelProfile = IIIF_PROFILE_VALUES[Versions.VERSION1]["level0"];
  }
  return {
    url: iiifInfo.imageInfo["@id"] === void 0 ? void 0 : iiifInfo.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
    supports: levelProfile.supports,
    formats: [
      ...levelProfile.formats,
      iiifInfo.imageInfo.formats === void 0 ? [] : iiifInfo.imageInfo.formats
    ],
    qualities: [
      ...levelProfile.qualities,
      iiifInfo.imageInfo.qualities === void 0 ? [] : iiifInfo.imageInfo.qualities
    ],
    resolutions: iiifInfo.imageInfo.scale_factors,
    tileSize: iiifInfo.imageInfo.tile_width !== void 0 ? iiifInfo.imageInfo.tile_height !== void 0 ? [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_height] : [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_width] : iiifInfo.imageInfo.tile_height != void 0 ? [iiifInfo.imageInfo.tile_height, iiifInfo.imageInfo.tile_height] : void 0
  };
}
function generateVersion2Options(iiifInfo) {
  const levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), additionalProfile = Array.isArray(iiifInfo.imageInfo.profile) && iiifInfo.imageInfo.profile.length > 1, profileSupports = additionalProfile && iiifInfo.imageInfo.profile[1].supports ? iiifInfo.imageInfo.profile[1].supports : [], profileFormats = additionalProfile && iiifInfo.imageInfo.profile[1].formats ? iiifInfo.imageInfo.profile[1].formats : [], profileQualities = additionalProfile && iiifInfo.imageInfo.profile[1].qualities ? iiifInfo.imageInfo.profile[1].qualities : [];
  return {
    url: iiifInfo.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
    sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [
      iiifInfo.imageInfo.tiles.map(function(tile) {
        return tile.width;
      })[0],
      iiifInfo.imageInfo.tiles.map(function(tile) {
        return tile.height === void 0 ? tile.width : tile.height;
      })[0]
    ],
    resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile) {
      return tile.scaleFactors;
    })[0],
    supports: [...levelProfile.supports, ...profileSupports],
    formats: [...levelProfile.formats, ...profileFormats],
    qualities: [...levelProfile.qualities, ...profileQualities]
  };
}
function generateVersion3Options(iiifInfo) {
  const levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), formats = iiifInfo.imageInfo.extraFormats === void 0 ? levelProfile.formats : [...levelProfile.formats, ...iiifInfo.imageInfo.extraFormats], preferredFormat = iiifInfo.imageInfo.preferredFormats !== void 0 && Array.isArray(iiifInfo.imageInfo.preferredFormats) && iiifInfo.imageInfo.preferredFormats.length > 0 ? iiifInfo.imageInfo.preferredFormats.filter(function(format) {
    return ["jpg", "png", "gif"].includes(format);
  }).reduce(function(acc, format) {
    return acc === void 0 && formats.includes(format) ? format : acc;
  }, void 0) : void 0;
  return {
    url: iiifInfo.imageInfo["id"],
    sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [
      iiifInfo.imageInfo.tiles.map(function(tile) {
        return tile.width;
      })[0],
      iiifInfo.imageInfo.tiles.map(function(tile) {
        return tile.height;
      })[0]
    ],
    resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile) {
      return tile.scaleFactors;
    })[0],
    supports: iiifInfo.imageInfo.extraFeatures === void 0 ? levelProfile.supports : [...levelProfile.supports, ...iiifInfo.imageInfo.extraFeatures],
    formats,
    qualities: iiifInfo.imageInfo.extraQualities === void 0 ? levelProfile.qualities : [...levelProfile.qualities, ...iiifInfo.imageInfo.extraQualities],
    preferredFormat
  };
}
var versionFunctions = {};
versionFunctions[Versions.VERSION1] = generateVersion1Options;
versionFunctions[Versions.VERSION2] = generateVersion2Options;
versionFunctions[Versions.VERSION3] = generateVersion3Options;
var IIIFInfo = class {
  constructor(imageInfo) {
    this.setImageInfo(imageInfo);
  }
  setImageInfo(imageInfo) {
    if (typeof imageInfo == "string") {
      this.imageInfo = JSON.parse(imageInfo);
    } else {
      this.imageInfo = imageInfo;
    }
  }
  getImageApiVersion() {
    if (this.imageInfo === void 0) {
      return;
    }
    let context = this.imageInfo["@context"] || "ol-no-context";
    if (typeof context == "string") {
      context = [context];
    }
    for (let i = 0; i < context.length; i++) {
      switch (context[i]) {
        case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
        case "http://iiif.io/api/image/1/context.json":
          return Versions.VERSION1;
        case "http://iiif.io/api/image/2/context.json":
          return Versions.VERSION2;
        case "http://iiif.io/api/image/3/context.json":
          return Versions.VERSION3;
        case "ol-no-context":
          if (this.getComplianceLevelEntryFromProfile(Versions.VERSION1) && this.imageInfo.identifier) {
            return Versions.VERSION1;
          }
          break;
        default:
      }
    }
    assert(false, 61);
  }
  getComplianceLevelEntryFromProfile(version) {
    if (this.imageInfo === void 0 || this.imageInfo.profile === void 0) {
      return;
    }
    if (version === void 0) {
      version = this.getImageApiVersion();
    }
    switch (version) {
      case Versions.VERSION1:
        if (COMPLIANCE_VERSION1.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        break;
      case Versions.VERSION3:
        if (COMPLIANCE_VERSION3.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        break;
      case Versions.VERSION2:
        if (typeof this.imageInfo.profile === "string" && COMPLIANCE_VERSION2.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] === "string" && COMPLIANCE_VERSION2.test(this.imageInfo.profile[0])) {
          return this.imageInfo.profile[0];
        }
        break;
      default:
    }
  }
  getComplianceLevelFromProfile(version) {
    const complianceLevel = this.getComplianceLevelEntryFromProfile(version);
    if (complianceLevel === void 0) {
      return void 0;
    }
    const level = complianceLevel.match(/level[0-2](?:\.json)?$/g);
    return Array.isArray(level) ? level[0].replace(".json", "") : void 0;
  }
  getComplianceLevelSupportedFeatures() {
    if (this.imageInfo === void 0) {
      return;
    }
    const version = this.getImageApiVersion();
    const level = this.getComplianceLevelFromProfile(version);
    if (level === void 0) {
      return IIIF_PROFILE_VALUES["none"]["none"];
    }
    return IIIF_PROFILE_VALUES[version][level];
  }
  getTileSourceOptions(preferredOptions) {
    const options = preferredOptions || {}, version = this.getImageApiVersion();
    if (version === void 0) {
      return;
    }
    const imageOptions = version === void 0 ? void 0 : versionFunctions[version](this);
    if (imageOptions === void 0) {
      return;
    }
    return {
      url: imageOptions.url,
      version,
      size: [this.imageInfo.width, this.imageInfo.height],
      sizes: imageOptions.sizes,
      format: options.format !== void 0 && imageOptions.formats.includes(options.format) ? options.format : imageOptions.preferredFormat !== void 0 ? imageOptions.preferredFormat : "jpg",
      supports: imageOptions.supports,
      quality: options.quality && imageOptions.qualities.includes(options.quality) ? options.quality : imageOptions.qualities.includes("native") ? "native" : "default",
      resolutions: Array.isArray(imageOptions.resolutions) ? imageOptions.resolutions.sort(function(a, b) {
        return b - a;
      }) : void 0,
      tileSize: imageOptions.tileSize
    };
  }
};
var IIIFInfo_default = IIIFInfo;

// node_modules/ol/style/Fill.js
var Fill = class {
  constructor(options) {
    options = options || {};
    this.color_ = options.color !== void 0 ? options.color : null;
  }
  clone() {
    const color = this.getColor();
    return new Fill({
      color: Array.isArray(color) ? color.slice() : color || void 0
    });
  }
  getColor() {
    return this.color_;
  }
  setColor(color) {
    this.color_ = color;
  }
};
var Fill_default = Fill;

// node_modules/ol/style/Image.js
var ImageStyle = class {
  constructor(options) {
    this.opacity_ = options.opacity;
    this.rotateWithView_ = options.rotateWithView;
    this.rotation_ = options.rotation;
    this.scale_ = options.scale;
    this.scaleArray_ = toSize(options.scale);
    this.displacement_ = options.displacement;
    this.declutterMode_ = options.declutterMode;
  }
  clone() {
    const scale2 = this.getScale();
    return new ImageStyle({
      opacity: this.getOpacity(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  getOpacity() {
    return this.opacity_;
  }
  getRotateWithView() {
    return this.rotateWithView_;
  }
  getRotation() {
    return this.rotation_;
  }
  getScale() {
    return this.scale_;
  }
  getScaleArray() {
    return this.scaleArray_;
  }
  getDisplacement() {
    return this.displacement_;
  }
  getDeclutterMode() {
    return this.declutterMode_;
  }
  getAnchor() {
    return abstract();
  }
  getImage(pixelRatio) {
    return abstract();
  }
  getHitDetectionImage() {
    return abstract();
  }
  getPixelRatio(pixelRatio) {
    return 1;
  }
  getImageState() {
    return abstract();
  }
  getImageSize() {
    return abstract();
  }
  getOrigin() {
    return abstract();
  }
  getSize() {
    return abstract();
  }
  setDisplacement(displacement) {
    this.displacement_ = displacement;
  }
  setOpacity(opacity) {
    this.opacity_ = opacity;
  }
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }
  setRotation(rotation) {
    this.rotation_ = rotation;
  }
  setScale(scale2) {
    this.scale_ = scale2;
    this.scaleArray_ = toSize(scale2);
  }
  listenImageChange(listener) {
    abstract();
  }
  load() {
    abstract();
  }
  unlistenImageChange(listener) {
    abstract();
  }
};
var Image_default = ImageStyle;

// node_modules/ol/color.js
var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
function asString(color) {
  if (typeof color === "string") {
    return color;
  }
  return toString(color);
}
function fromNamed(color) {
  const el = document.createElement("div");
  el.style.color = color;
  if (el.style.color !== "") {
    document.body.appendChild(el);
    const rgb = getComputedStyle(el).color;
    document.body.removeChild(el);
    return rgb;
  }
  return "";
}
var fromString = function() {
  const MAX_CACHE_SIZE = 1024;
  const cache = {};
  let cacheSize = 0;
  return function(s) {
    let color;
    if (cache.hasOwnProperty(s)) {
      color = cache[s];
    } else {
      if (cacheSize >= MAX_CACHE_SIZE) {
        let i = 0;
        for (const key in cache) {
          if ((i++ & 3) === 0) {
            delete cache[key];
            --cacheSize;
          }
        }
      }
      color = fromStringInternal_(s);
      cache[s] = color;
      ++cacheSize;
    }
    return color;
  };
}();
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  }
  return fromString(color);
}
function fromStringInternal_(s) {
  let r, g, b, a, color;
  if (NAMED_COLOR_RE_.exec(s)) {
    s = fromNamed(s);
  }
  if (HEX_COLOR_RE_.exec(s)) {
    const n = s.length - 1;
    let d;
    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }
    const hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);
    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }
    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;
      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }
    color = [r, g, b, a / 255];
  } else if (s.startsWith("rgba(")) {
    color = s.slice(5, -1).split(",").map(Number);
    normalize(color);
  } else if (s.startsWith("rgb(")) {
    color = s.slice(4, -1).split(",").map(Number);
    color.push(1);
    normalize(color);
  } else {
    assert(false, 14);
  }
  return color;
}
function normalize(color) {
  color[0] = clamp(color[0] + 0.5 | 0, 0, 255);
  color[1] = clamp(color[1] + 0.5 | 0, 0, 255);
  color[2] = clamp(color[2] + 0.5 | 0, 0, 255);
  color[3] = clamp(color[3], 0, 1);
  return color;
}
function toString(color) {
  let r = color[0];
  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }
  let g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  let b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  const a = color[3] === void 0 ? 1 : Math.round(color[3] * 100) / 100;
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
}

// node_modules/ol/style/IconImageCache.js
var IconImageCache = class {
  constructor() {
    this.cache_ = {};
    this.cacheSize_ = 0;
    this.maxCacheSize_ = 32;
  }
  clear() {
    this.cache_ = {};
    this.cacheSize_ = 0;
  }
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  expire() {
    if (this.canExpireCache()) {
      let i = 0;
      for (const key in this.cache_) {
        const iconImage = this.cache_[key];
        if ((i++ & 3) === 0 && !iconImage.hasListener()) {
          delete this.cache_[key];
          --this.cacheSize_;
        }
      }
    }
  }
  get(src, crossOrigin, color) {
    const key = getKey(src, crossOrigin, color);
    return key in this.cache_ ? this.cache_[key] : null;
  }
  set(src, crossOrigin, color, iconImage) {
    const key = getKey(src, crossOrigin, color);
    this.cache_[key] = iconImage;
    ++this.cacheSize_;
  }
  setSize(maxCacheSize) {
    this.maxCacheSize_ = maxCacheSize;
    this.expire();
  }
};
function getKey(src, crossOrigin, color) {
  const colorString = color ? asString(color) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
}
var shared = new IconImageCache();

// node_modules/ol/style/IconImage.js
var taintedTestContext = null;
var IconImage = class extends Target_default {
  constructor(image, src, size, crossOrigin, imageState, color) {
    super();
    this.hitDetectionImage_ = null;
    this.image_ = image;
    this.crossOrigin_ = crossOrigin;
    this.canvas_ = {};
    this.color_ = color;
    this.unlisten_ = null;
    this.imageState_ = imageState;
    this.size_ = size;
    this.src_ = src;
    this.tainted_;
  }
  initializeImage_() {
    this.image_ = new Image();
    if (this.crossOrigin_ !== null) {
      this.image_.crossOrigin = this.crossOrigin_;
    }
  }
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === ImageState_default.LOADED) {
      if (!taintedTestContext) {
        taintedTestContext = createCanvasContext2D(1, 1, void 0, {
          willReadFrequently: true
        });
      }
      taintedTestContext.drawImage(this.image_, 0, 0);
      try {
        taintedTestContext.getImageData(0, 0, 1, 1);
        this.tainted_ = false;
      } catch (e) {
        taintedTestContext = null;
        this.tainted_ = true;
      }
    }
    return this.tainted_ === true;
  }
  dispatchChangeEvent_() {
    this.dispatchEvent(EventType_default.CHANGE);
  }
  handleImageError_() {
    this.imageState_ = ImageState_default.ERROR;
    this.unlistenImage_();
    this.dispatchChangeEvent_();
  }
  handleImageLoad_() {
    this.imageState_ = ImageState_default.LOADED;
    if (this.size_) {
      this.image_.width = this.size_[0];
      this.image_.height = this.size_[1];
    } else {
      this.size_ = [this.image_.width, this.image_.height];
    }
    this.unlistenImage_();
    this.dispatchChangeEvent_();
  }
  getImage(pixelRatio) {
    if (!this.image_) {
      this.initializeImage_();
    }
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
  }
  getPixelRatio(pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? pixelRatio : 1;
  }
  getImageState() {
    return this.imageState_;
  }
  getHitDetectionImage() {
    if (!this.image_) {
      this.initializeImage_();
    }
    if (!this.hitDetectionImage_) {
      if (this.isTainted_()) {
        const width = this.size_[0];
        const height = this.size_[1];
        const context = createCanvasContext2D(width, height);
        context.fillRect(0, 0, width, height);
        this.hitDetectionImage_ = context.canvas;
      } else {
        this.hitDetectionImage_ = this.image_;
      }
    }
    return this.hitDetectionImage_;
  }
  getSize() {
    return this.size_;
  }
  getSrc() {
    return this.src_;
  }
  load() {
    if (this.imageState_ !== ImageState_default.IDLE) {
      return;
    }
    if (!this.image_) {
      this.initializeImage_();
    }
    this.imageState_ = ImageState_default.LOADING;
    try {
      this.image_.src = this.src_;
    } catch (e) {
      this.handleImageError_();
    }
    this.unlisten_ = listenImage(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    );
  }
  replaceColor_(pixelRatio) {
    if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState_default.LOADED) {
      return;
    }
    const image = this.image_;
    const canvas = document.createElement("canvas");
    canvas.width = Math.ceil(image.width * pixelRatio);
    canvas.height = Math.ceil(image.height * pixelRatio);
    const ctx = canvas.getContext("2d");
    ctx.scale(pixelRatio, pixelRatio);
    ctx.drawImage(image, 0, 0);
    ctx.globalCompositeOperation = "multiply";
    ctx.fillStyle = asString(this.color_);
    ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
    ctx.globalCompositeOperation = "destination-in";
    ctx.drawImage(image, 0, 0);
    this.canvas_[pixelRatio] = canvas;
  }
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
};
function get2(image, src, size, crossOrigin, imageState, color) {
  let iconImage = shared.get(src, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);
    shared.set(src, crossOrigin, color, iconImage);
  }
  return iconImage;
}

// node_modules/ol/style/Icon.js
var Icon = class extends Image_default {
  constructor(options) {
    options = options || {};
    const opacity = options.opacity !== void 0 ? options.opacity : 1;
    const rotation = options.rotation !== void 0 ? options.rotation : 0;
    const scale2 = options.scale !== void 0 ? options.scale : 1;
    const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
    super({
      opacity,
      rotation,
      scale: scale2,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      rotateWithView,
      declutterMode: options.declutterMode
    });
    this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
    this.normalizedAnchor_ = null;
    this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : "top-left";
    this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : "fraction";
    this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : "fraction";
    this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    const image = options.img !== void 0 ? options.img : null;
    this.imgSize_ = options.imgSize;
    let src = options.src;
    assert(!(src !== void 0 && image), 4);
    assert(!image || image && this.imgSize_, 5);
    if ((src === void 0 || src.length === 0) && image) {
      src = image.src || getUid(image);
    }
    assert(src !== void 0 && src.length > 0, 6);
    assert(
      !((options.width !== void 0 || options.height !== void 0) && options.scale !== void 0),
      69
    );
    const imageState = options.src !== void 0 ? ImageState_default.IDLE : ImageState_default.LOADED;
    this.color_ = options.color !== void 0 ? asArray(options.color) : null;
    this.iconImage_ = get2(
      image,
      src,
      this.imgSize_ !== void 0 ? this.imgSize_ : null,
      this.crossOrigin_,
      imageState,
      this.color_
    );
    this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
    this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : "top-left";
    this.origin_ = null;
    this.size_ = options.size !== void 0 ? options.size : null;
    this.width_ = options.width;
    this.height_ = options.height;
    if (this.width_ !== void 0 || this.height_ !== void 0) {
      const image2 = this.getImage(1);
      const setScale = () => {
        this.updateScaleFromWidthAndHeight(this.width_, this.height_);
      };
      if (image2.width > 0) {
        this.updateScaleFromWidthAndHeight(this.width_, this.height_);
      } else {
        image2.addEventListener("load", setScale);
      }
    }
  }
  clone() {
    let scale2 = this.getScale();
    scale2 = Array.isArray(scale2) ? scale2.slice() : scale2;
    if (this.width_ !== void 0 || this.height_ !== void 0) {
      scale2 = void 0;
    }
    return new Icon({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      imgSize: this.imgSize_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: scale2,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
      width: this.width_,
      height: this.height_
    });
  }
  updateScaleFromWidthAndHeight(width, height) {
    const image = this.getImage(1);
    if (width !== void 0 && height !== void 0) {
      super.setScale([width / image.width, height / image.height]);
    } else if (width !== void 0) {
      super.setScale([width / image.width, width / image.width]);
    } else if (height !== void 0) {
      super.setScale([height / image.height, height / image.height]);
    } else {
      super.setScale([1, 1]);
    }
  }
  getAnchor() {
    let anchor = this.normalizedAnchor_;
    if (!anchor) {
      anchor = this.anchor_;
      const size = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!size) {
          return null;
        }
        anchor = this.anchor_.slice();
        if (this.anchorXUnits_ == "fraction") {
          anchor[0] *= size[0];
        }
        if (this.anchorYUnits_ == "fraction") {
          anchor[1] *= size[1];
        }
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!size) {
          return null;
        }
        if (anchor === this.anchor_) {
          anchor = this.anchor_.slice();
        }
        if (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") {
          anchor[0] = -anchor[0] + size[0];
        }
        if (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") {
          anchor[1] = -anchor[1] + size[1];
        }
      }
      this.normalizedAnchor_ = anchor;
    }
    const displacement = this.getDisplacement();
    const scale2 = this.getScaleArray();
    return [
      anchor[0] - displacement[0] / scale2[0],
      anchor[1] + displacement[1] / scale2[1]
    ];
  }
  setAnchor(anchor) {
    this.anchor_ = anchor;
    this.normalizedAnchor_ = null;
  }
  getColor() {
    return this.color_;
  }
  getImage(pixelRatio) {
    return this.iconImage_.getImage(pixelRatio);
  }
  getPixelRatio(pixelRatio) {
    return this.iconImage_.getPixelRatio(pixelRatio);
  }
  getImageSize() {
    return this.iconImage_.getSize();
  }
  getImageState() {
    return this.iconImage_.getImageState();
  }
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  getOrigin() {
    if (this.origin_) {
      return this.origin_;
    }
    let offset2 = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const size = this.getSize();
      const iconImageSize = this.iconImage_.getSize();
      if (!size || !iconImageSize) {
        return null;
      }
      offset2 = offset2.slice();
      if (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") {
        offset2[0] = iconImageSize[0] - size[0] - offset2[0];
      }
      if (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") {
        offset2[1] = iconImageSize[1] - size[1] - offset2[1];
      }
    }
    this.origin_ = offset2;
    return this.origin_;
  }
  getSrc() {
    return this.iconImage_.getSrc();
  }
  getSize() {
    return !this.size_ ? this.iconImage_.getSize() : this.size_;
  }
  getWidth() {
    return this.width_;
  }
  getHeight() {
    return this.height_;
  }
  setWidth(width) {
    this.width_ = width;
    this.updateScaleFromWidthAndHeight(width, this.height_);
  }
  setHeight(height) {
    this.height_ = height;
    this.updateScaleFromWidthAndHeight(this.width_, height);
  }
  setScale(scale2) {
    super.setScale(scale2);
    const image = this.getImage(1);
    if (image) {
      const widthScale = Array.isArray(scale2) ? scale2[0] : scale2;
      if (widthScale !== void 0) {
        this.width_ = widthScale * image.width;
      }
      const heightScale = Array.isArray(scale2) ? scale2[1] : scale2;
      if (heightScale !== void 0) {
        this.height_ = heightScale * image.height;
      }
    }
  }
  listenImageChange(listener) {
    this.iconImage_.addEventListener(EventType_default.CHANGE, listener);
  }
  load() {
    this.iconImage_.load();
  }
  unlistenImageChange(listener) {
    this.iconImage_.removeEventListener(EventType_default.CHANGE, listener);
  }
};
var Icon_default = Icon;

// node_modules/ol/style/Stroke.js
var Stroke = class {
  constructor(options) {
    options = options || {};
    this.color_ = options.color !== void 0 ? options.color : null;
    this.lineCap_ = options.lineCap;
    this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
    this.lineDashOffset_ = options.lineDashOffset;
    this.lineJoin_ = options.lineJoin;
    this.miterLimit_ = options.miterLimit;
    this.width_ = options.width;
  }
  clone() {
    const color = this.getColor();
    return new Stroke({
      color: Array.isArray(color) ? color.slice() : color || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  getColor() {
    return this.color_;
  }
  getLineCap() {
    return this.lineCap_;
  }
  getLineDash() {
    return this.lineDash_;
  }
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  getLineJoin() {
    return this.lineJoin_;
  }
  getMiterLimit() {
    return this.miterLimit_;
  }
  getWidth() {
    return this.width_;
  }
  setColor(color) {
    this.color_ = color;
  }
  setLineCap(lineCap) {
    this.lineCap_ = lineCap;
  }
  setLineDash(lineDash) {
    this.lineDash_ = lineDash;
  }
  setLineDashOffset(lineDashOffset) {
    this.lineDashOffset_ = lineDashOffset;
  }
  setLineJoin(lineJoin) {
    this.lineJoin_ = lineJoin;
  }
  setMiterLimit(miterLimit) {
    this.miterLimit_ = miterLimit;
  }
  setWidth(width) {
    this.width_ = width;
  }
};
var Stroke_default = Stroke;

// node_modules/ol/css.js
var fontRegEx = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
  ].join(""),
  "i"
);
var fontRegExMatchIndex = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
];
var getFontParameters = function(fontSpec) {
  const match = fontSpec.match(fontRegEx);
  if (!match) {
    return null;
  }
  const style = {
    lineHeight: "normal",
    size: "1.2em",
    style: "normal",
    weight: "normal",
    variant: "normal"
  };
  for (let i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
    const value = match[i + 1];
    if (value !== void 0) {
      style[fontRegExMatchIndex[i]] = value;
    }
  }
  style.families = style.family.split(/,\s?/);
  return style;
};

// node_modules/ol/render/canvas.js
var checkedFonts = new Object_default();
var measureContext = null;
var measureFont;
var textHeights = {};
var registerFont = function() {
  const retries = 100;
  const size = "32px ";
  const referenceFonts = ["monospace", "serif"];
  const len = referenceFonts.length;
  const text = "wmytzilWMYTZIL@#/&?$%10\uF013";
  let interval, referenceWidth;
  function isAvailable(fontStyle, fontWeight, fontFamily) {
    let available = true;
    for (let i = 0; i < len; ++i) {
      const referenceFont = referenceFonts[i];
      referenceWidth = measureTextWidth(
        fontStyle + " " + fontWeight + " " + size + referenceFont,
        text
      );
      if (fontFamily != referenceFont) {
        const width = measureTextWidth(
          fontStyle + " " + fontWeight + " " + size + fontFamily + "," + referenceFont,
          text
        );
        available = available && width != referenceWidth;
      }
    }
    if (available) {
      return true;
    }
    return false;
  }
  function check() {
    let done = true;
    const fonts = checkedFonts.getKeys();
    for (let i = 0, ii = fonts.length; i < ii; ++i) {
      const font = fonts[i];
      if (checkedFonts.get(font) < retries) {
        if (isAvailable.apply(this, font.split("\n"))) {
          clear(textHeights);
          measureContext = null;
          measureFont = void 0;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = void 0;
    }
  }
  return function(fontSpec) {
    const font = getFontParameters(fontSpec);
    if (!font) {
      return;
    }
    const families = font.families;
    for (let i = 0, ii = families.length; i < ii; ++i) {
      const family = families[i];
      const key = font.style + "\n" + font.weight + "\n" + family;
      if (checkedFonts.get(key) === void 0) {
        checkedFonts.set(key, retries, true);
        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);
          if (interval === void 0) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
}();
var measureTextHeight = function() {
  let measureElement;
  return function(fontSpec) {
    let height = textHeights[fontSpec];
    if (height == void 0) {
      if (WORKER_OFFSCREEN_CANVAS) {
        const font = getFontParameters(fontSpec);
        const metrics = measureText(fontSpec, "\u017Dg");
        const lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
        height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
      } else {
        if (!measureElement) {
          measureElement = document.createElement("div");
          measureElement.innerHTML = "M";
          measureElement.style.minHeight = "0";
          measureElement.style.maxHeight = "none";
          measureElement.style.height = "auto";
          measureElement.style.padding = "0";
          measureElement.style.border = "none";
          measureElement.style.position = "absolute";
          measureElement.style.display = "block";
          measureElement.style.left = "-99999px";
        }
        measureElement.style.font = fontSpec;
        document.body.appendChild(measureElement);
        height = measureElement.offsetHeight;
        document.body.removeChild(measureElement);
      }
      textHeights[fontSpec] = height;
    }
    return height;
  };
}();
function measureText(font, text) {
  if (!measureContext) {
    measureContext = createCanvasContext2D(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text);
}
function measureTextWidth(font, text) {
  return measureText(font, text).width;
}

// node_modules/ol/style/Style.js
var Style = class {
  constructor(options) {
    options = options || {};
    this.geometry_ = null;
    this.geometryFunction_ = defaultGeometryFunction;
    if (options.geometry !== void 0) {
      this.setGeometry(options.geometry);
    }
    this.fill_ = options.fill !== void 0 ? options.fill : null;
    this.image_ = options.image !== void 0 ? options.image : null;
    this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
    this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.text_ = options.text !== void 0 ? options.text : null;
    this.zIndex_ = options.zIndex;
  }
  clone() {
    let geometry = this.getGeometry();
    if (geometry && typeof geometry === "object") {
      geometry = geometry.clone();
    }
    return new Style({
      geometry,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  getRenderer() {
    return this.renderer_;
  }
  setRenderer(renderer) {
    this.renderer_ = renderer;
  }
  setHitDetectionRenderer(renderer) {
    this.hitDetectionRenderer_ = renderer;
  }
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  getGeometry() {
    return this.geometry_;
  }
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  getFill() {
    return this.fill_;
  }
  setFill(fill) {
    this.fill_ = fill;
  }
  getImage() {
    return this.image_;
  }
  setImage(image) {
    this.image_ = image;
  }
  getStroke() {
    return this.stroke_;
  }
  setStroke(stroke) {
    this.stroke_ = stroke;
  }
  getText() {
    return this.text_;
  }
  setText(text) {
    this.text_ = text;
  }
  getZIndex() {
    return this.zIndex_;
  }
  setGeometry(geometry) {
    if (typeof geometry === "function") {
      this.geometryFunction_ = geometry;
    } else if (typeof geometry === "string") {
      this.geometryFunction_ = function(feature) {
        return feature.get(geometry);
      };
    } else if (!geometry) {
      this.geometryFunction_ = defaultGeometryFunction;
    } else if (geometry !== void 0) {
      this.geometryFunction_ = function() {
        return geometry;
      };
    }
    this.geometry_ = geometry;
  }
  setZIndex(zIndex) {
    this.zIndex_ = zIndex;
  }
};
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
var Style_default = Style;

// node_modules/ol/style/Text.js
var DEFAULT_FILL_COLOR = "#333";
var Text = class {
  constructor(options) {
    options = options || {};
    this.font_ = options.font;
    this.rotation_ = options.rotation;
    this.rotateWithView_ = options.rotateWithView;
    this.scale_ = options.scale;
    this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
    this.text_ = options.text;
    this.textAlign_ = options.textAlign;
    this.justify_ = options.justify;
    this.repeat_ = options.repeat;
    this.textBaseline_ = options.textBaseline;
    this.fill_ = options.fill !== void 0 ? options.fill : new Fill_default({ color: DEFAULT_FILL_COLOR });
    this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
    this.placement_ = options.placement !== void 0 ? options.placement : "point";
    this.overflow_ = !!options.overflow;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
    this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
    this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
    this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
    this.padding_ = options.padding === void 0 ? null : options.padding;
  }
  clone() {
    const scale2 = this.getScale();
    return new Text({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0
    });
  }
  getOverflow() {
    return this.overflow_;
  }
  getFont() {
    return this.font_;
  }
  getMaxAngle() {
    return this.maxAngle_;
  }
  getPlacement() {
    return this.placement_;
  }
  getRepeat() {
    return this.repeat_;
  }
  getOffsetX() {
    return this.offsetX_;
  }
  getOffsetY() {
    return this.offsetY_;
  }
  getFill() {
    return this.fill_;
  }
  getRotateWithView() {
    return this.rotateWithView_;
  }
  getRotation() {
    return this.rotation_;
  }
  getScale() {
    return this.scale_;
  }
  getScaleArray() {
    return this.scaleArray_;
  }
  getStroke() {
    return this.stroke_;
  }
  getText() {
    return this.text_;
  }
  getTextAlign() {
    return this.textAlign_;
  }
  getJustify() {
    return this.justify_;
  }
  getTextBaseline() {
    return this.textBaseline_;
  }
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  getPadding() {
    return this.padding_;
  }
  setOverflow(overflow) {
    this.overflow_ = overflow;
  }
  setFont(font) {
    this.font_ = font;
  }
  setMaxAngle(maxAngle) {
    this.maxAngle_ = maxAngle;
  }
  setOffsetX(offsetX) {
    this.offsetX_ = offsetX;
  }
  setOffsetY(offsetY) {
    this.offsetY_ = offsetY;
  }
  setPlacement(placement) {
    this.placement_ = placement;
  }
  setRepeat(repeat) {
    this.repeat_ = repeat;
  }
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }
  setFill(fill) {
    this.fill_ = fill;
  }
  setRotation(rotation) {
    this.rotation_ = rotation;
  }
  setScale(scale2) {
    this.scale_ = scale2;
    this.scaleArray_ = toSize(scale2 !== void 0 ? scale2 : 1);
  }
  setStroke(stroke) {
    this.stroke_ = stroke;
  }
  setText(text) {
    this.text_ = text;
  }
  setTextAlign(textAlign) {
    this.textAlign_ = textAlign;
  }
  setJustify(justify) {
    this.justify_ = justify;
  }
  setTextBaseline(textBaseline) {
    this.textBaseline_ = textBaseline;
  }
  setBackgroundFill(fill) {
    this.backgroundFill_ = fill;
  }
  setBackgroundStroke(stroke) {
    this.backgroundStroke_ = stroke;
  }
  setPadding(padding) {
    this.padding_ = padding;
  }
};
var Text_default = Text;

// node_modules/ol/format/KML.js
var GX_NAMESPACE_URIS = ["http://www.google.com/kml/ext/2.2"];
var NAMESPACE_URIS2 = [
  null,
  "http://earth.google.com/kml/2.0",
  "http://earth.google.com/kml/2.1",
  "http://earth.google.com/kml/2.2",
  "http://www.opengis.net/kml/2.2"
];
var SCHEMA_LOCATION2 = "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd";
var ICON_ANCHOR_UNITS_MAP = {
  "fraction": "fraction",
  "pixels": "pixels",
  "insetPixels": "pixels"
};
var PLACEMARK_PARSERS = makeStructureNS(
  NAMESPACE_URIS2,
  {
    "ExtendedData": extendedDataParser,
    "Region": regionParser,
    "MultiGeometry": makeObjectPropertySetter(readMultiGeometry, "geometry"),
    "LineString": makeObjectPropertySetter(readLineString, "geometry"),
    "LinearRing": makeObjectPropertySetter(readLinearRing, "geometry"),
    "Point": makeObjectPropertySetter(readPoint, "geometry"),
    "Polygon": makeObjectPropertySetter(readPolygon, "geometry"),
    "Style": makeObjectPropertySetter(readStyle),
    "StyleMap": placemarkStyleMapParser,
    "address": makeObjectPropertySetter(readString),
    "description": makeObjectPropertySetter(readString),
    "name": makeObjectPropertySetter(readString),
    "open": makeObjectPropertySetter(readBoolean),
    "phoneNumber": makeObjectPropertySetter(readString),
    "styleUrl": makeObjectPropertySetter(readStyleURL),
    "visibility": makeObjectPropertySetter(readBoolean)
  },
  makeStructureNS(GX_NAMESPACE_URIS, {
    "MultiTrack": makeObjectPropertySetter(readGxMultiTrack, "geometry"),
    "Track": makeObjectPropertySetter(readGxTrack, "geometry")
  })
);
var NETWORK_LINK_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "ExtendedData": extendedDataParser,
  "Region": regionParser,
  "Link": linkParser,
  "address": makeObjectPropertySetter(readString),
  "description": makeObjectPropertySetter(readString),
  "name": makeObjectPropertySetter(readString),
  "open": makeObjectPropertySetter(readBoolean),
  "phoneNumber": makeObjectPropertySetter(readString),
  "visibility": makeObjectPropertySetter(readBoolean)
});
var LINK_PARSERS2 = makeStructureNS(NAMESPACE_URIS2, {
  "href": makeObjectPropertySetter(readURI)
});
var REGION_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "LatLonAltBox": latLonAltBoxParser,
  "Lod": lodParser
});
var KML_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, ["Document", "Placemark"]);
var KML_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "Document": makeChildAppender(writeDocument),
  "Placemark": makeChildAppender(writePlacemark)
});
var DEFAULT_COLOR;
var DEFAULT_FILL_STYLE = null;
var DEFAULT_IMAGE_STYLE_ANCHOR;
var DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
var DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
var DEFAULT_IMAGE_STYLE_SIZE;
var DEFAULT_IMAGE_STYLE_SRC;
var DEFAULT_IMAGE_STYLE = null;
var DEFAULT_NO_IMAGE_STYLE;
var DEFAULT_STROKE_STYLE = null;
var DEFAULT_TEXT_STROKE_STYLE;
var DEFAULT_TEXT_STYLE = null;
var DEFAULT_STYLE = null;
var DEFAULT_STYLE_ARRAY = null;
function scaleForSize(size) {
  return 32 / Math.min(size[0], size[1]);
}
function createStyleDefaults() {
  DEFAULT_COLOR = [255, 255, 255, 1];
  DEFAULT_FILL_STYLE = new Fill_default({
    color: DEFAULT_COLOR
  });
  DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];
  DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = "pixels";
  DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = "pixels";
  DEFAULT_IMAGE_STYLE_SIZE = [64, 64];
  DEFAULT_IMAGE_STYLE_SRC = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png";
  DEFAULT_IMAGE_STYLE = new Icon_default({
    anchor: DEFAULT_IMAGE_STYLE_ANCHOR,
    anchorOrigin: "bottom-left",
    anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,
    anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,
    crossOrigin: "anonymous",
    rotation: 0,
    scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),
    size: DEFAULT_IMAGE_STYLE_SIZE,
    src: DEFAULT_IMAGE_STYLE_SRC
  });
  DEFAULT_NO_IMAGE_STYLE = "NO_IMAGE";
  DEFAULT_STROKE_STYLE = new Stroke_default({
    color: DEFAULT_COLOR,
    width: 1
  });
  DEFAULT_TEXT_STROKE_STYLE = new Stroke_default({
    color: [51, 51, 51, 1],
    width: 2
  });
  DEFAULT_TEXT_STYLE = new Text_default({
    font: "bold 16px Helvetica",
    fill: DEFAULT_FILL_STYLE,
    stroke: DEFAULT_TEXT_STROKE_STYLE,
    scale: 0.8
  });
  DEFAULT_STYLE = new Style_default({
    fill: DEFAULT_FILL_STYLE,
    image: DEFAULT_IMAGE_STYLE,
    text: DEFAULT_TEXT_STYLE,
    stroke: DEFAULT_STROKE_STYLE,
    zIndex: 0
  });
  DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];
}
var TEXTAREA;
function defaultIconUrlFunction(href) {
  return href;
}
var KML = class extends XMLFeature_default {
  constructor(options) {
    super();
    options = options ? options : {};
    if (!DEFAULT_STYLE_ARRAY) {
      createStyleDefaults();
    }
    this.dataProjection = get("EPSG:4326");
    this.defaultStyle_ = options.defaultStyle ? options.defaultStyle : DEFAULT_STYLE_ARRAY;
    this.extractStyles_ = options.extractStyles !== void 0 ? options.extractStyles : true;
    this.writeStyles_ = options.writeStyles !== void 0 ? options.writeStyles : true;
    this.sharedStyles_ = {};
    this.showPointNames_ = options.showPointNames !== void 0 ? options.showPointNames : true;
    this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
    this.iconUrlFunction_ = options.iconUrlFunction ? options.iconUrlFunction : defaultIconUrlFunction;
    this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"];
  }
  readDocumentOrFolder_(node, objectStack) {
    const parsersNS = makeStructureNS(NAMESPACE_URIS2, {
      "Document": makeArrayExtender(this.readDocumentOrFolder_, this),
      "Folder": makeArrayExtender(this.readDocumentOrFolder_, this),
      "Placemark": makeArrayPusher(this.readPlacemark_, this),
      "Style": this.readSharedStyle_.bind(this),
      "StyleMap": this.readSharedStyleMap_.bind(this)
    });
    const features = pushParseAndPop([], parsersNS, node, objectStack, this);
    if (features) {
      return features;
    }
    return void 0;
  }
  readPlacemark_(node, objectStack) {
    const object = pushParseAndPop(
      { "geometry": null },
      PLACEMARK_PARSERS,
      node,
      objectStack,
      this
    );
    if (!object) {
      return void 0;
    }
    const feature = new Feature_default();
    const id = node.getAttribute("id");
    if (id !== null) {
      feature.setId(id);
    }
    const options = objectStack[0];
    const geometry = object["geometry"];
    if (geometry) {
      transformGeometryWithOptions(geometry, false, options);
    }
    feature.setGeometry(geometry);
    delete object["geometry"];
    if (this.extractStyles_) {
      const style = object["Style"];
      const styleUrl = object["styleUrl"];
      const styleFunction = createFeatureStyleFunction(
        style,
        styleUrl,
        this.defaultStyle_,
        this.sharedStyles_,
        this.showPointNames_
      );
      feature.setStyle(styleFunction);
    }
    delete object["Style"];
    feature.setProperties(object, true);
    return feature;
  }
  readSharedStyle_(node, objectStack) {
    const id = node.getAttribute("id");
    if (id !== null) {
      const style = readStyle.call(this, node, objectStack);
      if (style) {
        let styleUri;
        let baseURI = node.baseURI;
        if (!baseURI || baseURI == "about:blank") {
          baseURI = window.location.href;
        }
        if (baseURI) {
          const url = new URL("#" + id, baseURI);
          styleUri = url.href;
        } else {
          styleUri = "#" + id;
        }
        this.sharedStyles_[styleUri] = style;
      }
    }
  }
  readSharedStyleMap_(node, objectStack) {
    const id = node.getAttribute("id");
    if (id === null) {
      return;
    }
    const styleMapValue = readStyleMapValue.call(this, node, objectStack);
    if (!styleMapValue) {
      return;
    }
    let styleUri;
    let baseURI = node.baseURI;
    if (!baseURI || baseURI == "about:blank") {
      baseURI = window.location.href;
    }
    if (baseURI) {
      const url = new URL("#" + id, baseURI);
      styleUri = url.href;
    } else {
      styleUri = "#" + id;
    }
    this.sharedStyles_[styleUri] = styleMapValue;
  }
  readFeatureFromNode(node, options) {
    if (!NAMESPACE_URIS2.includes(node.namespaceURI)) {
      return null;
    }
    const feature = this.readPlacemark_(node, [
      this.getReadOptions(node, options)
    ]);
    if (feature) {
      return feature;
    }
    return null;
  }
  readFeaturesFromNode(node, options) {
    if (!NAMESPACE_URIS2.includes(node.namespaceURI)) {
      return [];
    }
    let features;
    const localName = node.localName;
    if (localName == "Document" || localName == "Folder") {
      features = this.readDocumentOrFolder_(node, [
        this.getReadOptions(node, options)
      ]);
      if (features) {
        return features;
      }
      return [];
    } else if (localName == "Placemark") {
      const feature = this.readPlacemark_(node, [
        this.getReadOptions(node, options)
      ]);
      if (feature) {
        return [feature];
      }
      return [];
    } else if (localName == "kml") {
      features = [];
      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
        const fs = this.readFeaturesFromNode(n, options);
        if (fs) {
          extend2(features, fs);
        }
      }
      return features;
    }
    return [];
  }
  readName(source) {
    if (!source) {
      return void 0;
    } else if (typeof source === "string") {
      const doc = parse(source);
      return this.readNameFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readNameFromDocument(source);
    }
    return this.readNameFromNode(source);
  }
  readNameFromDocument(doc) {
    for (let n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        const name = this.readNameFromNode(n);
        if (name) {
          return name;
        }
      }
    }
    return void 0;
  }
  readNameFromNode(node) {
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      if (NAMESPACE_URIS2.includes(n.namespaceURI) && n.localName == "name") {
        return readString(n);
      }
    }
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      const localName = n.localName;
      if (NAMESPACE_URIS2.includes(n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "Placemark" || localName == "kml")) {
        const name = this.readNameFromNode(n);
        if (name) {
          return name;
        }
      }
    }
    return void 0;
  }
  readNetworkLinks(source) {
    const networkLinks = [];
    if (typeof source === "string") {
      const doc = parse(source);
      extend2(networkLinks, this.readNetworkLinksFromDocument(doc));
    } else if (isDocument(source)) {
      extend2(
        networkLinks,
        this.readNetworkLinksFromDocument(source)
      );
    } else {
      extend2(
        networkLinks,
        this.readNetworkLinksFromNode(source)
      );
    }
    return networkLinks;
  }
  readNetworkLinksFromDocument(doc) {
    const networkLinks = [];
    for (let n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        extend2(
          networkLinks,
          this.readNetworkLinksFromNode(n)
        );
      }
    }
    return networkLinks;
  }
  readNetworkLinksFromNode(node) {
    const networkLinks = [];
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      if (NAMESPACE_URIS2.includes(n.namespaceURI) && n.localName == "NetworkLink") {
        const obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n, []);
        networkLinks.push(obj);
      }
    }
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      const localName = n.localName;
      if (NAMESPACE_URIS2.includes(n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "kml")) {
        extend2(networkLinks, this.readNetworkLinksFromNode(n));
      }
    }
    return networkLinks;
  }
  readRegion(source) {
    const regions = [];
    if (typeof source === "string") {
      const doc = parse(source);
      extend2(regions, this.readRegionFromDocument(doc));
    } else if (isDocument(source)) {
      extend2(
        regions,
        this.readRegionFromDocument(source)
      );
    } else {
      extend2(regions, this.readRegionFromNode(source));
    }
    return regions;
  }
  readRegionFromDocument(doc) {
    const regions = [];
    for (let n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        extend2(regions, this.readRegionFromNode(n));
      }
    }
    return regions;
  }
  readRegionFromNode(node) {
    const regions = [];
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      if (NAMESPACE_URIS2.includes(n.namespaceURI) && n.localName == "Region") {
        const obj = pushParseAndPop({}, REGION_PARSERS, n, []);
        regions.push(obj);
      }
    }
    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
      const localName = n.localName;
      if (NAMESPACE_URIS2.includes(n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "kml")) {
        extend2(regions, this.readRegionFromNode(n));
      }
    }
    return regions;
  }
  writeFeaturesNode(features, options) {
    options = this.adaptOptions(options);
    const kml = createElementNS(NAMESPACE_URIS2[4], "kml");
    const xmlnsUri = "http://www.w3.org/2000/xmlns/";
    kml.setAttributeNS(xmlnsUri, "xmlns:gx", GX_NAMESPACE_URIS[0]);
    kml.setAttributeNS(xmlnsUri, "xmlns:xsi", XML_SCHEMA_INSTANCE_URI);
    kml.setAttributeNS(
      XML_SCHEMA_INSTANCE_URI,
      "xsi:schemaLocation",
      SCHEMA_LOCATION2
    );
    const context = {
      node: kml
    };
    const properties = {};
    if (features.length > 1) {
      properties["Document"] = features;
    } else if (features.length == 1) {
      properties["Placemark"] = features[0];
    }
    const orderedKeys = KML_SEQUENCE[kml.namespaceURI];
    const values = makeSequence(properties, orderedKeys);
    pushSerializeAndPop(
      context,
      KML_SERIALIZERS,
      OBJECT_PROPERTY_NODE_FACTORY,
      values,
      [options],
      orderedKeys,
      this
    );
    return kml;
  }
};
function createNameStyleFunction(foundStyle, name) {
  const textOffset = [0, 0];
  let textAlign = "start";
  const imageStyle = foundStyle.getImage();
  if (imageStyle) {
    const imageSize = imageStyle.getSize();
    if (imageSize && imageSize.length == 2) {
      const imageScale = imageStyle.getScaleArray();
      const anchor = imageStyle.getAnchor();
      textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);
      textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);
      textAlign = "left";
    }
  }
  let textStyle = foundStyle.getText();
  if (textStyle) {
    textStyle = textStyle.clone();
    textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());
    textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());
    textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());
    textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);
  } else {
    textStyle = DEFAULT_TEXT_STYLE.clone();
  }
  textStyle.setText(name);
  textStyle.setOffsetX(textOffset[0]);
  textStyle.setOffsetY(textOffset[1]);
  textStyle.setTextAlign(textAlign);
  const nameStyle = new Style_default({
    image: imageStyle,
    text: textStyle
  });
  return nameStyle;
}
function createFeatureStyleFunction(style, styleUrl, defaultStyle, sharedStyles, showPointNames) {
  return function(feature, resolution) {
    let drawName = showPointNames;
    let name = "";
    let multiGeometryPoints = [];
    if (drawName) {
      const geometry = feature.getGeometry();
      if (geometry) {
        if (geometry instanceof GeometryCollection_default) {
          multiGeometryPoints = geometry.getGeometriesArrayRecursive().filter(function(geometry2) {
            const type = geometry2.getType();
            return type === "Point" || type === "MultiPoint";
          });
          drawName = multiGeometryPoints.length > 0;
        } else {
          const type = geometry.getType();
          drawName = type === "Point" || type === "MultiPoint";
        }
      }
    }
    if (drawName) {
      name = feature.get("name");
      drawName = drawName && !!name;
      if (drawName && /&[^&]+;/.test(name)) {
        if (!TEXTAREA) {
          TEXTAREA = document.createElement("textarea");
        }
        TEXTAREA.innerHTML = name;
        name = TEXTAREA.value;
      }
    }
    let featureStyle = defaultStyle;
    if (style) {
      featureStyle = style;
    } else if (styleUrl) {
      featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);
    }
    if (drawName) {
      const nameStyle = createNameStyleFunction(featureStyle[0], name);
      if (multiGeometryPoints.length > 0) {
        nameStyle.setGeometry(new GeometryCollection_default(multiGeometryPoints));
        const baseStyle = new Style_default({
          geometry: featureStyle[0].getGeometry(),
          image: null,
          fill: featureStyle[0].getFill(),
          stroke: featureStyle[0].getStroke(),
          text: null
        });
        return [nameStyle, baseStyle].concat(featureStyle.slice(1));
      }
      return nameStyle;
    }
    return featureStyle;
  };
}
function findStyle(styleValue, defaultStyle, sharedStyles) {
  if (Array.isArray(styleValue)) {
    return styleValue;
  } else if (typeof styleValue === "string") {
    return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);
  }
  return defaultStyle;
}
function readColor(node) {
  const s = getAllTextContent(node, false);
  const m = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(s);
  if (m) {
    const hexColor = m[1];
    return [
      parseInt(hexColor.substr(6, 2), 16),
      parseInt(hexColor.substr(4, 2), 16),
      parseInt(hexColor.substr(2, 2), 16),
      parseInt(hexColor.substr(0, 2), 16) / 255
    ];
  }
  return void 0;
}
function readFlatCoordinates(node) {
  let s = getAllTextContent(node, false);
  const flatCoordinates = [];
  s = s.replace(/\s*,\s*/g, ",");
  const re = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
  let m;
  while (m = re.exec(s)) {
    const x = parseFloat(m[1]);
    const y = parseFloat(m[2]);
    const z = m[3] ? parseFloat(m[3]) : 0;
    flatCoordinates.push(x, y, z);
    s = s.substr(m[0].length);
  }
  if (s !== "") {
    return void 0;
  }
  return flatCoordinates;
}
function readURI(node) {
  const s = getAllTextContent(node, false).trim();
  let baseURI = node.baseURI;
  if (!baseURI || baseURI == "about:blank") {
    baseURI = window.location.href;
  }
  if (baseURI) {
    const url = new URL(s, baseURI);
    return url.href;
  }
  return s;
}
function readStyleURL(node) {
  const s = getAllTextContent(node, false).trim().replace(/^(?!.*#)/, "#");
  let baseURI = node.baseURI;
  if (!baseURI || baseURI == "about:blank") {
    baseURI = window.location.href;
  }
  if (baseURI) {
    const url = new URL(s, baseURI);
    return url.href;
  }
  return s;
}
function readVec2(node) {
  const xunits = node.getAttribute("xunits");
  const yunits = node.getAttribute("yunits");
  let origin;
  if (xunits !== "insetPixels") {
    if (yunits !== "insetPixels") {
      origin = "bottom-left";
    } else {
      origin = "top-left";
    }
  } else {
    if (yunits !== "insetPixels") {
      origin = "bottom-right";
    } else {
      origin = "top-right";
    }
  }
  return {
    x: parseFloat(node.getAttribute("x")),
    xunits: ICON_ANCHOR_UNITS_MAP[xunits],
    y: parseFloat(node.getAttribute("y")),
    yunits: ICON_ANCHOR_UNITS_MAP[yunits],
    origin
  };
}
function readScale(node) {
  return readDecimal(node);
}
var STYLE_MAP_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "Pair": pairDataParser
});
function readStyleMapValue(node, objectStack) {
  return pushParseAndPop(void 0, STYLE_MAP_PARSERS, node, objectStack, this);
}
var ICON_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "Icon": makeObjectPropertySetter(readIcon),
  "color": makeObjectPropertySetter(readColor),
  "heading": makeObjectPropertySetter(readDecimal),
  "hotSpot": makeObjectPropertySetter(readVec2),
  "scale": makeObjectPropertySetter(readScale)
});
function iconStyleParser(node, objectStack) {
  const object = pushParseAndPop({}, ICON_STYLE_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  const styleObject = objectStack[objectStack.length - 1];
  const IconObject = "Icon" in object ? object["Icon"] : {};
  const drawIcon = !("Icon" in object) || Object.keys(IconObject).length > 0;
  let src;
  const href = IconObject["href"];
  if (href) {
    src = href;
  } else if (drawIcon) {
    src = DEFAULT_IMAGE_STYLE_SRC;
  }
  let anchor, anchorXUnits, anchorYUnits;
  let anchorOrigin = "bottom-left";
  const hotSpot = object["hotSpot"];
  if (hotSpot) {
    anchor = [hotSpot.x, hotSpot.y];
    anchorXUnits = hotSpot.xunits;
    anchorYUnits = hotSpot.yunits;
    anchorOrigin = hotSpot.origin;
  } else if (/^https?:\/\/maps\.(?:google|gstatic)\.com\//.test(src)) {
    if (src.includes("pushpin")) {
      anchor = DEFAULT_IMAGE_STYLE_ANCHOR;
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    } else if (src.includes("arrow-reverse")) {
      anchor = [54, 42];
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    } else if (src.includes("paddle")) {
      anchor = [32, 1];
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    }
  }
  let offset2;
  const x = IconObject["x"];
  const y = IconObject["y"];
  if (x !== void 0 && y !== void 0) {
    offset2 = [x, y];
  }
  let size;
  const w = IconObject["w"];
  const h = IconObject["h"];
  if (w !== void 0 && h !== void 0) {
    size = [w, h];
  }
  let rotation;
  const heading = object["heading"];
  if (heading !== void 0) {
    rotation = toRadians(heading);
  }
  const scale2 = object["scale"];
  const color = object["color"];
  if (drawIcon) {
    if (src == DEFAULT_IMAGE_STYLE_SRC) {
      size = DEFAULT_IMAGE_STYLE_SIZE;
    }
    const imageStyle = new Icon_default({
      anchor,
      anchorOrigin,
      anchorXUnits,
      anchorYUnits,
      crossOrigin: this.crossOrigin_,
      offset: offset2,
      offsetOrigin: "bottom-left",
      rotation,
      scale: scale2,
      size,
      src: this.iconUrlFunction_(src),
      color
    });
    const imageScale = imageStyle.getScaleArray()[0];
    const imageSize = imageStyle.getSize();
    if (imageSize === null) {
      const imageState = imageStyle.getImageState();
      if (imageState === ImageState_default.IDLE || imageState === ImageState_default.LOADING) {
        const listener = function() {
          const imageState2 = imageStyle.getImageState();
          if (!(imageState2 === ImageState_default.IDLE || imageState2 === ImageState_default.LOADING)) {
            const imageSize2 = imageStyle.getSize();
            if (imageSize2 && imageSize2.length == 2) {
              const resizeScale = scaleForSize(imageSize2);
              imageStyle.setScale(imageScale * resizeScale);
            }
            imageStyle.unlistenImageChange(listener);
          }
        };
        imageStyle.listenImageChange(listener);
        if (imageState === ImageState_default.IDLE) {
          imageStyle.load();
        }
      }
    } else if (imageSize.length == 2) {
      const resizeScale = scaleForSize(imageSize);
      imageStyle.setScale(imageScale * resizeScale);
    }
    styleObject["imageStyle"] = imageStyle;
  } else {
    styleObject["imageStyle"] = DEFAULT_NO_IMAGE_STYLE;
  }
}
var LABEL_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "color": makeObjectPropertySetter(readColor),
  "scale": makeObjectPropertySetter(readScale)
});
function labelStyleParser(node, objectStack) {
  const object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  const styleObject = objectStack[objectStack.length - 1];
  const textStyle = new Text_default({
    fill: new Fill_default({
      color: "color" in object ? object["color"] : DEFAULT_COLOR
    }),
    scale: object["scale"]
  });
  styleObject["textStyle"] = textStyle;
}
var LINE_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "color": makeObjectPropertySetter(readColor),
  "width": makeObjectPropertySetter(readDecimal)
});
function lineStyleParser(node, objectStack) {
  const object = pushParseAndPop({}, LINE_STYLE_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  const styleObject = objectStack[objectStack.length - 1];
  const strokeStyle = new Stroke_default({
    color: "color" in object ? object["color"] : DEFAULT_COLOR,
    width: "width" in object ? object["width"] : 1
  });
  styleObject["strokeStyle"] = strokeStyle;
}
var POLY_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "color": makeObjectPropertySetter(readColor),
  "fill": makeObjectPropertySetter(readBoolean),
  "outline": makeObjectPropertySetter(readBoolean)
});
function polyStyleParser(node, objectStack) {
  const object = pushParseAndPop({}, POLY_STYLE_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  const styleObject = objectStack[objectStack.length - 1];
  const fillStyle = new Fill_default({
    color: "color" in object ? object["color"] : DEFAULT_COLOR
  });
  styleObject["fillStyle"] = fillStyle;
  const fill = object["fill"];
  if (fill !== void 0) {
    styleObject["fill"] = fill;
  }
  const outline = object["outline"];
  if (outline !== void 0) {
    styleObject["outline"] = outline;
  }
}
var FLAT_LINEAR_RING_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "coordinates": makeReplacer(readFlatCoordinates)
});
function readFlatLinearRing(node, objectStack) {
  return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node, objectStack);
}
function gxCoordParser(node, objectStack) {
  const gxTrackObject = objectStack[objectStack.length - 1];
  const coordinates2 = gxTrackObject.coordinates;
  const s = getAllTextContent(node, false);
  const re = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i;
  const m = re.exec(s);
  if (m) {
    const x = parseFloat(m[1]);
    const y = parseFloat(m[2]);
    const z = parseFloat(m[3]);
    coordinates2.push([x, y, z]);
  } else {
    coordinates2.push([]);
  }
}
var GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {
  "Track": makeArrayPusher(readGxTrack)
});
function readGxMultiTrack(node, objectStack) {
  const lineStrings = pushParseAndPop(
    [],
    GX_MULTITRACK_GEOMETRY_PARSERS,
    node,
    objectStack
  );
  if (!lineStrings) {
    return void 0;
  }
  return new MultiLineString_default(lineStrings);
}
var GX_TRACK_PARSERS = makeStructureNS(
  NAMESPACE_URIS2,
  {
    "when": whenParser
  },
  makeStructureNS(GX_NAMESPACE_URIS, {
    "coord": gxCoordParser
  })
);
function readGxTrack(node, objectStack) {
  const gxTrackObject = pushParseAndPop(
    {
      coordinates: [],
      whens: []
    },
    GX_TRACK_PARSERS,
    node,
    objectStack
  );
  if (!gxTrackObject) {
    return void 0;
  }
  const flatCoordinates = [];
  const coordinates2 = gxTrackObject.coordinates;
  const whens = gxTrackObject.whens;
  for (let i = 0, ii = Math.min(coordinates2.length, whens.length); i < ii; ++i) {
    if (coordinates2[i].length == 3) {
      flatCoordinates.push(
        coordinates2[i][0],
        coordinates2[i][1],
        coordinates2[i][2],
        whens[i]
      );
    }
  }
  return new LineString_default(flatCoordinates, "XYZM");
}
var ICON_PARSERS = makeStructureNS(
  NAMESPACE_URIS2,
  {
    "href": makeObjectPropertySetter(readURI)
  },
  makeStructureNS(GX_NAMESPACE_URIS, {
    "x": makeObjectPropertySetter(readDecimal),
    "y": makeObjectPropertySetter(readDecimal),
    "w": makeObjectPropertySetter(readDecimal),
    "h": makeObjectPropertySetter(readDecimal)
  })
);
function readIcon(node, objectStack) {
  const iconObject = pushParseAndPop({}, ICON_PARSERS, node, objectStack);
  if (iconObject) {
    return iconObject;
  }
  return null;
}
var GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "coordinates": makeReplacer(readFlatCoordinates)
});
function readFlatCoordinatesFromNode(node, objectStack) {
  return pushParseAndPop(
    null,
    GEOMETRY_FLAT_COORDINATES_PARSERS,
    node,
    objectStack
  );
}
var EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "extrude": makeObjectPropertySetter(readBoolean),
  "tessellate": makeObjectPropertySetter(readBoolean),
  "altitudeMode": makeObjectPropertySetter(readString)
});
function readLineString(node, objectStack) {
  const properties = pushParseAndPop(
    {},
    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,
    node,
    objectStack
  );
  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
  if (flatCoordinates) {
    const lineString = new LineString_default(flatCoordinates, "XYZ");
    lineString.setProperties(properties, true);
    return lineString;
  }
  return void 0;
}
function readLinearRing(node, objectStack) {
  const properties = pushParseAndPop(
    {},
    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,
    node,
    objectStack
  );
  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
  if (flatCoordinates) {
    const polygon = new Polygon_default(flatCoordinates, "XYZ", [
      flatCoordinates.length
    ]);
    polygon.setProperties(properties, true);
    return polygon;
  }
  return void 0;
}
var MULTI_GEOMETRY_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "LineString": makeArrayPusher(readLineString),
  "LinearRing": makeArrayPusher(readLinearRing),
  "MultiGeometry": makeArrayPusher(readMultiGeometry),
  "Point": makeArrayPusher(readPoint),
  "Polygon": makeArrayPusher(readPolygon)
});
function readMultiGeometry(node, objectStack) {
  const geometries = pushParseAndPop(
    [],
    MULTI_GEOMETRY_PARSERS,
    node,
    objectStack
  );
  if (!geometries) {
    return null;
  }
  if (geometries.length === 0) {
    return new GeometryCollection_default(geometries);
  }
  let multiGeometry;
  let homogeneous = true;
  const type = geometries[0].getType();
  let geometry;
  for (let i = 1, ii = geometries.length; i < ii; ++i) {
    geometry = geometries[i];
    if (geometry.getType() != type) {
      homogeneous = false;
      break;
    }
  }
  if (homogeneous) {
    let layout;
    let flatCoordinates;
    if (type == "Point") {
      const point = geometries[0];
      layout = point.getLayout();
      flatCoordinates = point.getFlatCoordinates();
      for (let i = 1, ii = geometries.length; i < ii; ++i) {
        geometry = geometries[i];
        extend2(flatCoordinates, geometry.getFlatCoordinates());
      }
      multiGeometry = new MultiPoint_default(flatCoordinates, layout);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == "LineString") {
      multiGeometry = new MultiLineString_default(geometries);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == "Polygon") {
      multiGeometry = new MultiPolygon_default(geometries);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == "GeometryCollection") {
      multiGeometry = new GeometryCollection_default(geometries);
    } else {
      assert(false, 37);
    }
  } else {
    multiGeometry = new GeometryCollection_default(geometries);
  }
  return multiGeometry;
}
function readPoint(node, objectStack) {
  const properties = pushParseAndPop(
    {},
    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,
    node,
    objectStack
  );
  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
  if (flatCoordinates) {
    const point = new Point_default(flatCoordinates, "XYZ");
    point.setProperties(properties, true);
    return point;
  }
  return void 0;
}
var FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "innerBoundaryIs": innerBoundaryIsParser,
  "outerBoundaryIs": outerBoundaryIsParser
});
function readPolygon(node, objectStack) {
  const properties = pushParseAndPop(
    {},
    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,
    node,
    objectStack
  );
  const flatLinearRings = pushParseAndPop(
    [null],
    FLAT_LINEAR_RINGS_PARSERS,
    node,
    objectStack
  );
  if (flatLinearRings && flatLinearRings[0]) {
    const flatCoordinates = flatLinearRings[0];
    const ends = [flatCoordinates.length];
    for (let i = 1, ii = flatLinearRings.length; i < ii; ++i) {
      extend2(flatCoordinates, flatLinearRings[i]);
      ends.push(flatCoordinates.length);
    }
    const polygon = new Polygon_default(flatCoordinates, "XYZ", ends);
    polygon.setProperties(properties, true);
    return polygon;
  }
  return void 0;
}
var STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "IconStyle": iconStyleParser,
  "LabelStyle": labelStyleParser,
  "LineStyle": lineStyleParser,
  "PolyStyle": polyStyleParser
});
function readStyle(node, objectStack) {
  const styleObject = pushParseAndPop(
    {},
    STYLE_PARSERS,
    node,
    objectStack,
    this
  );
  if (!styleObject) {
    return null;
  }
  let fillStyle = "fillStyle" in styleObject ? styleObject["fillStyle"] : DEFAULT_FILL_STYLE;
  const fill = styleObject["fill"];
  if (fill !== void 0 && !fill) {
    fillStyle = null;
  }
  let imageStyle;
  if ("imageStyle" in styleObject) {
    if (styleObject["imageStyle"] != DEFAULT_NO_IMAGE_STYLE) {
      imageStyle = styleObject["imageStyle"];
    }
  } else {
    imageStyle = DEFAULT_IMAGE_STYLE;
  }
  const textStyle = "textStyle" in styleObject ? styleObject["textStyle"] : DEFAULT_TEXT_STYLE;
  const strokeStyle = "strokeStyle" in styleObject ? styleObject["strokeStyle"] : DEFAULT_STROKE_STYLE;
  const outline = styleObject["outline"];
  if (outline !== void 0 && !outline) {
    return [
      new Style_default({
        geometry: function(feature) {
          const geometry = feature.getGeometry();
          const type = geometry.getType();
          if (type === "GeometryCollection") {
            const collection = geometry;
            return new GeometryCollection_default(
              collection.getGeometriesArrayRecursive().filter(function(geometry2) {
                const type2 = geometry2.getType();
                return type2 !== "Polygon" && type2 !== "MultiPolygon";
              })
            );
          } else if (type !== "Polygon" && type !== "MultiPolygon") {
            return geometry;
          }
        },
        fill: fillStyle,
        image: imageStyle,
        stroke: strokeStyle,
        text: textStyle,
        zIndex: void 0
      }),
      new Style_default({
        geometry: function(feature) {
          const geometry = feature.getGeometry();
          const type = geometry.getType();
          if (type === "GeometryCollection") {
            const collection = geometry;
            return new GeometryCollection_default(
              collection.getGeometriesArrayRecursive().filter(function(geometry2) {
                const type2 = geometry2.getType();
                return type2 === "Polygon" || type2 === "MultiPolygon";
              })
            );
          } else if (type === "Polygon" || type === "MultiPolygon") {
            return geometry;
          }
        },
        fill: fillStyle,
        stroke: null,
        zIndex: void 0
      })
    ];
  }
  return [
    new Style_default({
      fill: fillStyle,
      image: imageStyle,
      stroke: strokeStyle,
      text: textStyle,
      zIndex: void 0
    })
  ];
}
function setCommonGeometryProperties(multiGeometry, geometries) {
  const ii = geometries.length;
  const extrudes = new Array(geometries.length);
  const tessellates = new Array(geometries.length);
  const altitudeModes = new Array(geometries.length);
  let hasExtrude, hasTessellate, hasAltitudeMode;
  hasExtrude = false;
  hasTessellate = false;
  hasAltitudeMode = false;
  for (let i = 0; i < ii; ++i) {
    const geometry = geometries[i];
    extrudes[i] = geometry.get("extrude");
    tessellates[i] = geometry.get("tessellate");
    altitudeModes[i] = geometry.get("altitudeMode");
    hasExtrude = hasExtrude || extrudes[i] !== void 0;
    hasTessellate = hasTessellate || tessellates[i] !== void 0;
    hasAltitudeMode = hasAltitudeMode || altitudeModes[i];
  }
  if (hasExtrude) {
    multiGeometry.set("extrude", extrudes);
  }
  if (hasTessellate) {
    multiGeometry.set("tessellate", tessellates);
  }
  if (hasAltitudeMode) {
    multiGeometry.set("altitudeMode", altitudeModes);
  }
}
var DATA_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "displayName": makeObjectPropertySetter(readString),
  "value": makeObjectPropertySetter(readString)
});
function dataParser(node, objectStack) {
  const name = node.getAttribute("name");
  parseNode(DATA_PARSERS, node, objectStack);
  const featureObject = objectStack[objectStack.length - 1];
  if (name && featureObject.displayName) {
    featureObject[name] = {
      value: featureObject.value,
      displayName: featureObject.displayName,
      toString: function() {
        return featureObject.value;
      }
    };
  } else if (name !== null) {
    featureObject[name] = featureObject.value;
  } else if (featureObject.displayName !== null) {
    featureObject[featureObject.displayName] = featureObject.value;
  }
  delete featureObject["value"];
}
var EXTENDED_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "Data": dataParser,
  "SchemaData": schemaDataParser
});
function extendedDataParser(node, objectStack) {
  parseNode(EXTENDED_DATA_PARSERS, node, objectStack);
}
function regionParser(node, objectStack) {
  parseNode(REGION_PARSERS, node, objectStack);
}
var PAIR_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "Style": makeObjectPropertySetter(readStyle),
  "key": makeObjectPropertySetter(readString),
  "styleUrl": makeObjectPropertySetter(readStyleURL)
});
function pairDataParser(node, objectStack) {
  const pairObject = pushParseAndPop({}, PAIR_PARSERS, node, objectStack, this);
  if (!pairObject) {
    return;
  }
  const key = pairObject["key"];
  if (key && key == "normal") {
    const styleUrl = pairObject["styleUrl"];
    if (styleUrl) {
      objectStack[objectStack.length - 1] = styleUrl;
    }
    const style = pairObject["Style"];
    if (style) {
      objectStack[objectStack.length - 1] = style;
    }
  }
}
function placemarkStyleMapParser(node, objectStack) {
  const styleMapValue = readStyleMapValue.call(this, node, objectStack);
  if (!styleMapValue) {
    return;
  }
  const placemarkObject = objectStack[objectStack.length - 1];
  if (Array.isArray(styleMapValue)) {
    placemarkObject["Style"] = styleMapValue;
  } else if (typeof styleMapValue === "string") {
    placemarkObject["styleUrl"] = styleMapValue;
  } else {
    assert(false, 38);
  }
}
var SCHEMA_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "SimpleData": simpleDataParser
});
function schemaDataParser(node, objectStack) {
  parseNode(SCHEMA_DATA_PARSERS, node, objectStack);
}
function simpleDataParser(node, objectStack) {
  const name = node.getAttribute("name");
  if (name !== null) {
    const data = readString(node);
    const featureObject = objectStack[objectStack.length - 1];
    featureObject[name] = data;
  }
}
var LAT_LON_ALT_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "altitudeMode": makeObjectPropertySetter(readString),
  "minAltitude": makeObjectPropertySetter(readDecimal),
  "maxAltitude": makeObjectPropertySetter(readDecimal),
  "north": makeObjectPropertySetter(readDecimal),
  "south": makeObjectPropertySetter(readDecimal),
  "east": makeObjectPropertySetter(readDecimal),
  "west": makeObjectPropertySetter(readDecimal)
});
function latLonAltBoxParser(node, objectStack) {
  const object = pushParseAndPop(
    {},
    LAT_LON_ALT_BOX_PARSERS,
    node,
    objectStack
  );
  if (!object) {
    return;
  }
  const regionObject = objectStack[objectStack.length - 1];
  const extent = [
    parseFloat(object["west"]),
    parseFloat(object["south"]),
    parseFloat(object["east"]),
    parseFloat(object["north"])
  ];
  regionObject["extent"] = extent;
  regionObject["altitudeMode"] = object["altitudeMode"];
  regionObject["minAltitude"] = parseFloat(object["minAltitude"]);
  regionObject["maxAltitude"] = parseFloat(object["maxAltitude"]);
}
var LOD_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "minLodPixels": makeObjectPropertySetter(readDecimal),
  "maxLodPixels": makeObjectPropertySetter(readDecimal),
  "minFadeExtent": makeObjectPropertySetter(readDecimal),
  "maxFadeExtent": makeObjectPropertySetter(readDecimal)
});
function lodParser(node, objectStack) {
  const object = pushParseAndPop({}, LOD_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  const lodObject = objectStack[objectStack.length - 1];
  lodObject["minLodPixels"] = parseFloat(object["minLodPixels"]);
  lodObject["maxLodPixels"] = parseFloat(object["maxLodPixels"]);
  lodObject["minFadeExtent"] = parseFloat(object["minFadeExtent"]);
  lodObject["maxFadeExtent"] = parseFloat(object["maxFadeExtent"]);
}
var INNER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "LinearRing": makeArrayPusher(readFlatLinearRing)
});
function innerBoundaryIsParser(node, objectStack) {
  const innerBoundaryFlatLinearRings = pushParseAndPop(
    [],
    INNER_BOUNDARY_IS_PARSERS,
    node,
    objectStack
  );
  if (innerBoundaryFlatLinearRings.length > 0) {
    const flatLinearRings = objectStack[objectStack.length - 1];
    flatLinearRings.push(...innerBoundaryFlatLinearRings);
  }
}
var OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "LinearRing": makeReplacer(readFlatLinearRing)
});
function outerBoundaryIsParser(node, objectStack) {
  const flatLinearRing = pushParseAndPop(
    void 0,
    OUTER_BOUNDARY_IS_PARSERS,
    node,
    objectStack
  );
  if (flatLinearRing) {
    const flatLinearRings = objectStack[objectStack.length - 1];
    flatLinearRings[0] = flatLinearRing;
  }
}
function linkParser(node, objectStack) {
  parseNode(LINK_PARSERS2, node, objectStack);
}
function whenParser(node, objectStack) {
  const gxTrackObject = objectStack[objectStack.length - 1];
  const whens = gxTrackObject.whens;
  const s = getAllTextContent(node, false);
  const when = Date.parse(s);
  whens.push(isNaN(when) ? 0 : when);
}
function writeColorTextNode(node, color) {
  const rgba = asArray(color);
  const opacity = rgba.length == 4 ? rgba[3] : 1;
  const abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];
  for (let i = 0; i < 4; ++i) {
    const hex = Math.floor(abgr[i]).toString(16);
    abgr[i] = hex.length == 1 ? "0" + hex : hex;
  }
  writeStringTextNode(node, abgr.join(""));
}
function writeCoordinatesTextNode(node, coordinates2, objectStack) {
  const context = objectStack[objectStack.length - 1];
  const layout = context["layout"];
  const stride = context["stride"];
  let dimension;
  if (layout == "XY" || layout == "XYM") {
    dimension = 2;
  } else if (layout == "XYZ" || layout == "XYZM") {
    dimension = 3;
  } else {
    assert(false, 34);
  }
  const ii = coordinates2.length;
  let text = "";
  if (ii > 0) {
    text += coordinates2[0];
    for (let d = 1; d < dimension; ++d) {
      text += "," + coordinates2[d];
    }
    for (let i = stride; i < ii; i += stride) {
      text += " " + coordinates2[i];
      for (let d = 1; d < dimension; ++d) {
        text += "," + coordinates2[i + d];
      }
    }
  }
  writeStringTextNode(node, text);
}
var EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "Data": makeChildAppender(writeDataNode),
  "value": makeChildAppender(writeDataNodeValue),
  "displayName": makeChildAppender(writeDataNodeName)
});
function writeDataNode(node, pair, objectStack) {
  node.setAttribute("name", pair.name);
  const context = { node };
  const value = pair.value;
  if (typeof value == "object") {
    if (value !== null && value.displayName) {
      pushSerializeAndPop(
        context,
        EXTENDEDDATA_NODE_SERIALIZERS,
        OBJECT_PROPERTY_NODE_FACTORY,
        [value.displayName],
        objectStack,
        ["displayName"]
      );
    }
    if (value !== null && value.value) {
      pushSerializeAndPop(
        context,
        EXTENDEDDATA_NODE_SERIALIZERS,
        OBJECT_PROPERTY_NODE_FACTORY,
        [value.value],
        objectStack,
        ["value"]
      );
    }
  } else {
    pushSerializeAndPop(
      context,
      EXTENDEDDATA_NODE_SERIALIZERS,
      OBJECT_PROPERTY_NODE_FACTORY,
      [value],
      objectStack,
      ["value"]
    );
  }
}
function writeDataNodeName(node, name) {
  writeCDATASection(node, name);
}
function writeDataNodeValue(node, value) {
  writeStringTextNode(node, value);
}
var DOCUMENT_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "Placemark": makeChildAppender(writePlacemark)
});
var DOCUMENT_NODE_FACTORY = function(value, objectStack, nodeName) {
  const parentNode = objectStack[objectStack.length - 1].node;
  return createElementNS(parentNode.namespaceURI, "Placemark");
};
function writeDocument(node, features, objectStack) {
  const context = { node };
  pushSerializeAndPop(
    context,
    DOCUMENT_SERIALIZERS,
    DOCUMENT_NODE_FACTORY,
    features,
    objectStack,
    void 0,
    this
  );
}
var DATA_NODE_FACTORY = makeSimpleNodeFactory("Data");
function writeExtendedData(node, namesAndValues, objectStack) {
  const context = { node };
  const names = namesAndValues.names;
  const values = namesAndValues.values;
  const length = names.length;
  for (let i = 0; i < length; i++) {
    pushSerializeAndPop(
      context,
      EXTENDEDDATA_NODE_SERIALIZERS,
      DATA_NODE_FACTORY,
      [{ name: names[i], value: values[i] }],
      objectStack
    );
  }
}
var ICON_SEQUENCE = makeStructureNS(
  NAMESPACE_URIS2,
  ["href"],
  makeStructureNS(GX_NAMESPACE_URIS, ["x", "y", "w", "h"])
);
var ICON_SERIALIZERS = makeStructureNS(
  NAMESPACE_URIS2,
  {
    "href": makeChildAppender(writeStringTextNode)
  },
  makeStructureNS(GX_NAMESPACE_URIS, {
    "x": makeChildAppender(writeDecimalTextNode),
    "y": makeChildAppender(writeDecimalTextNode),
    "w": makeChildAppender(writeDecimalTextNode),
    "h": makeChildAppender(writeDecimalTextNode)
  })
);
var GX_NODE_FACTORY = function(value, objectStack, nodeName) {
  return createElementNS(GX_NAMESPACE_URIS[0], "gx:" + nodeName);
};
function writeIcon(node, icon, objectStack) {
  const context = { node };
  const parentNode = objectStack[objectStack.length - 1].node;
  let orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];
  let values = makeSequence(icon, orderedKeys);
  pushSerializeAndPop(
    context,
    ICON_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
  orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];
  values = makeSequence(icon, orderedKeys);
  pushSerializeAndPop(
    context,
    ICON_SERIALIZERS,
    GX_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
}
var ICON_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, [
  "scale",
  "heading",
  "Icon",
  "color",
  "hotSpot"
]);
var ICON_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "Icon": makeChildAppender(writeIcon),
  "color": makeChildAppender(writeColorTextNode),
  "heading": makeChildAppender(writeDecimalTextNode),
  "hotSpot": makeChildAppender(writeVec2),
  "scale": makeChildAppender(writeScaleTextNode)
});
function writeIconStyle(node, style, objectStack) {
  const context = { node };
  const properties = {};
  const src = style.getSrc();
  const size = style.getSize();
  const iconImageSize = style.getImageSize();
  const iconProperties = {
    "href": src
  };
  if (size) {
    iconProperties["w"] = size[0];
    iconProperties["h"] = size[1];
    const anchor = style.getAnchor();
    const origin = style.getOrigin();
    if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {
      iconProperties["x"] = origin[0];
      iconProperties["y"] = iconImageSize[1] - (origin[1] + size[1]);
    }
    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {
      const hotSpot = {
        x: anchor[0],
        xunits: "pixels",
        y: size[1] - anchor[1],
        yunits: "pixels"
      };
      properties["hotSpot"] = hotSpot;
    }
  }
  properties["Icon"] = iconProperties;
  let scale2 = style.getScaleArray()[0];
  let imageSize = size;
  if (imageSize === null) {
    imageSize = DEFAULT_IMAGE_STYLE_SIZE;
  }
  if (imageSize.length == 2) {
    const resizeScale = scaleForSize(imageSize);
    scale2 = scale2 / resizeScale;
  }
  if (scale2 !== 1) {
    properties["scale"] = scale2;
  }
  const rotation = style.getRotation();
  if (rotation !== 0) {
    properties["heading"] = rotation;
  }
  const color = style.getColor();
  if (color) {
    properties["color"] = color;
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];
  const values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(
    context,
    ICON_STYLE_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
}
var LABEL_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, [
  "color",
  "scale"
]);
var LABEL_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "color": makeChildAppender(writeColorTextNode),
  "scale": makeChildAppender(writeScaleTextNode)
});
function writeLabelStyle(node, style, objectStack) {
  const context = { node };
  const properties = {};
  const fill = style.getFill();
  if (fill) {
    properties["color"] = fill.getColor();
  }
  const scale2 = style.getScale();
  if (scale2 && scale2 !== 1) {
    properties["scale"] = scale2;
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];
  const values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(
    context,
    LABEL_STYLE_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
}
var LINE_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, ["color", "width"]);
var LINE_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "color": makeChildAppender(writeColorTextNode),
  "width": makeChildAppender(writeDecimalTextNode)
});
function writeLineStyle(node, style, objectStack) {
  const context = { node };
  const properties = {
    "color": style.getColor(),
    "width": Number(style.getWidth()) || 1
  };
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];
  const values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(
    context,
    LINE_STYLE_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
}
var GEOMETRY_TYPE_TO_NODENAME2 = {
  "Point": "Point",
  "LineString": "LineString",
  "LinearRing": "LinearRing",
  "Polygon": "Polygon",
  "MultiPoint": "MultiGeometry",
  "MultiLineString": "MultiGeometry",
  "MultiPolygon": "MultiGeometry",
  "GeometryCollection": "MultiGeometry"
};
var GEOMETRY_NODE_FACTORY = function(value, objectStack, nodeName) {
  if (value) {
    const parentNode = objectStack[objectStack.length - 1].node;
    return createElementNS(
      parentNode.namespaceURI,
      GEOMETRY_TYPE_TO_NODENAME2[value.getType()]
    );
  }
};
var POINT_NODE_FACTORY = makeSimpleNodeFactory("Point");
var LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory("LineString");
var LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory("LinearRing");
var POLYGON_NODE_FACTORY = makeSimpleNodeFactory("Polygon");
var MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "LineString": makeChildAppender(writePrimitiveGeometry),
  "Point": makeChildAppender(writePrimitiveGeometry),
  "Polygon": makeChildAppender(writePolygon),
  "GeometryCollection": makeChildAppender(writeMultiGeometry)
});
function writeMultiGeometry(node, geometry, objectStack) {
  const context = { node };
  const type = geometry.getType();
  let geometries = [];
  let factory;
  if (type === "GeometryCollection") {
    geometry.getGeometriesArrayRecursive().forEach(function(geometry2) {
      const type2 = geometry2.getType();
      if (type2 === "MultiPoint") {
        geometries = geometries.concat(
          geometry2.getPoints()
        );
      } else if (type2 === "MultiLineString") {
        geometries = geometries.concat(
          geometry2.getLineStrings()
        );
      } else if (type2 === "MultiPolygon") {
        geometries = geometries.concat(
          geometry2.getPolygons()
        );
      } else if (type2 === "Point" || type2 === "LineString" || type2 === "Polygon") {
        geometries.push(geometry2);
      } else {
        assert(false, 39);
      }
    });
    factory = GEOMETRY_NODE_FACTORY;
  } else if (type === "MultiPoint") {
    geometries = geometry.getPoints();
    factory = POINT_NODE_FACTORY;
  } else if (type === "MultiLineString") {
    geometries = geometry.getLineStrings();
    factory = LINE_STRING_NODE_FACTORY;
  } else if (type === "MultiPolygon") {
    geometries = geometry.getPolygons();
    factory = POLYGON_NODE_FACTORY;
  } else {
    assert(false, 39);
  }
  pushSerializeAndPop(
    context,
    MULTI_GEOMETRY_SERIALIZERS,
    factory,
    geometries,
    objectStack
  );
}
var BOUNDARY_IS_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "LinearRing": makeChildAppender(writePrimitiveGeometry)
});
function writeBoundaryIs(node, linearRing2, objectStack) {
  const context = { node };
  pushSerializeAndPop(
    context,
    BOUNDARY_IS_SERIALIZERS,
    LINEAR_RING_NODE_FACTORY,
    [linearRing2],
    objectStack
  );
}
var PLACEMARK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "ExtendedData": makeChildAppender(writeExtendedData),
  "MultiGeometry": makeChildAppender(writeMultiGeometry),
  "LineString": makeChildAppender(writePrimitiveGeometry),
  "LinearRing": makeChildAppender(writePrimitiveGeometry),
  "Point": makeChildAppender(writePrimitiveGeometry),
  "Polygon": makeChildAppender(writePolygon),
  "Style": makeChildAppender(writeStyle),
  "address": makeChildAppender(writeStringTextNode),
  "description": makeChildAppender(writeStringTextNode),
  "name": makeChildAppender(writeStringTextNode),
  "open": makeChildAppender(writeBooleanTextNode),
  "phoneNumber": makeChildAppender(writeStringTextNode),
  "styleUrl": makeChildAppender(writeStringTextNode),
  "visibility": makeChildAppender(writeBooleanTextNode)
});
var PLACEMARK_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, [
  "name",
  "open",
  "visibility",
  "address",
  "phoneNumber",
  "description",
  "styleUrl",
  "Style"
]);
var EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory("ExtendedData");
function writePlacemark(node, feature, objectStack) {
  const context = { node };
  if (feature.getId()) {
    node.setAttribute("id", feature.getId());
  }
  const properties = feature.getProperties();
  const filter = {
    "address": 1,
    "description": 1,
    "name": 1,
    "open": 1,
    "phoneNumber": 1,
    "styleUrl": 1,
    "visibility": 1
  };
  filter[feature.getGeometryName()] = 1;
  const keys = Object.keys(properties || {}).sort().filter(function(v) {
    return !filter[v];
  });
  const styleFunction = feature.getStyleFunction();
  if (styleFunction) {
    const styles = styleFunction(feature, 0);
    if (styles) {
      const styleArray = Array.isArray(styles) ? styles : [styles];
      let pointStyles = styleArray;
      if (feature.getGeometry()) {
        pointStyles = styleArray.filter(function(style) {
          const geometry2 = style.getGeometryFunction()(feature);
          if (geometry2) {
            const type = geometry2.getType();
            if (type === "GeometryCollection") {
              return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                const type2 = geometry3.getType();
                return type2 === "Point" || type2 === "MultiPoint";
              }).length;
            }
            return type === "Point" || type === "MultiPoint";
          }
        });
        "Point";
      }
      if (this.writeStyles_) {
        let lineStyles = styleArray;
        let polyStyles = styleArray;
        if (feature.getGeometry()) {
          lineStyles = styleArray.filter(function(style) {
            const geometry2 = style.getGeometryFunction()(feature);
            if (geometry2) {
              const type = geometry2.getType();
              if (type === "GeometryCollection") {
                return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                  const type2 = geometry3.getType();
                  return type2 === "LineString" || type2 === "MultiLineString";
                }).length;
              }
              return type === "LineString" || type === "MultiLineString";
            }
          });
          polyStyles = styleArray.filter(function(style) {
            const geometry2 = style.getGeometryFunction()(feature);
            if (geometry2) {
              const type = geometry2.getType();
              if (type === "GeometryCollection") {
                return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                  const type2 = geometry3.getType();
                  return type2 === "Polygon" || type2 === "MultiPolygon";
                }).length;
              }
              return type === "Polygon" || type === "MultiPolygon";
            }
          });
        }
        properties["Style"] = {
          pointStyles,
          lineStyles,
          polyStyles
        };
      }
      if (pointStyles.length && properties["name"] === void 0) {
        const textStyle = pointStyles[0].getText();
        if (textStyle) {
          properties["name"] = textStyle.getText();
        }
      }
    }
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];
  const values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(
    context,
    PLACEMARK_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
  if (keys.length > 0) {
    const sequence = makeSequence(properties, keys);
    const namesAndValues = { names: keys, values: sequence };
    pushSerializeAndPop(
      context,
      PLACEMARK_SERIALIZERS,
      EXTENDEDDATA_NODE_FACTORY,
      [namesAndValues],
      objectStack
    );
  }
  const options = objectStack[0];
  let geometry = feature.getGeometry();
  if (geometry) {
    geometry = transformGeometryWithOptions(geometry, true, options);
  }
  pushSerializeAndPop(
    context,
    PLACEMARK_SERIALIZERS,
    GEOMETRY_NODE_FACTORY,
    [geometry],
    objectStack
  );
}
var PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, [
  "extrude",
  "tessellate",
  "altitudeMode",
  "coordinates"
]);
var PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "extrude": makeChildAppender(writeBooleanTextNode),
  "tessellate": makeChildAppender(writeBooleanTextNode),
  "altitudeMode": makeChildAppender(writeStringTextNode),
  "coordinates": makeChildAppender(writeCoordinatesTextNode)
});
function writePrimitiveGeometry(node, geometry, objectStack) {
  const flatCoordinates = geometry.getFlatCoordinates();
  const context = { node };
  context["layout"] = geometry.getLayout();
  context["stride"] = geometry.getStride();
  const properties = geometry.getProperties();
  properties.coordinates = flatCoordinates;
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];
  const values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(
    context,
    PRIMITIVE_GEOMETRY_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
}
var POLY_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, [
  "color",
  "fill",
  "outline"
]);
var POLYGON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "outerBoundaryIs": makeChildAppender(writeBoundaryIs),
  "innerBoundaryIs": makeChildAppender(writeBoundaryIs)
});
var INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory("innerBoundaryIs");
var OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory("outerBoundaryIs");
function writePolygon(node, polygon, objectStack) {
  const linearRings2 = polygon.getLinearRings();
  const outerRing = linearRings2.shift();
  const context = { node };
  pushSerializeAndPop(
    context,
    POLYGON_SERIALIZERS,
    INNER_BOUNDARY_NODE_FACTORY,
    linearRings2,
    objectStack
  );
  pushSerializeAndPop(
    context,
    POLYGON_SERIALIZERS,
    OUTER_BOUNDARY_NODE_FACTORY,
    [outerRing],
    objectStack
  );
}
var POLY_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "color": makeChildAppender(writeColorTextNode),
  "fill": makeChildAppender(writeBooleanTextNode),
  "outline": makeChildAppender(writeBooleanTextNode)
});
function writePolyStyle(node, style, objectStack) {
  const context = { node };
  const fill = style.getFill();
  const stroke = style.getStroke();
  const properties = {
    "color": fill ? fill.getColor() : void 0,
    "fill": fill ? void 0 : false,
    "outline": stroke ? void 0 : false
  };
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];
  const values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(
    context,
    POLY_STYLE_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
}
function writeScaleTextNode(node, scale2) {
  writeDecimalTextNode(node, Math.round(scale2 * 1e6) / 1e6);
}
var STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, [
  "IconStyle",
  "LabelStyle",
  "LineStyle",
  "PolyStyle"
]);
var STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "IconStyle": makeChildAppender(writeIconStyle),
  "LabelStyle": makeChildAppender(writeLabelStyle),
  "LineStyle": makeChildAppender(writeLineStyle),
  "PolyStyle": makeChildAppender(writePolyStyle)
});
function writeStyle(node, styles, objectStack) {
  const context = { node };
  const properties = {};
  if (styles.pointStyles.length) {
    const textStyle = styles.pointStyles[0].getText();
    if (textStyle) {
      properties["LabelStyle"] = textStyle;
    }
    const imageStyle = styles.pointStyles[0].getImage();
    if (imageStyle && typeof imageStyle.getSrc === "function") {
      properties["IconStyle"] = imageStyle;
    }
  }
  if (styles.lineStyles.length) {
    const strokeStyle = styles.lineStyles[0].getStroke();
    if (strokeStyle) {
      properties["LineStyle"] = strokeStyle;
    }
  }
  if (styles.polyStyles.length) {
    const strokeStyle = styles.polyStyles[0].getStroke();
    if (strokeStyle && !properties["LineStyle"]) {
      properties["LineStyle"] = strokeStyle;
    }
    properties["PolyStyle"] = styles.polyStyles[0];
  }
  const parentNode = objectStack[objectStack.length - 1].node;
  const orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];
  const values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(
    context,
    STYLE_SERIALIZERS,
    OBJECT_PROPERTY_NODE_FACTORY,
    values,
    objectStack,
    orderedKeys
  );
}
function writeVec2(node, vec2) {
  node.setAttribute("x", String(vec2.x));
  node.setAttribute("y", String(vec2.y));
  node.setAttribute("xunits", vec2.xunits);
  node.setAttribute("yunits", vec2.yunits);
}
var KML_default = KML;

// node_modules/ol/format/MVT.js
var import_pbf = __toESM(require_pbf(), 1);

// node_modules/ol/geom/Circle.js
var Circle = class extends SimpleGeometry_default {
  constructor(center, radius, layout) {
    super();
    if (layout !== void 0 && radius === void 0) {
      this.setFlatCoordinates(layout, center);
    } else {
      radius = radius ? radius : 0;
      this.setCenterAndRadius(center, radius, layout);
    }
  }
  clone() {
    const circle = new Circle(
      this.flatCoordinates.slice(),
      void 0,
      this.layout
    );
    circle.applyProperties(this);
    return circle;
  }
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    const flatCoordinates = this.flatCoordinates;
    const dx = x - flatCoordinates[0];
    const dy = y - flatCoordinates[1];
    const squaredDistance2 = dx * dx + dy * dy;
    if (squaredDistance2 < minSquaredDistance) {
      if (squaredDistance2 === 0) {
        for (let i = 0; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      } else {
        const delta = this.getRadius() / Math.sqrt(squaredDistance2);
        closestPoint[0] = flatCoordinates[0] + delta * dx;
        closestPoint[1] = flatCoordinates[1] + delta * dy;
        for (let i = 2; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      }
      closestPoint.length = this.stride;
      return squaredDistance2;
    }
    return minSquaredDistance;
  }
  containsXY(x, y) {
    const flatCoordinates = this.flatCoordinates;
    const dx = x - flatCoordinates[0];
    const dy = y - flatCoordinates[1];
    return dx * dx + dy * dy <= this.getRadiusSquared_();
  }
  getCenter() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  computeExtent(extent) {
    const flatCoordinates = this.flatCoordinates;
    const radius = flatCoordinates[this.stride] - flatCoordinates[0];
    return createOrUpdate(
      flatCoordinates[0] - radius,
      flatCoordinates[1] - radius,
      flatCoordinates[0] + radius,
      flatCoordinates[1] + radius,
      extent
    );
  }
  getRadius() {
    return Math.sqrt(this.getRadiusSquared_());
  }
  getRadiusSquared_() {
    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return dx * dx + dy * dy;
  }
  getType() {
    return "Circle";
  }
  intersectsExtent(extent) {
    const circleExtent = this.getExtent();
    if (intersects(extent, circleExtent)) {
      const center = this.getCenter();
      if (extent[0] <= center[0] && extent[2] >= center[0]) {
        return true;
      }
      if (extent[1] <= center[1] && extent[3] >= center[1]) {
        return true;
      }
      return forEachCorner(extent, this.intersectsCoordinate.bind(this));
    }
    return false;
  }
  setCenter(center) {
    const stride = this.stride;
    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
    const flatCoordinates = center.slice();
    flatCoordinates[stride] = flatCoordinates[0] + radius;
    for (let i = 1; i < stride; ++i) {
      flatCoordinates[stride + i] = center[i];
    }
    this.setFlatCoordinates(this.layout, flatCoordinates);
    this.changed();
  }
  setCenterAndRadius(center, radius, layout) {
    this.setLayout(layout, center, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const flatCoordinates = this.flatCoordinates;
    let offset2 = deflateCoordinate(flatCoordinates, 0, center, this.stride);
    flatCoordinates[offset2++] = flatCoordinates[0] + radius;
    for (let i = 1, ii = this.stride; i < ii; ++i) {
      flatCoordinates[offset2++] = flatCoordinates[i];
    }
    flatCoordinates.length = offset2;
    this.changed();
  }
  getCoordinates() {
    return null;
  }
  setCoordinates(coordinates2, layout) {
  }
  setRadius(radius) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
    this.changed();
  }
  rotate(angle, anchor) {
    const center = this.getCenter();
    const stride = this.getStride();
    this.setCenter(
      rotate(center, 0, center.length, stride, angle, anchor, center)
    );
    this.changed();
  }
  translate(deltaX, deltaY) {
    const center = this.getCenter();
    const stride = this.getStride();
    this.setCenter(
      translate(center, 0, center.length, stride, deltaX, deltaY, center)
    );
    this.changed();
  }
};
Circle.prototype.transform;

// node_modules/ol/render/Feature.js
var tmpTransform2 = create();
var RenderFeature = class {
  constructor(type, flatCoordinates, ends, properties, id) {
    this.styleFunction;
    this.extent_;
    this.id_ = id;
    this.type_ = type;
    this.flatCoordinates_ = flatCoordinates;
    this.flatInteriorPoints_ = null;
    this.flatMidpoints_ = null;
    this.ends_ = ends;
    this.properties_ = properties;
  }
  get(key) {
    return this.properties_[key];
  }
  getExtent() {
    if (!this.extent_) {
      this.extent_ = this.type_ === "Point" ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2
      );
    }
    return this.extent_;
  }
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const flatCenter = getCenter(this.getExtent());
      this.flatInteriorPoints_ = getInteriorPointOfArray(
        this.flatCoordinates_,
        0,
        this.ends_,
        2,
        flatCenter,
        0
      );
    }
    return this.flatInteriorPoints_;
  }
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const flatCenters = linearRingss2(
        this.flatCoordinates_,
        0,
        this.ends_,
        2
      );
      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
        this.flatCoordinates_,
        0,
        this.ends_,
        2,
        flatCenters
      );
    }
    return this.flatInteriorPoints_;
  }
  getFlatMidpoint() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = interpolatePoint(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        0.5
      );
    }
    return this.flatMidpoints_;
  }
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const flatCoordinates = this.flatCoordinates_;
      let offset2 = 0;
      const ends = this.ends_;
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        const end = ends[i];
        const midpoint = interpolatePoint(flatCoordinates, offset2, end, 2, 0.5);
        extend2(this.flatMidpoints_, midpoint);
        offset2 = end;
      }
    }
    return this.flatMidpoints_;
  }
  getId() {
    return this.id_;
  }
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  getGeometry() {
    return this;
  }
  getSimplifiedGeometry(squaredTolerance) {
    return this;
  }
  simplifyTransformed(squaredTolerance, transform) {
    return this;
  }
  getProperties() {
    return this.properties_;
  }
  getStride() {
    return 2;
  }
  getStyleFunction() {
    return this.styleFunction;
  }
  getType() {
    return this.type_;
  }
  transform(projection) {
    projection = get(projection);
    const pixelExtent = projection.getExtent();
    const projectedExtent = projection.getWorldExtent();
    if (pixelExtent && projectedExtent) {
      const scale2 = getHeight(projectedExtent) / getHeight(pixelExtent);
      compose(
        tmpTransform2,
        projectedExtent[0],
        projectedExtent[3],
        scale2,
        -scale2,
        0,
        0,
        0
      );
      transform2D(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        tmpTransform2,
        this.flatCoordinates_
      );
    }
  }
  getEnds() {
    return this.ends_;
  }
};
RenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;
RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
var Feature_default3 = RenderFeature;

// node_modules/ol/format/MVT.js
var MVT = class extends Feature_default2 {
  constructor(options) {
    super();
    options = options ? options : {};
    this.dataProjection = new Projection_default({
      code: "",
      units: "tile-pixels"
    });
    this.featureClass_ = options.featureClass ? options.featureClass : Feature_default3;
    this.geometryName_ = options.geometryName;
    this.layerName_ = options.layerName ? options.layerName : "layer";
    this.layers_ = options.layers ? options.layers : null;
    this.idProperty_ = options.idProperty;
    this.supportedMediaTypes = [
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
    ];
  }
  readRawGeometry_(pbf, feature, flatCoordinates, ends) {
    pbf.pos = feature.geometry;
    const end = pbf.readVarint() + pbf.pos;
    let cmd = 1;
    let length = 0;
    let x = 0;
    let y = 0;
    let coordsLen = 0;
    let currentEnd = 0;
    while (pbf.pos < end) {
      if (!length) {
        const cmdLen = pbf.readVarint();
        cmd = cmdLen & 7;
        length = cmdLen >> 3;
      }
      length--;
      if (cmd === 1 || cmd === 2) {
        x += pbf.readSVarint();
        y += pbf.readSVarint();
        if (cmd === 1) {
          if (coordsLen > currentEnd) {
            ends.push(coordsLen);
            currentEnd = coordsLen;
          }
        }
        flatCoordinates.push(x, y);
        coordsLen += 2;
      } else if (cmd === 7) {
        if (coordsLen > currentEnd) {
          flatCoordinates.push(
            flatCoordinates[currentEnd],
            flatCoordinates[currentEnd + 1]
          );
          coordsLen += 2;
        }
      } else {
        assert(false, 59);
      }
    }
    if (coordsLen > currentEnd) {
      ends.push(coordsLen);
      currentEnd = coordsLen;
    }
  }
  createFeature_(pbf, rawFeature, options) {
    const type = rawFeature.type;
    if (type === 0) {
      return null;
    }
    let feature;
    const values = rawFeature.properties;
    let id;
    if (!this.idProperty_) {
      id = rawFeature.id;
    } else {
      id = values[this.idProperty_];
      delete values[this.idProperty_];
    }
    values[this.layerName_] = rawFeature.layer.name;
    const flatCoordinates = [];
    const ends = [];
    this.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);
    const geometryType = getGeometryType(type, ends.length);
    if (this.featureClass_ === Feature_default3) {
      feature = new this.featureClass_(
        geometryType,
        flatCoordinates,
        ends,
        values,
        id
      );
      feature.transform(options.dataProjection);
    } else {
      let geom;
      if (geometryType == "Polygon") {
        const endss = inflateEnds(flatCoordinates, ends);
        geom = endss.length > 1 ? new MultiPolygon_default(flatCoordinates, "XY", endss) : new Polygon_default(flatCoordinates, "XY", ends);
      } else {
        geom = geometryType === "Point" ? new Point_default(flatCoordinates, "XY") : geometryType === "LineString" ? new LineString_default(flatCoordinates, "XY") : geometryType === "MultiPoint" ? new MultiPoint_default(flatCoordinates, "XY") : geometryType === "MultiLineString" ? new MultiLineString_default(flatCoordinates, "XY", ends) : null;
      }
      const ctor = this.featureClass_;
      feature = new ctor();
      if (this.geometryName_) {
        feature.setGeometryName(this.geometryName_);
      }
      const geometry = transformGeometryWithOptions(geom, false, options);
      feature.setGeometry(geometry);
      if (id !== void 0) {
        feature.setId(id);
      }
      feature.setProperties(values, true);
    }
    return feature;
  }
  getType() {
    return "arraybuffer";
  }
  readFeatures(source, options) {
    const layers = this.layers_;
    options = this.adaptOptions(options);
    const dataProjection = get(options.dataProjection);
    dataProjection.setWorldExtent(options.extent);
    options.dataProjection = dataProjection;
    const pbf = new import_pbf.default(source);
    const pbfLayers = pbf.readFields(layersPBFReader, {});
    const features = [];
    for (const name in pbfLayers) {
      if (layers && !layers.includes(name)) {
        continue;
      }
      const pbfLayer = pbfLayers[name];
      const extent = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;
      dataProjection.setExtent(extent);
      for (let i = 0, ii = pbfLayer.length; i < ii; ++i) {
        const rawFeature = readRawFeature(pbf, pbfLayer, i);
        const feature = this.createFeature_(pbf, rawFeature, options);
        if (feature !== null) {
          features.push(feature);
        }
      }
    }
    return features;
  }
  readProjection(source) {
    return this.dataProjection;
  }
  setLayers(layers) {
    this.layers_ = layers;
  }
};
function layersPBFReader(tag, layers, pbf) {
  if (tag === 3) {
    const layer = {
      keys: [],
      values: [],
      features: []
    };
    const end = pbf.readVarint() + pbf.pos;
    pbf.readFields(layerPBFReader, layer, end);
    layer.length = layer.features.length;
    if (layer.length) {
      layers[layer.name] = layer;
    }
  }
}
function layerPBFReader(tag, layer, pbf) {
  if (tag === 15) {
    layer.version = pbf.readVarint();
  } else if (tag === 1) {
    layer.name = pbf.readString();
  } else if (tag === 5) {
    layer.extent = pbf.readVarint();
  } else if (tag === 2) {
    layer.features.push(pbf.pos);
  } else if (tag === 3) {
    layer.keys.push(pbf.readString());
  } else if (tag === 4) {
    let value = null;
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      tag = pbf.readVarint() >> 3;
      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }
    layer.values.push(value);
  }
}
function featurePBFReader(tag, feature, pbf) {
  if (tag == 1) {
    feature.id = pbf.readVarint();
  } else if (tag == 2) {
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const key = feature.layer.keys[pbf.readVarint()];
      const value = feature.layer.values[pbf.readVarint()];
      feature.properties[key] = value;
    }
  } else if (tag == 3) {
    feature.type = pbf.readVarint();
  } else if (tag == 4) {
    feature.geometry = pbf.pos;
  }
}
function readRawFeature(pbf, layer, i) {
  pbf.pos = layer.features[i];
  const end = pbf.readVarint() + pbf.pos;
  const feature = {
    layer,
    type: 0,
    properties: {}
  };
  pbf.readFields(featurePBFReader, feature, end);
  return feature;
}
function getGeometryType(type, numEnds) {
  let geometryType;
  if (type === 1) {
    geometryType = numEnds === 1 ? "Point" : "MultiPoint";
  } else if (type === 2) {
    geometryType = numEnds === 1 ? "LineString" : "MultiLineString";
  } else if (type === 3) {
    geometryType = "Polygon";
  }
  return geometryType;
}
var MVT_default = MVT;

// node_modules/ol/format/XML.js
var XML = class {
  read(source) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      const doc = parse(source);
      return this.readFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readFromDocument(source);
    }
    return this.readFromNode(source);
  }
  readFromDocument(doc) {
    for (let n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readFromNode(n);
      }
    }
    return null;
  }
  readFromNode(node) {
  }
};
var XML_default = XML;

// node_modules/ol/format/xlink.js
var NAMESPACE_URI = "http://www.w3.org/1999/xlink";
function readHref(node) {
  return node.getAttributeNS(NAMESPACE_URI, "href");
}

// node_modules/ol/format/OWS.js
var NAMESPACE_URIS3 = [null, "http://www.opengis.net/ows/1.1"];
var PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "ServiceIdentification": makeObjectPropertySetter(readServiceIdentification),
  "ServiceProvider": makeObjectPropertySetter(readServiceProvider),
  "OperationsMetadata": makeObjectPropertySetter(readOperationsMetadata)
});
var OWS = class extends XML_default {
  constructor() {
    super();
  }
  readFromNode(node) {
    const owsObject = pushParseAndPop({}, PARSERS, node, []);
    return owsObject ? owsObject : null;
  }
};
var ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "DeliveryPoint": makeObjectPropertySetter(readString),
  "City": makeObjectPropertySetter(readString),
  "AdministrativeArea": makeObjectPropertySetter(readString),
  "PostalCode": makeObjectPropertySetter(readString),
  "Country": makeObjectPropertySetter(readString),
  "ElectronicMailAddress": makeObjectPropertySetter(readString)
});
var ALLOWED_VALUES_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Value": makeObjectPropertyPusher(readValue)
});
var CONSTRAINT_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "AllowedValues": makeObjectPropertySetter(readAllowedValues)
});
var CONTACT_INFO_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Phone": makeObjectPropertySetter(readPhone),
  "Address": makeObjectPropertySetter(readAddress)
});
var DCP_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "HTTP": makeObjectPropertySetter(readHttp)
});
var HTTP_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Get": makeObjectPropertyPusher(readGet),
  "Post": void 0
});
var OPERATION_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "DCP": makeObjectPropertySetter(readDcp)
});
var OPERATIONS_METADATA_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Operation": readOperation
});
var PHONE_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Voice": makeObjectPropertySetter(readString),
  "Facsimile": makeObjectPropertySetter(readString)
});
var REQUEST_METHOD_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Constraint": makeObjectPropertyPusher(readConstraint)
});
var SERVICE_CONTACT_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "IndividualName": makeObjectPropertySetter(readString),
  "PositionName": makeObjectPropertySetter(readString),
  "ContactInfo": makeObjectPropertySetter(readContactInfo)
});
var SERVICE_IDENTIFICATION_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Abstract": makeObjectPropertySetter(readString),
  "AccessConstraints": makeObjectPropertySetter(readString),
  "Fees": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "ServiceTypeVersion": makeObjectPropertySetter(readString),
  "ServiceType": makeObjectPropertySetter(readString)
});
var SERVICE_PROVIDER_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "ProviderName": makeObjectPropertySetter(readString),
  "ProviderSite": makeObjectPropertySetter(readHref),
  "ServiceContact": makeObjectPropertySetter(readServiceContact)
});
function readAddress(node, objectStack) {
  return pushParseAndPop({}, ADDRESS_PARSERS, node, objectStack);
}
function readAllowedValues(node, objectStack) {
  return pushParseAndPop({}, ALLOWED_VALUES_PARSERS, node, objectStack);
}
function readConstraint(node, objectStack) {
  const name = node.getAttribute("name");
  if (!name) {
    return void 0;
  }
  return pushParseAndPop({ "name": name }, CONSTRAINT_PARSERS, node, objectStack);
}
function readContactInfo(node, objectStack) {
  return pushParseAndPop({}, CONTACT_INFO_PARSERS, node, objectStack);
}
function readDcp(node, objectStack) {
  return pushParseAndPop({}, DCP_PARSERS, node, objectStack);
}
function readGet(node, objectStack) {
  const href = readHref(node);
  if (!href) {
    return void 0;
  }
  return pushParseAndPop(
    { "href": href },
    REQUEST_METHOD_PARSERS,
    node,
    objectStack
  );
}
function readHttp(node, objectStack) {
  return pushParseAndPop({}, HTTP_PARSERS, node, objectStack);
}
function readOperation(node, objectStack) {
  const name = node.getAttribute("name");
  const value = pushParseAndPop({}, OPERATION_PARSERS, node, objectStack);
  if (!value) {
    return void 0;
  }
  const object = objectStack[objectStack.length - 1];
  object[name] = value;
}
function readOperationsMetadata(node, objectStack) {
  return pushParseAndPop({}, OPERATIONS_METADATA_PARSERS, node, objectStack);
}
function readPhone(node, objectStack) {
  return pushParseAndPop({}, PHONE_PARSERS, node, objectStack);
}
function readServiceIdentification(node, objectStack) {
  return pushParseAndPop({}, SERVICE_IDENTIFICATION_PARSERS, node, objectStack);
}
function readServiceContact(node, objectStack) {
  return pushParseAndPop({}, SERVICE_CONTACT_PARSERS, node, objectStack);
}
function readServiceProvider(node, objectStack) {
  return pushParseAndPop({}, SERVICE_PROVIDER_PARSERS, node, objectStack);
}
function readValue(node, objectStack) {
  return readString(node);
}
var OWS_default = OWS;

// node_modules/ol/geom/flat/flip.js
function flipXY(flatCoordinates, offset2, end, stride, dest, destOffset) {
  if (dest !== void 0) {
    dest = dest;
    destOffset = destOffset !== void 0 ? destOffset : 0;
  } else {
    dest = [];
    destOffset = 0;
  }
  let j = offset2;
  while (j < end) {
    const x = flatCoordinates[j++];
    dest[destOffset++] = flatCoordinates[j++];
    dest[destOffset++] = x;
    for (let k = 2; k < stride; ++k) {
      dest[destOffset++] = flatCoordinates[j++];
    }
  }
  dest.length = destOffset;
  return dest;
}

// node_modules/ol/format/Polyline.js
var Polyline = class extends TextFeature_default {
  constructor(options) {
    super();
    options = options ? options : {};
    this.dataProjection = get("EPSG:4326");
    this.factor_ = options.factor ? options.factor : 1e5;
    this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : "XY";
  }
  readFeatureFromText(text, options) {
    const geometry = this.readGeometryFromText(text, options);
    return new Feature_default(geometry);
  }
  readFeaturesFromText(text, options) {
    const feature = this.readFeatureFromText(text, options);
    return [feature];
  }
  readGeometryFromText(text, options) {
    const stride = getStrideForLayout(this.geometryLayout_);
    const flatCoordinates = decodeDeltas(text, stride, this.factor_);
    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
    const coordinates2 = inflateCoordinates(
      flatCoordinates,
      0,
      flatCoordinates.length,
      stride
    );
    const lineString = new LineString_default(coordinates2, this.geometryLayout_);
    return transformGeometryWithOptions(
      lineString,
      false,
      this.adaptOptions(options)
    );
  }
  writeFeatureText(feature, options) {
    const geometry = feature.getGeometry();
    if (geometry) {
      return this.writeGeometryText(geometry, options);
    }
    assert(false, 40);
    return "";
  }
  writeFeaturesText(features, options) {
    return this.writeFeatureText(features[0], options);
  }
  writeGeometryText(geometry, options) {
    geometry = transformGeometryWithOptions(geometry, true, this.adaptOptions(options));
    const flatCoordinates = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
    return encodeDeltas(flatCoordinates, stride, this.factor_);
  }
};
function encodeDeltas(numbers, stride, factor) {
  factor = factor ? factor : 1e5;
  let d;
  const lastNumbers = new Array(stride);
  for (d = 0; d < stride; ++d) {
    lastNumbers[d] = 0;
  }
  for (let i = 0, ii = numbers.length; i < ii; ) {
    for (d = 0; d < stride; ++d, ++i) {
      const num = numbers[i];
      const delta = num - lastNumbers[d];
      lastNumbers[d] = num;
      numbers[i] = delta;
    }
  }
  return encodeFloats(numbers, factor);
}
function decodeDeltas(encoded, stride, factor) {
  factor = factor ? factor : 1e5;
  let d;
  const lastNumbers = new Array(stride);
  for (d = 0; d < stride; ++d) {
    lastNumbers[d] = 0;
  }
  const numbers = decodeFloats(encoded, factor);
  for (let i = 0, ii = numbers.length; i < ii; ) {
    for (d = 0; d < stride; ++d, ++i) {
      lastNumbers[d] += numbers[i];
      numbers[i] = lastNumbers[d];
    }
  }
  return numbers;
}
function encodeFloats(numbers, factor) {
  factor = factor ? factor : 1e5;
  for (let i = 0, ii = numbers.length; i < ii; ++i) {
    numbers[i] = Math.round(numbers[i] * factor);
  }
  return encodeSignedIntegers(numbers);
}
function decodeFloats(encoded, factor) {
  factor = factor ? factor : 1e5;
  const numbers = decodeSignedIntegers(encoded);
  for (let i = 0, ii = numbers.length; i < ii; ++i) {
    numbers[i] /= factor;
  }
  return numbers;
}
function encodeSignedIntegers(numbers) {
  for (let i = 0, ii = numbers.length; i < ii; ++i) {
    const num = numbers[i];
    numbers[i] = num < 0 ? ~(num << 1) : num << 1;
  }
  return encodeUnsignedIntegers(numbers);
}
function decodeSignedIntegers(encoded) {
  const numbers = decodeUnsignedIntegers(encoded);
  for (let i = 0, ii = numbers.length; i < ii; ++i) {
    const num = numbers[i];
    numbers[i] = num & 1 ? ~(num >> 1) : num >> 1;
  }
  return numbers;
}
function encodeUnsignedIntegers(numbers) {
  let encoded = "";
  for (let i = 0, ii = numbers.length; i < ii; ++i) {
    encoded += encodeUnsignedInteger(numbers[i]);
  }
  return encoded;
}
function decodeUnsignedIntegers(encoded) {
  const numbers = [];
  let current = 0;
  let shift = 0;
  for (let i = 0, ii = encoded.length; i < ii; ++i) {
    const b = encoded.charCodeAt(i) - 63;
    current |= (b & 31) << shift;
    if (b < 32) {
      numbers.push(current);
      current = 0;
      shift = 0;
    } else {
      shift += 5;
    }
  }
  return numbers;
}
function encodeUnsignedInteger(num) {
  let value, encoded = "";
  while (num >= 32) {
    value = (32 | num & 31) + 63;
    encoded += String.fromCharCode(value);
    num >>= 5;
  }
  value = num + 63;
  encoded += String.fromCharCode(value);
  return encoded;
}
var Polyline_default = Polyline;

// node_modules/ol/format/TopoJSON.js
var TopoJSON = class extends JSONFeature_default {
  constructor(options) {
    super();
    options = options ? options : {};
    this.layerName_ = options.layerName;
    this.layers_ = options.layers ? options.layers : null;
    this.dataProjection = get(
      options.dataProjection ? options.dataProjection : "EPSG:4326"
    );
  }
  readFeaturesFromObject(object, options) {
    if (object.type == "Topology") {
      const topoJSONTopology = object;
      let transform, scale2 = null, translate2 = null;
      if (topoJSONTopology["transform"]) {
        transform = topoJSONTopology["transform"];
        scale2 = transform["scale"];
        translate2 = transform["translate"];
      }
      const arcs = topoJSONTopology["arcs"];
      if (transform) {
        transformArcs(arcs, scale2, translate2);
      }
      const features = [];
      const topoJSONFeatures = topoJSONTopology["objects"];
      const property = this.layerName_;
      let feature;
      for (const objectName in topoJSONFeatures) {
        if (this.layers_ && !this.layers_.includes(objectName)) {
          continue;
        }
        if (topoJSONFeatures[objectName].type === "GeometryCollection") {
          feature = topoJSONFeatures[objectName];
          features.push.apply(
            features,
            readFeaturesFromGeometryCollection(
              feature,
              arcs,
              scale2,
              translate2,
              property,
              objectName,
              options
            )
          );
        } else {
          feature = topoJSONFeatures[objectName];
          features.push(
            readFeatureFromGeometry(
              feature,
              arcs,
              scale2,
              translate2,
              property,
              objectName,
              options
            )
          );
        }
      }
      return features;
    }
    return [];
  }
  readProjectionFromObject(object) {
    return this.dataProjection;
  }
};
var GEOMETRY_READERS2 = {
  "Point": readPointGeometry3,
  "LineString": readLineStringGeometry3,
  "Polygon": readPolygonGeometry3,
  "MultiPoint": readMultiPointGeometry3,
  "MultiLineString": readMultiLineStringGeometry3,
  "MultiPolygon": readMultiPolygonGeometry3
};
function concatenateArcs(indices, arcs) {
  const coordinates2 = [];
  let index;
  for (let i = 0, ii = indices.length; i < ii; ++i) {
    index = indices[i];
    if (i > 0) {
      coordinates2.pop();
    }
    if (index >= 0) {
      const arc = arcs[index];
      for (let j = 0, jj = arc.length; j < jj; ++j) {
        coordinates2.push(arc[j].slice(0));
      }
    } else {
      const arc = arcs[~index];
      for (let j = arc.length - 1; j >= 0; --j) {
        coordinates2.push(arc[j].slice(0));
      }
    }
  }
  return coordinates2;
}
function readPointGeometry3(object, scale2, translate2) {
  const coordinates2 = object["coordinates"];
  if (scale2 && translate2) {
    transformVertex(coordinates2, scale2, translate2);
  }
  return new Point_default(coordinates2);
}
function readMultiPointGeometry3(object, scale2, translate2) {
  const coordinates2 = object["coordinates"];
  if (scale2 && translate2) {
    for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
      transformVertex(coordinates2[i], scale2, translate2);
    }
  }
  return new MultiPoint_default(coordinates2);
}
function readLineStringGeometry3(object, arcs) {
  const coordinates2 = concatenateArcs(object["arcs"], arcs);
  return new LineString_default(coordinates2);
}
function readMultiLineStringGeometry3(object, arcs) {
  const coordinates2 = [];
  for (let i = 0, ii = object["arcs"].length; i < ii; ++i) {
    coordinates2[i] = concatenateArcs(object["arcs"][i], arcs);
  }
  return new MultiLineString_default(coordinates2);
}
function readPolygonGeometry3(object, arcs) {
  const coordinates2 = [];
  for (let i = 0, ii = object["arcs"].length; i < ii; ++i) {
    coordinates2[i] = concatenateArcs(object["arcs"][i], arcs);
  }
  return new Polygon_default(coordinates2);
}
function readMultiPolygonGeometry3(object, arcs) {
  const coordinates2 = [];
  for (let i = 0, ii = object["arcs"].length; i < ii; ++i) {
    const polyArray = object["arcs"][i];
    const ringCoords = [];
    for (let j = 0, jj = polyArray.length; j < jj; ++j) {
      ringCoords[j] = concatenateArcs(polyArray[j], arcs);
    }
    coordinates2[i] = ringCoords;
  }
  return new MultiPolygon_default(coordinates2);
}
function readFeaturesFromGeometryCollection(collection, arcs, scale2, translate2, property, name, options) {
  const geometries = collection["geometries"];
  const features = [];
  for (let i = 0, ii = geometries.length; i < ii; ++i) {
    features[i] = readFeatureFromGeometry(
      geometries[i],
      arcs,
      scale2,
      translate2,
      property,
      name,
      options
    );
  }
  return features;
}
function readFeatureFromGeometry(object, arcs, scale2, translate2, property, name, options) {
  let geometry = null;
  const type = object.type;
  if (type) {
    const geometryReader = GEOMETRY_READERS2[type];
    if (type === "Point" || type === "MultiPoint") {
      geometry = geometryReader(object, scale2, translate2);
    } else {
      geometry = geometryReader(object, arcs);
    }
    geometry = transformGeometryWithOptions(geometry, false, options);
  }
  const feature = new Feature_default({ geometry });
  if (object.id !== void 0) {
    feature.setId(object.id);
  }
  let properties = object.properties;
  if (property) {
    if (!properties) {
      properties = {};
    }
    properties[property] = name;
  }
  if (properties) {
    feature.setProperties(properties, true);
  }
  return feature;
}
function transformArcs(arcs, scale2, translate2) {
  for (let i = 0, ii = arcs.length; i < ii; ++i) {
    transformArc(arcs[i], scale2, translate2);
  }
}
function transformArc(arc, scale2, translate2) {
  let x = 0;
  let y = 0;
  for (let i = 0, ii = arc.length; i < ii; ++i) {
    const vertex = arc[i];
    x += vertex[0];
    y += vertex[1];
    vertex[0] = x;
    vertex[1] = y;
    transformVertex(vertex, scale2, translate2);
  }
}
function transformVertex(vertex, scale2, translate2) {
  vertex[0] = vertex[0] * scale2[0] + translate2[0];
  vertex[1] = vertex[1] * scale2[1] + translate2[1];
}
var TopoJSON_default = TopoJSON;

// node_modules/ol/format/GML32.js
var GML32 = class extends GML3_default {
  constructor(options) {
    options = options ? options : {};
    super(options);
    this.schemaLocation = options.schemaLocation ? options.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
  }
  writeGeometryElement(node, geometry, objectStack) {
    const context = objectStack[objectStack.length - 1];
    objectStack[objectStack.length - 1] = Object.assign(
      { multiCurve: true, multiSurface: true },
      context
    );
    super.writeGeometryElement(node, geometry, objectStack);
  }
};
GML32.prototype.namespace = "http://www.opengis.net/gml/3.2";
GML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "pos": makeReplacer(GML3_default.prototype.readFlatPos),
    "posList": makeReplacer(GML3_default.prototype.readFlatPosList),
    "coordinates": makeReplacer(GML2_default.prototype.readFlatCoordinates)
  }
};
GML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "interior": GML3_default.prototype.interiorParser,
    "exterior": GML3_default.prototype.exteriorParser
  }
};
GML32.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Point": makeReplacer(GMLBase_default.prototype.readPoint),
    "MultiPoint": makeReplacer(GMLBase_default.prototype.readMultiPoint),
    "LineString": makeReplacer(GMLBase_default.prototype.readLineString),
    "MultiLineString": makeReplacer(GMLBase_default.prototype.readMultiLineString),
    "LinearRing": makeReplacer(GMLBase_default.prototype.readLinearRing),
    "Polygon": makeReplacer(GMLBase_default.prototype.readPolygon),
    "MultiPolygon": makeReplacer(GMLBase_default.prototype.readMultiPolygon),
    "Surface": makeReplacer(GML32.prototype.readSurface),
    "MultiSurface": makeReplacer(GML3_default.prototype.readMultiSurface),
    "Curve": makeReplacer(GML32.prototype.readCurve),
    "MultiCurve": makeReplacer(GML3_default.prototype.readMultiCurve),
    "Envelope": makeReplacer(GML32.prototype.readEnvelope)
  }
};
GML32.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "curveMember": makeArrayPusher(GML3_default.prototype.curveMemberParser),
    "curveMembers": makeArrayPusher(GML3_default.prototype.curveMemberParser)
  }
};
GML32.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "surfaceMember": makeArrayPusher(GML3_default.prototype.surfaceMemberParser),
    "surfaceMembers": makeArrayPusher(GML3_default.prototype.surfaceMemberParser)
  }
};
GML32.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LineString": makeArrayPusher(GMLBase_default.prototype.readLineString),
    "Curve": makeArrayPusher(GML3_default.prototype.readCurve)
  }
};
GML32.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Polygon": makeArrayPusher(GMLBase_default.prototype.readPolygon),
    "Surface": makeArrayPusher(GML3_default.prototype.readSurface)
  }
};
GML32.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "patches": makeReplacer(GML3_default.prototype.readPatch)
  }
};
GML32.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "segments": makeReplacer(GML3_default.prototype.readSegment)
  }
};
GML32.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "lowerCorner": makeArrayPusher(GML3_default.prototype.readFlatPosList),
    "upperCorner": makeArrayPusher(GML3_default.prototype.readFlatPosList)
  }
};
GML32.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "PolygonPatch": makeReplacer(GML3_default.prototype.readPolygonPatch)
  }
};
GML32.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LineStringSegment": makeArrayExtender(
      GML3_default.prototype.readLineStringSegment
    )
  }
};
GML32.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "pointMember": makeArrayPusher(GMLBase_default.prototype.pointMemberParser),
    "pointMembers": makeArrayPusher(GMLBase_default.prototype.pointMemberParser)
  }
};
GML32.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "lineStringMember": makeArrayPusher(
      GMLBase_default.prototype.lineStringMemberParser
    ),
    "lineStringMembers": makeArrayPusher(
      GMLBase_default.prototype.lineStringMemberParser
    )
  }
};
GML32.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "polygonMember": makeArrayPusher(GMLBase_default.prototype.polygonMemberParser),
    "polygonMembers": makeArrayPusher(GMLBase_default.prototype.polygonMemberParser)
  }
};
GML32.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Point": makeArrayPusher(GMLBase_default.prototype.readFlatCoordinatesFromNode)
  }
};
GML32.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LineString": makeArrayPusher(GMLBase_default.prototype.readLineString)
  }
};
GML32.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Polygon": makeArrayPusher(GMLBase_default.prototype.readPolygon)
  }
};
GML32.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LinearRing": makeReplacer(GMLBase_default.prototype.readFlatLinearRing),
    "Ring": makeReplacer(GML32.prototype.readFlatCurveRing)
  }
};
GML32.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "exterior": makeChildAppender(GML3_default.prototype.writeRing),
    "interior": makeChildAppender(GML3_default.prototype.writeRing)
  }
};
GML32.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "lowerCorner": makeChildAppender(writeStringTextNode),
    "upperCorner": makeChildAppender(writeStringTextNode)
  }
};
GML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "surfaceMember": makeChildAppender(
      GML3_default.prototype.writeSurfaceOrPolygonMember
    ),
    "polygonMember": makeChildAppender(
      GML3_default.prototype.writeSurfaceOrPolygonMember
    )
  }
};
GML32.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "pointMember": makeChildAppender(GML3_default.prototype.writePointMember)
  }
};
GML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "lineStringMember": makeChildAppender(
      GML3_default.prototype.writeLineStringOrCurveMember
    ),
    "curveMember": makeChildAppender(
      GML3_default.prototype.writeLineStringOrCurveMember
    )
  }
};
GML32.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "Curve": makeChildAppender(GML3_default.prototype.writeCurveOrLineString),
    "MultiCurve": makeChildAppender(GML3_default.prototype.writeMultiCurveOrLineString),
    "Point": makeChildAppender(GML32.prototype.writePoint),
    "MultiPoint": makeChildAppender(GML3_default.prototype.writeMultiPoint),
    "LineString": makeChildAppender(GML3_default.prototype.writeCurveOrLineString),
    "MultiLineString": makeChildAppender(
      GML3_default.prototype.writeMultiCurveOrLineString
    ),
    "LinearRing": makeChildAppender(GML3_default.prototype.writeLinearRing),
    "Polygon": makeChildAppender(GML3_default.prototype.writeSurfaceOrPolygon),
    "MultiPolygon": makeChildAppender(
      GML3_default.prototype.writeMultiSurfaceOrPolygon
    ),
    "Surface": makeChildAppender(GML3_default.prototype.writeSurfaceOrPolygon),
    "MultiSurface": makeChildAppender(
      GML3_default.prototype.writeMultiSurfaceOrPolygon
    ),
    "Envelope": makeChildAppender(GML3_default.prototype.writeEnvelope)
  }
};
var GML32_default = GML32;

// node_modules/ol/format/filter/Filter.js
var Filter = class {
  constructor(tagName) {
    this.tagName_ = tagName;
  }
  getTagName() {
    return this.tagName_;
  }
};
var Filter_default = Filter;

// node_modules/ol/format/filter/LogicalNary.js
var LogicalNary = class extends Filter_default {
  constructor(tagName, conditions) {
    super(tagName);
    this.conditions = conditions;
    assert(this.conditions.length >= 2, 57);
  }
};
var LogicalNary_default = LogicalNary;

// node_modules/ol/format/filter/And.js
var And = class extends LogicalNary_default {
  constructor(conditions) {
    super("And", Array.prototype.slice.call(arguments));
  }
};
var And_default = And;

// node_modules/ol/format/filter/Bbox.js
var Bbox = class extends Filter_default {
  constructor(geometryName, extent, srsName) {
    super("BBOX");
    this.geometryName = geometryName;
    this.extent = extent;
    if (extent.length !== 4) {
      throw new Error(
        "Expected an extent with four values ([minX, minY, maxX, maxY])"
      );
    }
    this.srsName = srsName;
  }
};
var Bbox_default = Bbox;

// node_modules/ol/format/filter.js
function and(conditions) {
  const params = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(And_default, params))();
}
function bbox(geometryName, extent, srsName) {
  return new Bbox_default(geometryName, extent, srsName);
}

// node_modules/ol/format/WFS.js
var FEATURE_COLLECTION_PARSERS = {
  "http://www.opengis.net/gml": {
    "boundedBy": makeObjectPropertySetter(
      GMLBase_default.prototype.readExtentElement,
      "bounds"
    )
  },
  "http://www.opengis.net/wfs/2.0": {
    "member": makeArrayPusher(GMLBase_default.prototype.readFeaturesInternal)
  }
};
var TRANSACTION_SUMMARY_PARSERS = {
  "http://www.opengis.net/wfs": {
    "totalInserted": makeObjectPropertySetter(readPositiveInteger),
    "totalUpdated": makeObjectPropertySetter(readPositiveInteger),
    "totalDeleted": makeObjectPropertySetter(readPositiveInteger)
  },
  "http://www.opengis.net/wfs/2.0": {
    "totalInserted": makeObjectPropertySetter(readPositiveInteger),
    "totalUpdated": makeObjectPropertySetter(readPositiveInteger),
    "totalDeleted": makeObjectPropertySetter(readPositiveInteger)
  }
};
var TRANSACTION_RESPONSE_PARSERS = {
  "http://www.opengis.net/wfs": {
    "TransactionSummary": makeObjectPropertySetter(
      readTransactionSummary,
      "transactionSummary"
    ),
    "InsertResults": makeObjectPropertySetter(readInsertResults, "insertIds")
  },
  "http://www.opengis.net/wfs/2.0": {
    "TransactionSummary": makeObjectPropertySetter(
      readTransactionSummary,
      "transactionSummary"
    ),
    "InsertResults": makeObjectPropertySetter(readInsertResults, "insertIds")
  }
};
var QUERY_SERIALIZERS = {
  "http://www.opengis.net/wfs": {
    "PropertyName": makeChildAppender(writeStringTextNode)
  },
  "http://www.opengis.net/wfs/2.0": {
    "PropertyName": makeChildAppender(writeStringTextNode)
  }
};
var TRANSACTION_SERIALIZERS = {
  "http://www.opengis.net/wfs": {
    "Insert": makeChildAppender(writeFeature),
    "Update": makeChildAppender(writeUpdate),
    "Delete": makeChildAppender(writeDelete),
    "Property": makeChildAppender(writeProperty),
    "Native": makeChildAppender(writeNative)
  },
  "http://www.opengis.net/wfs/2.0": {
    "Insert": makeChildAppender(writeFeature),
    "Update": makeChildAppender(writeUpdate),
    "Delete": makeChildAppender(writeDelete),
    "Property": makeChildAppender(writeProperty),
    "Native": makeChildAppender(writeNative)
  }
};
var FEATURE_PREFIX = "feature";
var XMLNS = "http://www.w3.org/2000/xmlns/";
var OGCNS = {
  "2.0.0": "http://www.opengis.net/ogc/1.1",
  "1.1.0": "http://www.opengis.net/ogc",
  "1.0.0": "http://www.opengis.net/ogc"
};
var WFSNS = {
  "2.0.0": "http://www.opengis.net/wfs/2.0",
  "1.1.0": "http://www.opengis.net/wfs",
  "1.0.0": "http://www.opengis.net/wfs"
};
var FESNS = {
  "2.0.0": "http://www.opengis.net/fes/2.0",
  "1.1.0": "http://www.opengis.net/fes",
  "1.0.0": "http://www.opengis.net/fes"
};
var SCHEMA_LOCATIONS = {
  "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd",
  "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
  "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"
};
var GML_FORMATS = {
  "2.0.0": GML32_default,
  "1.1.0": GML3_default,
  "1.0.0": GML2_default
};
var DEFAULT_VERSION = "1.1.0";
var WFS = class extends XMLFeature_default {
  constructor(options) {
    super();
    options = options ? options : {};
    this.version_ = options.version ? options.version : DEFAULT_VERSION;
    this.featureType_ = options.featureType;
    this.featureNS_ = options.featureNS;
    this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML_FORMATS[this.version_]();
    this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : SCHEMA_LOCATIONS[this.version_];
  }
  getFeatureType() {
    return this.featureType_;
  }
  setFeatureType(featureType) {
    this.featureType_ = featureType;
  }
  readFeaturesFromNode(node, options) {
    const context = {
      node
    };
    Object.assign(context, {
      "featureType": this.featureType_,
      "featureNS": this.featureNS_
    });
    Object.assign(context, this.getReadOptions(node, options ? options : {}));
    const objectStack = [context];
    let featuresNS;
    if (this.version_ === "2.0.0") {
      featuresNS = FEATURE_COLLECTION_PARSERS;
    } else {
      featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
    }
    let features = pushParseAndPop(
      [],
      featuresNS,
      node,
      objectStack,
      this.gmlFormat_
    );
    if (!features) {
      features = [];
    }
    return features;
  }
  readTransactionResponse(source) {
    if (!source) {
      return void 0;
    } else if (typeof source === "string") {
      const doc = parse(source);
      return this.readTransactionResponseFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readTransactionResponseFromDocument(
        source
      );
    }
    return this.readTransactionResponseFromNode(
      source
    );
  }
  readFeatureCollectionMetadata(source) {
    if (!source) {
      return void 0;
    } else if (typeof source === "string") {
      const doc = parse(source);
      return this.readFeatureCollectionMetadataFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readFeatureCollectionMetadataFromDocument(
        source
      );
    }
    return this.readFeatureCollectionMetadataFromNode(
      source
    );
  }
  readFeatureCollectionMetadataFromDocument(doc) {
    for (let n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readFeatureCollectionMetadataFromNode(
          n
        );
      }
    }
    return void 0;
  }
  readFeatureCollectionMetadataFromNode(node) {
    const result = {};
    const value = readNonNegativeIntegerString(
      node.getAttribute("numberOfFeatures")
    );
    result["numberOfFeatures"] = value;
    return pushParseAndPop(
      result,
      FEATURE_COLLECTION_PARSERS,
      node,
      [],
      this.gmlFormat_
    );
  }
  readTransactionResponseFromDocument(doc) {
    for (let n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readTransactionResponseFromNode(n);
      }
    }
    return void 0;
  }
  readTransactionResponseFromNode(node) {
    return pushParseAndPop(
      {},
      TRANSACTION_RESPONSE_PARSERS,
      node,
      []
    );
  }
  writeGetFeature(options) {
    const node = createElementNS(WFSNS[this.version_], "GetFeature");
    node.setAttribute("service", "WFS");
    node.setAttribute("version", this.version_);
    if (options.handle) {
      node.setAttribute("handle", options.handle);
    }
    if (options.outputFormat) {
      node.setAttribute("outputFormat", options.outputFormat);
    }
    if (options.maxFeatures !== void 0) {
      node.setAttribute("maxFeatures", String(options.maxFeatures));
    }
    if (options.resultType) {
      node.setAttribute("resultType", options.resultType);
    }
    if (options.startIndex !== void 0) {
      node.setAttribute("startIndex", String(options.startIndex));
    }
    if (options.count !== void 0) {
      node.setAttribute("count", String(options.count));
    }
    if (options.viewParams !== void 0) {
      node.setAttribute("viewParams", options.viewParams);
    }
    node.setAttributeNS(
      XML_SCHEMA_INSTANCE_URI,
      "xsi:schemaLocation",
      this.schemaLocation_
    );
    const context = {
      node
    };
    Object.assign(context, {
      "version": this.version_,
      "srsName": options.srsName,
      "featureNS": options.featureNS ? options.featureNS : this.featureNS_,
      "featurePrefix": options.featurePrefix,
      "propertyNames": options.propertyNames ? options.propertyNames : []
    });
    assert(Array.isArray(options.featureTypes), 11);
    if (typeof options.featureTypes[0] === "string") {
      let filter = options.filter;
      if (options.bbox) {
        assert(options.geometryName, 12);
        filter = this.combineBboxAndFilter(
          options.geometryName,
          options.bbox,
          options.srsName,
          filter
        );
      }
      Object.assign(context, {
        "geometryName": options.geometryName,
        "filter": filter
      });
      writeGetFeature(
        node,
        options.featureTypes,
        [context]
      );
    } else {
      options.featureTypes.forEach((featureType) => {
        const completeFilter = this.combineBboxAndFilter(
          featureType.geometryName,
          featureType.bbox,
          options.srsName,
          options.filter
        );
        Object.assign(context, {
          "geometryName": featureType.geometryName,
          "filter": completeFilter
        });
        writeGetFeature(node, [featureType.name], [context]);
      });
    }
    return node;
  }
  combineBboxAndFilter(geometryName, extent, srsName, filter) {
    const bboxFilter = bbox(geometryName, extent, srsName);
    if (filter) {
      return and(filter, bboxFilter);
    }
    return bboxFilter;
  }
  writeTransaction(inserts, updates, deletes, options) {
    const objectStack = [];
    const version = options.version ? options.version : this.version_;
    const node = createElementNS(WFSNS[version], "Transaction");
    node.setAttribute("service", "WFS");
    node.setAttribute("version", version);
    let baseObj;
    if (options) {
      baseObj = options.gmlOptions ? options.gmlOptions : {};
      if (options.handle) {
        node.setAttribute("handle", options.handle);
      }
    }
    node.setAttributeNS(
      XML_SCHEMA_INSTANCE_URI,
      "xsi:schemaLocation",
      SCHEMA_LOCATIONS[version]
    );
    const request = createTransactionRequest(node, baseObj, version, options);
    if (inserts) {
      serializeTransactionRequest("Insert", inserts, objectStack, request);
    }
    if (updates) {
      serializeTransactionRequest("Update", updates, objectStack, request);
    }
    if (deletes) {
      serializeTransactionRequest("Delete", deletes, objectStack, request);
    }
    if (options.nativeElements) {
      serializeTransactionRequest(
        "Native",
        options.nativeElements,
        objectStack,
        request
      );
    }
    return node;
  }
  readProjectionFromDocument(doc) {
    for (let n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readProjectionFromNode(n);
      }
    }
    return null;
  }
  readProjectionFromNode(node) {
    if (node.firstElementChild && node.firstElementChild.firstElementChild) {
      node = node.firstElementChild.firstElementChild;
      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {
        if (!(n.childNodes.length === 0 || n.childNodes.length === 1 && n.firstChild.nodeType === 3)) {
          const objectStack = [{}];
          this.gmlFormat_.readGeometryElement(n, objectStack);
          return get(objectStack.pop().srsName);
        }
      }
    }
    return null;
  }
};
function createTransactionRequest(node, baseObj, version, options) {
  const featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;
  let gmlVersion;
  if (version === "1.0.0") {
    gmlVersion = 2;
  } else if (version === "1.1.0") {
    gmlVersion = 3;
  } else if (version === "2.0.0") {
    gmlVersion = 3.2;
  }
  const obj = Object.assign(
    { node },
    {
      version,
      "featureNS": options.featureNS,
      "featureType": options.featureType,
      "featurePrefix": featurePrefix,
      "gmlVersion": gmlVersion,
      "hasZ": options.hasZ,
      "srsName": options.srsName
    },
    baseObj
  );
  return obj;
}
function serializeTransactionRequest(type, features, objectStack, request) {
  pushSerializeAndPop(
    request,
    TRANSACTION_SERIALIZERS,
    makeSimpleNodeFactory(type),
    features,
    objectStack
  );
}
function readTransactionSummary(node, objectStack) {
  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);
}
var OGC_FID_PARSERS = {
  "http://www.opengis.net/ogc": {
    "FeatureId": makeArrayPusher(function(node, objectStack) {
      return node.getAttribute("fid");
    })
  },
  "http://www.opengis.net/ogc/1.1": {
    "FeatureId": makeArrayPusher(function(node, objectStack) {
      return node.getAttribute("fid");
    })
  }
};
function fidParser(node, objectStack) {
  parseNode(OGC_FID_PARSERS, node, objectStack);
}
var INSERT_RESULTS_PARSERS = {
  "http://www.opengis.net/wfs": {
    "Feature": fidParser
  },
  "http://www.opengis.net/wfs/2.0": {
    "Feature": fidParser
  }
};
function readInsertResults(node, objectStack) {
  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node, objectStack);
}
function writeFeature(node, feature, objectStack) {
  const context = objectStack[objectStack.length - 1];
  const featureType = context["featureType"];
  const featureNS = context["featureNS"];
  const gmlVersion = context["gmlVersion"];
  const child = createElementNS(featureNS, featureType);
  node.appendChild(child);
  if (gmlVersion === 2) {
    GML2_default.prototype.writeFeatureElement(child, feature, objectStack);
  } else if (gmlVersion === 3) {
    GML3_default.prototype.writeFeatureElement(child, feature, objectStack);
  } else {
    GML32_default.prototype.writeFeatureElement(child, feature, objectStack);
  }
}
function writeOgcFidFilter(node, fid, objectStack) {
  const context = objectStack[objectStack.length - 1];
  const version = context["version"];
  const ns = OGCNS[version];
  const filter = createElementNS(ns, "Filter");
  const child = createElementNS(ns, "FeatureId");
  filter.appendChild(child);
  child.setAttribute("fid", fid);
  node.appendChild(filter);
}
function getTypeName(featurePrefix, featureType) {
  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;
  const prefix = featurePrefix + ":";
  if (featureType.startsWith(prefix)) {
    return featureType;
  }
  return prefix + featureType;
}
function writeDelete(node, feature, objectStack) {
  const context = objectStack[objectStack.length - 1];
  assert(feature.getId() !== void 0, 26);
  const featureType = context["featureType"];
  const featurePrefix = context["featurePrefix"];
  const featureNS = context["featureNS"];
  const typeName = getTypeName(featurePrefix, featureType);
  node.setAttribute("typeName", typeName);
  node.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
  const fid = feature.getId();
  if (fid !== void 0) {
    writeOgcFidFilter(node, fid, objectStack);
  }
}
function writeUpdate(node, feature, objectStack) {
  const context = objectStack[objectStack.length - 1];
  assert(feature.getId() !== void 0, 27);
  const version = context["version"];
  const featureType = context["featureType"];
  const featurePrefix = context["featurePrefix"];
  const featureNS = context["featureNS"];
  const typeName = getTypeName(featurePrefix, featureType);
  const geometryName = feature.getGeometryName();
  node.setAttribute("typeName", typeName);
  node.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
  const fid = feature.getId();
  if (fid !== void 0) {
    const keys = feature.getKeys();
    const values = [];
    for (let i = 0, ii = keys.length; i < ii; i++) {
      const value = feature.get(keys[i]);
      if (value !== void 0) {
        let name = keys[i];
        if (value && typeof value.getSimplifiedGeometry === "function") {
          name = geometryName;
        }
        values.push({ name, value });
      }
    }
    pushSerializeAndPop(
      {
        version,
        "gmlVersion": context["gmlVersion"],
        node,
        "hasZ": context["hasZ"],
        "srsName": context["srsName"]
      },
      TRANSACTION_SERIALIZERS,
      makeSimpleNodeFactory("Property"),
      values,
      objectStack
    );
    writeOgcFidFilter(node, fid, objectStack);
  }
}
function writeProperty(node, pair, objectStack) {
  const context = objectStack[objectStack.length - 1];
  const version = context["version"];
  const ns = WFSNS[version];
  const name = createElementNS(ns, "Name");
  const gmlVersion = context["gmlVersion"];
  node.appendChild(name);
  writeStringTextNode(name, pair.name);
  if (pair.value !== void 0 && pair.value !== null) {
    const value = createElementNS(ns, "Value");
    node.appendChild(value);
    if (pair.value && typeof pair.value.getSimplifiedGeometry === "function") {
      if (gmlVersion === 2) {
        GML2_default.prototype.writeGeometryElement(value, pair.value, objectStack);
      } else if (gmlVersion === 3) {
        GML3_default.prototype.writeGeometryElement(value, pair.value, objectStack);
      } else {
        GML32_default.prototype.writeGeometryElement(value, pair.value, objectStack);
      }
    } else {
      writeStringTextNode(value, pair.value);
    }
  }
}
function writeNative(node, nativeElement, objectStack) {
  if (nativeElement.vendorId) {
    node.setAttribute("vendorId", nativeElement.vendorId);
  }
  if (nativeElement.safeToIgnore !== void 0) {
    node.setAttribute("safeToIgnore", String(nativeElement.safeToIgnore));
  }
  if (nativeElement.value !== void 0) {
    writeStringTextNode(node, nativeElement.value);
  }
}
var GETFEATURE_SERIALIZERS = {
  "http://www.opengis.net/wfs": {
    "Query": makeChildAppender(writeQuery)
  },
  "http://www.opengis.net/wfs/2.0": {
    "Query": makeChildAppender(writeQuery)
  },
  "http://www.opengis.net/ogc": {
    "During": makeChildAppender(writeDuringFilter),
    "And": makeChildAppender(writeLogicalFilter),
    "Or": makeChildAppender(writeLogicalFilter),
    "Not": makeChildAppender(writeNotFilter),
    "BBOX": makeChildAppender(writeBboxFilter),
    "Contains": makeChildAppender(writeSpatialFilter),
    "Intersects": makeChildAppender(writeSpatialFilter),
    "Within": makeChildAppender(writeSpatialFilter),
    "DWithin": makeChildAppender(writeDWithinFilter),
    "PropertyIsEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNotEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNull": makeChildAppender(writeIsNullFilter),
    "PropertyIsBetween": makeChildAppender(writeIsBetweenFilter),
    "PropertyIsLike": makeChildAppender(writeIsLikeFilter)
  },
  "http://www.opengis.net/fes/2.0": {
    "During": makeChildAppender(writeDuringFilter),
    "And": makeChildAppender(writeLogicalFilter),
    "Or": makeChildAppender(writeLogicalFilter),
    "Not": makeChildAppender(writeNotFilter),
    "BBOX": makeChildAppender(writeBboxFilter),
    "Contains": makeChildAppender(writeSpatialFilter),
    "Disjoint": makeChildAppender(writeSpatialFilter),
    "Intersects": makeChildAppender(writeSpatialFilter),
    "ResourceId": makeChildAppender(writeResourceIdFilter),
    "Within": makeChildAppender(writeSpatialFilter),
    "DWithin": makeChildAppender(writeDWithinFilter),
    "PropertyIsEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNotEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNull": makeChildAppender(writeIsNullFilter),
    "PropertyIsBetween": makeChildAppender(writeIsBetweenFilter),
    "PropertyIsLike": makeChildAppender(writeIsLikeFilter)
  }
};
function writeQuery(node, featureType, objectStack) {
  const context = objectStack[objectStack.length - 1];
  const version = context["version"];
  const featurePrefix = context["featurePrefix"];
  const featureNS = context["featureNS"];
  const propertyNames = context["propertyNames"];
  const srsName = context["srsName"];
  let typeName;
  if (featurePrefix) {
    typeName = getTypeName(featurePrefix, featureType);
  } else {
    typeName = featureType;
  }
  let typeNameAttr;
  if (version === "2.0.0") {
    typeNameAttr = "typeNames";
  } else {
    typeNameAttr = "typeName";
  }
  node.setAttribute(typeNameAttr, typeName);
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  if (featureNS) {
    node.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
  }
  const item = Object.assign({}, context);
  item.node = node;
  pushSerializeAndPop(
    item,
    QUERY_SERIALIZERS,
    makeSimpleNodeFactory("PropertyName"),
    propertyNames,
    objectStack
  );
  const filter = context["filter"];
  if (filter) {
    const child = createElementNS(getFilterNS(version), "Filter");
    node.appendChild(child);
    writeFilterCondition(child, filter, objectStack);
  }
}
function writeFilterCondition(node, filter, objectStack) {
  const context = objectStack[objectStack.length - 1];
  const item = { node };
  Object.assign(item, { context });
  pushSerializeAndPop(
    item,
    GETFEATURE_SERIALIZERS,
    makeSimpleNodeFactory(filter.getTagName()),
    [filter],
    objectStack
  );
}
function writeBboxFilter(node, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context = parent["context"];
  const version = context["version"];
  parent["srsName"] = filter.srsName;
  const format = GML_FORMATS[version];
  writePropertyName(version, node, filter.geometryName);
  format.prototype.writeGeometryElement(node, filter.extent, objectStack);
}
function writeResourceIdFilter(node, filter, objectStack) {
  node.setAttribute("rid", filter.rid);
}
function writeSpatialFilter(node, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context = parent["context"];
  const version = context["version"];
  parent["srsName"] = filter.srsName;
  const format = GML_FORMATS[version];
  writePropertyName(version, node, filter.geometryName);
  format.prototype.writeGeometryElement(node, filter.geometry, objectStack);
}
function writeDWithinFilter(node, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context = parent["context"];
  const version = context["version"];
  writeSpatialFilter(node, filter, objectStack);
  const distance = createElementNS(getFilterNS(version), "Distance");
  writeStringTextNode(distance, filter.distance.toString());
  if (version === "2.0.0") {
    distance.setAttribute("uom", filter.unit);
  } else {
    distance.setAttribute("units", filter.unit);
  }
  node.appendChild(distance);
}
function writeDuringFilter(node, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context = parent["context"];
  const version = context["version"];
  writeExpression(FESNS[version], "ValueReference", node, filter.propertyName);
  const timePeriod = createElementNS(GMLNS, "TimePeriod");
  node.appendChild(timePeriod);
  const begin = createElementNS(GMLNS, "begin");
  timePeriod.appendChild(begin);
  writeTimeInstant(begin, filter.begin);
  const end = createElementNS(GMLNS, "end");
  timePeriod.appendChild(end);
  writeTimeInstant(end, filter.end);
}
function writeLogicalFilter(node, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context = parent["context"];
  const item = { node };
  Object.assign(item, { context });
  const conditions = filter.conditions;
  for (let i = 0, ii = conditions.length; i < ii; ++i) {
    const condition = conditions[i];
    pushSerializeAndPop(
      item,
      GETFEATURE_SERIALIZERS,
      makeSimpleNodeFactory(condition.getTagName()),
      [condition],
      objectStack
    );
  }
}
function writeNotFilter(node, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context = parent["context"];
  const item = { node };
  Object.assign(item, { context });
  const condition = filter.condition;
  pushSerializeAndPop(
    item,
    GETFEATURE_SERIALIZERS,
    makeSimpleNodeFactory(condition.getTagName()),
    [condition],
    objectStack
  );
}
function writeComparisonFilter(node, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context = parent["context"];
  const version = context["version"];
  if (filter.matchCase !== void 0) {
    node.setAttribute("matchCase", filter.matchCase.toString());
  }
  writePropertyName(version, node, filter.propertyName);
  writeLiteral(version, node, "" + filter.expression);
}
function writeIsNullFilter(node, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context = parent["context"];
  const version = context["version"];
  writePropertyName(version, node, filter.propertyName);
}
function writeIsBetweenFilter(node, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context = parent["context"];
  const version = context["version"];
  const ns = getFilterNS(version);
  writePropertyName(version, node, filter.propertyName);
  const lowerBoundary = createElementNS(ns, "LowerBoundary");
  node.appendChild(lowerBoundary);
  writeLiteral(version, lowerBoundary, "" + filter.lowerBoundary);
  const upperBoundary = createElementNS(ns, "UpperBoundary");
  node.appendChild(upperBoundary);
  writeLiteral(version, upperBoundary, "" + filter.upperBoundary);
}
function writeIsLikeFilter(node, filter, objectStack) {
  const parent = objectStack[objectStack.length - 1];
  const context = parent["context"];
  const version = context["version"];
  node.setAttribute("wildCard", filter.wildCard);
  node.setAttribute("singleChar", filter.singleChar);
  node.setAttribute("escapeChar", filter.escapeChar);
  if (filter.matchCase !== void 0) {
    node.setAttribute("matchCase", filter.matchCase.toString());
  }
  writePropertyName(version, node, filter.propertyName);
  writeLiteral(version, node, "" + filter.pattern);
}
function writeExpression(ns, tagName, node, value) {
  const property = createElementNS(ns, tagName);
  writeStringTextNode(property, value);
  node.appendChild(property);
}
function writeLiteral(version, node, value) {
  writeExpression(getFilterNS(version), "Literal", node, value);
}
function writePropertyName(version, node, value) {
  if (version === "2.0.0") {
    writeExpression(FESNS[version], "ValueReference", node, value);
  } else {
    writeExpression(OGCNS[version], "PropertyName", node, value);
  }
}
function writeTimeInstant(node, time) {
  const timeInstant = createElementNS(GMLNS, "TimeInstant");
  node.appendChild(timeInstant);
  const timePosition = createElementNS(GMLNS, "timePosition");
  timeInstant.appendChild(timePosition);
  writeStringTextNode(timePosition, time);
}
function writeGetFeature(node, featureTypes, objectStack) {
  const context = objectStack[objectStack.length - 1];
  const item = Object.assign({}, context);
  item.node = node;
  pushSerializeAndPop(
    item,
    GETFEATURE_SERIALIZERS,
    makeSimpleNodeFactory("Query"),
    featureTypes,
    objectStack
  );
}
function getFilterNS(version) {
  let ns;
  if (version === "2.0.0") {
    ns = FESNS[version];
  } else {
    ns = OGCNS[version];
  }
  return ns;
}
var WFS_default = WFS;

// node_modules/ol/format/WKB.js
var WKBGeometryType = {
  POINT: 1,
  LINE_STRING: 2,
  POLYGON: 3,
  MULTI_POINT: 4,
  MULTI_LINE_STRING: 5,
  MULTI_POLYGON: 6,
  GEOMETRY_COLLECTION: 7,
  POLYHEDRAL_SURFACE: 15,
  TIN: 16,
  TRIANGLE: 17
};
var WkbReader = class {
  constructor(view) {
    this.view_ = view;
    this.pos_ = 0;
    this.initialized_ = false;
    this.isLittleEndian_ = false;
    this.hasZ_ = false;
    this.hasM_ = false;
    this.srid_ = null;
    this.layout_ = "XY";
  }
  readUint8() {
    return this.view_.getUint8(this.pos_++);
  }
  readUint32(isLittleEndian) {
    return this.view_.getUint32(
      (this.pos_ += 4) - 4,
      isLittleEndian !== void 0 ? isLittleEndian : this.isLittleEndian_
    );
  }
  readDouble(isLittleEndian) {
    return this.view_.getFloat64(
      (this.pos_ += 8) - 8,
      isLittleEndian !== void 0 ? isLittleEndian : this.isLittleEndian_
    );
  }
  readPoint() {
    const coords = [];
    coords.push(this.readDouble());
    coords.push(this.readDouble());
    if (this.hasZ_) {
      coords.push(this.readDouble());
    }
    if (this.hasM_) {
      coords.push(this.readDouble());
    }
    return coords;
  }
  readLineString() {
    const numPoints = this.readUint32();
    const coords = [];
    for (let i = 0; i < numPoints; i++) {
      coords.push(this.readPoint());
    }
    return coords;
  }
  readPolygon() {
    const numRings = this.readUint32();
    const rings = [];
    for (let i = 0; i < numRings; i++) {
      rings.push(this.readLineString());
    }
    return rings;
  }
  readWkbHeader(expectedTypeId) {
    const byteOrder = this.readUint8();
    const isLittleEndian = byteOrder > 0;
    const wkbType = this.readUint32(isLittleEndian);
    const wkbTypeThousandth = Math.floor((wkbType & 268435455) / 1e3);
    const hasZ = Boolean(wkbType & 2147483648) || wkbTypeThousandth === 1 || wkbTypeThousandth === 3;
    const hasM = Boolean(wkbType & 1073741824) || wkbTypeThousandth === 2 || wkbTypeThousandth === 3;
    const hasSRID = Boolean(wkbType & 536870912);
    const typeId = (wkbType & 268435455) % 1e3;
    const layout = ["XY", hasZ ? "Z" : "", hasM ? "M" : ""].join("");
    const srid = hasSRID ? this.readUint32(isLittleEndian) : null;
    if (expectedTypeId !== void 0 && expectedTypeId !== typeId) {
      throw new Error("Unexpected WKB geometry type " + typeId);
    }
    if (this.initialized_) {
      if (this.isLittleEndian_ !== isLittleEndian) {
        throw new Error("Inconsistent endian");
      }
      if (this.layout_ !== layout) {
        throw new Error("Inconsistent geometry layout");
      }
      if (srid && this.srid_ !== srid) {
        throw new Error("Inconsistent coordinate system (SRID)");
      }
    } else {
      this.isLittleEndian_ = isLittleEndian;
      this.hasZ_ = hasZ;
      this.hasM_ = hasM;
      this.layout_ = layout;
      this.srid_ = srid;
      this.initialized_ = true;
    }
    return typeId;
  }
  readWkbPayload(typeId) {
    switch (typeId) {
      case WKBGeometryType.POINT:
        return this.readPoint();
      case WKBGeometryType.LINE_STRING:
        return this.readLineString();
      case WKBGeometryType.POLYGON:
      case WKBGeometryType.TRIANGLE:
        return this.readPolygon();
      case WKBGeometryType.MULTI_POINT:
        return this.readMultiPoint();
      case WKBGeometryType.MULTI_LINE_STRING:
        return this.readMultiLineString();
      case WKBGeometryType.MULTI_POLYGON:
      case WKBGeometryType.POLYHEDRAL_SURFACE:
      case WKBGeometryType.TIN:
        return this.readMultiPolygon();
      case WKBGeometryType.GEOMETRY_COLLECTION:
        return this.readGeometryCollection();
      default:
        throw new Error(
          "Unsupported WKB geometry type " + typeId + " is found"
        );
    }
  }
  readWkbBlock(expectedTypeId) {
    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));
  }
  readWkbCollection(reader, expectedTypeId) {
    const num = this.readUint32();
    const items = [];
    for (let i = 0; i < num; i++) {
      const result = reader.call(this, expectedTypeId);
      if (result) {
        items.push(result);
      }
    }
    return items;
  }
  readMultiPoint() {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);
  }
  readMultiLineString() {
    return this.readWkbCollection(
      this.readWkbBlock,
      WKBGeometryType.LINE_STRING
    );
  }
  readMultiPolygon() {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);
  }
  readGeometryCollection() {
    return this.readWkbCollection(this.readGeometry);
  }
  readGeometry() {
    const typeId = this.readWkbHeader();
    const result = this.readWkbPayload(typeId);
    switch (typeId) {
      case WKBGeometryType.POINT:
        return new Point_default(
          result,
          this.layout_
        );
      case WKBGeometryType.LINE_STRING:
        return new LineString_default(
          result,
          this.layout_
        );
      case WKBGeometryType.POLYGON:
      case WKBGeometryType.TRIANGLE:
        return new Polygon_default(
          result,
          this.layout_
        );
      case WKBGeometryType.MULTI_POINT:
        return new MultiPoint_default(
          result,
          this.layout_
        );
      case WKBGeometryType.MULTI_LINE_STRING:
        return new MultiLineString_default(
          result,
          this.layout_
        );
      case WKBGeometryType.MULTI_POLYGON:
      case WKBGeometryType.POLYHEDRAL_SURFACE:
      case WKBGeometryType.TIN:
        return new MultiPolygon_default(
          result,
          this.layout_
        );
      case WKBGeometryType.GEOMETRY_COLLECTION:
        return new GeometryCollection_default(
          result
        );
      default:
        return null;
    }
  }
  getSrid() {
    return this.srid_;
  }
};
var WkbWriter = class {
  constructor(opts) {
    opts = opts || {};
    this.layout_ = opts.layout;
    this.isLittleEndian_ = opts.littleEndian !== false;
    this.isEWKB_ = opts.ewkb !== false;
    this.writeQueue_ = [];
    this.nodata_ = Object.assign({ X: 0, Y: 0, Z: 0, M: 0 }, opts.nodata);
  }
  writeUint8(value) {
    this.writeQueue_.push([1, value]);
  }
  writeUint32(value) {
    this.writeQueue_.push([4, value]);
  }
  writeDouble(value) {
    this.writeQueue_.push([8, value]);
  }
  writePoint(coords, layout) {
    const coordsObj = Object.assign.apply(
      null,
      layout.split("").map((axis, idx) => ({ [axis]: coords[idx] }))
    );
    for (const axis of this.layout_) {
      this.writeDouble(
        axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]
      );
    }
  }
  writeLineString(coords, layout) {
    this.writeUint32(coords.length);
    for (let i = 0; i < coords.length; i++) {
      this.writePoint(coords[i], layout);
    }
  }
  writePolygon(rings, layout) {
    this.writeUint32(rings.length);
    for (let i = 0; i < rings.length; i++) {
      this.writeLineString(rings[i], layout);
    }
  }
  writeWkbHeader(wkbType, srid) {
    wkbType %= 1e3;
    if (this.layout_.includes("Z")) {
      wkbType += this.isEWKB_ ? 2147483648 : 1e3;
    }
    if (this.layout_.includes("M")) {
      wkbType += this.isEWKB_ ? 1073741824 : 2e3;
    }
    if (this.isEWKB_ && Number.isInteger(srid)) {
      wkbType |= 536870912;
    }
    this.writeUint8(this.isLittleEndian_ ? 1 : 0);
    this.writeUint32(wkbType);
    if (this.isEWKB_ && Number.isInteger(srid)) {
      this.writeUint32(srid);
    }
  }
  writeMultiPoint(coords, layout) {
    this.writeUint32(coords.length);
    for (let i = 0; i < coords.length; i++) {
      this.writeWkbHeader(1);
      this.writePoint(coords[i], layout);
    }
  }
  writeMultiLineString(coords, layout) {
    this.writeUint32(coords.length);
    for (let i = 0; i < coords.length; i++) {
      this.writeWkbHeader(2);
      this.writeLineString(coords[i], layout);
    }
  }
  writeMultiPolygon(coords, layout) {
    this.writeUint32(coords.length);
    for (let i = 0; i < coords.length; i++) {
      this.writeWkbHeader(3);
      this.writePolygon(coords[i], layout);
    }
  }
  writeGeometryCollection(geometries) {
    this.writeUint32(geometries.length);
    for (let i = 0; i < geometries.length; i++) {
      this.writeGeometry(geometries[i]);
    }
  }
  findMinimumLayout(geom, layout = "XYZM") {
    const GeometryLayout_min = (a, b) => {
      if (a === b) {
        return a;
      }
      if (a === "XYZM") {
        return b;
      }
      if (b === "XYZM") {
        return a;
      }
      return "XY";
    };
    if (geom instanceof SimpleGeometry_default) {
      return GeometryLayout_min(geom.getLayout(), layout);
    }
    if (geom instanceof GeometryCollection_default) {
      const geoms = geom.getGeometriesArray();
      for (let i = 0; i < geoms.length && layout !== "XY"; i++) {
        layout = this.findMinimumLayout(geoms[i], layout);
      }
    }
    return layout;
  }
  writeGeometry(geom, srid) {
    const wkblut = {
      Point: WKBGeometryType.POINT,
      LineString: WKBGeometryType.LINE_STRING,
      Polygon: WKBGeometryType.POLYGON,
      MultiPoint: WKBGeometryType.MULTI_POINT,
      MultiLineString: WKBGeometryType.MULTI_LINE_STRING,
      MultiPolygon: WKBGeometryType.MULTI_POLYGON,
      GeometryCollection: WKBGeometryType.GEOMETRY_COLLECTION
    };
    const geomType = geom.getType();
    const typeId = wkblut[geomType];
    if (!typeId) {
      throw new Error("GeometryType " + geomType + " is not supported");
    }
    if (!this.layout_) {
      this.layout_ = this.findMinimumLayout(geom);
    }
    this.writeWkbHeader(typeId, srid);
    if (geom instanceof SimpleGeometry_default) {
      const writerLUT = {
        Point: this.writePoint,
        LineString: this.writeLineString,
        Polygon: this.writePolygon,
        MultiPoint: this.writeMultiPoint,
        MultiLineString: this.writeMultiLineString,
        MultiPolygon: this.writeMultiPolygon
      };
      writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());
    } else if (geom instanceof GeometryCollection_default) {
      this.writeGeometryCollection(geom.getGeometriesArray());
    }
  }
  getBuffer() {
    const byteLength = this.writeQueue_.reduce((acc, item) => acc + item[0], 0);
    const buffer = new ArrayBuffer(byteLength);
    const view = new DataView(buffer);
    let pos = 0;
    this.writeQueue_.forEach((item) => {
      switch (item[0]) {
        case 1:
          view.setUint8(pos, item[1]);
          break;
        case 4:
          view.setUint32(pos, item[1], this.isLittleEndian_);
          break;
        case 8:
          view.setFloat64(pos, item[1], this.isLittleEndian_);
          break;
        default:
          break;
      }
      pos += item[0];
    });
    return buffer;
  }
};
var WKB = class extends Feature_default2 {
  constructor(options) {
    super();
    options = options ? options : {};
    this.splitCollection = Boolean(options.splitCollection);
    this.viewCache_ = null;
    this.hex_ = options.hex !== false;
    this.littleEndian_ = options.littleEndian !== false;
    this.ewkb_ = options.ewkb !== false;
    this.layout_ = options.geometryLayout;
    this.nodataZ_ = options.nodataZ || 0;
    this.nodataM_ = options.nodataM || 0;
    this.srid_ = options.srid;
  }
  getType() {
    return this.hex_ ? "text" : "arraybuffer";
  }
  readFeature(source, options) {
    return new Feature_default({
      geometry: this.readGeometry(source, options)
    });
  }
  readFeatures(source, options) {
    let geometries = [];
    const geometry = this.readGeometry(source, options);
    if (this.splitCollection && geometry instanceof GeometryCollection_default) {
      geometries = geometry.getGeometriesArray();
    } else {
      geometries = [geometry];
    }
    return geometries.map((geometry2) => new Feature_default({ geometry: geometry2 }));
  }
  readGeometry(source, options) {
    const view = getDataView(source);
    if (!view) {
      return null;
    }
    const reader = new WkbReader(view);
    const geometry = reader.readGeometry();
    this.viewCache_ = view;
    options = this.getReadOptions(source, options);
    this.viewCache_ = null;
    return transformGeometryWithOptions(geometry, false, options);
  }
  readProjection(source) {
    const view = this.viewCache_ || getDataView(source);
    if (!view) {
      return void 0;
    }
    const reader = new WkbReader(view);
    reader.readWkbHeader();
    return reader.getSrid() && get("EPSG:" + reader.getSrid()) || void 0;
  }
  writeFeature(feature, options) {
    return this.writeGeometry(feature.getGeometry(), options);
  }
  writeFeatures(features, options) {
    return this.writeGeometry(
      new GeometryCollection_default(features.map((f) => f.getGeometry())),
      options
    );
  }
  writeGeometry(geometry, options) {
    options = this.adaptOptions(options);
    const writer = new WkbWriter({
      layout: this.layout_,
      littleEndian: this.littleEndian_,
      ewkb: this.ewkb_,
      nodata: {
        Z: this.nodataZ_,
        M: this.nodataM_
      }
    });
    let srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;
    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {
      const dataProjection = options.dataProjection && get(options.dataProjection);
      if (dataProjection) {
        const code = dataProjection.getCode();
        if (code.startsWith("EPSG:")) {
          srid = Number(code.substring(5));
        }
      }
    }
    writer.writeGeometry(
      transformGeometryWithOptions(geometry, true, options),
      srid
    );
    const buffer = writer.getBuffer();
    return this.hex_ ? encodeHexString(buffer) : buffer;
  }
};
function encodeHexString(buffer) {
  const view = new Uint8Array(buffer);
  return Array.from(view.values()).map((x) => (x < 16 ? "0" : "") + Number(x).toString(16).toUpperCase()).join("");
}
function decodeHexString(text) {
  const buffer = new Uint8Array(text.length / 2);
  for (let i = 0; i < text.length / 2; i++) {
    buffer[i] = parseInt(text.substr(i * 2, 2), 16);
  }
  return new DataView(buffer.buffer);
}
function getDataView(source) {
  if (typeof source === "string") {
    return decodeHexString(source);
  } else if (ArrayBuffer.isView(source)) {
    if (source instanceof DataView) {
      return source;
    }
    return new DataView(source.buffer, source.byteOffset, source.byteLength);
  } else if (source instanceof ArrayBuffer) {
    return new DataView(source);
  }
  return null;
}
var WKB_default = WKB;

// node_modules/ol/format/WKT.js
var GeometryConstructor = {
  "POINT": Point_default,
  "LINESTRING": LineString_default,
  "POLYGON": Polygon_default,
  "MULTIPOINT": MultiPoint_default,
  "MULTILINESTRING": MultiLineString_default,
  "MULTIPOLYGON": MultiPolygon_default
};
var EMPTY = "EMPTY";
var Z = "Z";
var M = "M";
var ZM = "ZM";
var TokenType = {
  START: 0,
  TEXT: 1,
  LEFT_PAREN: 2,
  RIGHT_PAREN: 3,
  NUMBER: 4,
  COMMA: 5,
  EOF: 6
};
var wktTypeLookup = {
  Point: "POINT",
  LineString: "LINESTRING",
  Polygon: "POLYGON",
  MultiPoint: "MULTIPOINT",
  MultiLineString: "MULTILINESTRING",
  MultiPolygon: "MULTIPOLYGON",
  GeometryCollection: "GEOMETRYCOLLECTION",
  Circle: "CIRCLE"
};
var Lexer = class {
  constructor(wkt) {
    this.wkt = wkt;
    this.index_ = -1;
  }
  isAlpha_(c) {
    return c >= "a" && c <= "z" || c >= "A" && c <= "Z";
  }
  isNumeric_(c, decimal) {
    decimal = decimal !== void 0 ? decimal : false;
    return c >= "0" && c <= "9" || c == "." && !decimal;
  }
  isWhiteSpace_(c) {
    return c == " " || c == "	" || c == "\r" || c == "\n";
  }
  nextChar_() {
    return this.wkt.charAt(++this.index_);
  }
  nextToken() {
    const c = this.nextChar_();
    const position = this.index_;
    let value = c;
    let type;
    if (c == "(") {
      type = TokenType.LEFT_PAREN;
    } else if (c == ",") {
      type = TokenType.COMMA;
    } else if (c == ")") {
      type = TokenType.RIGHT_PAREN;
    } else if (this.isNumeric_(c) || c == "-") {
      type = TokenType.NUMBER;
      value = this.readNumber_();
    } else if (this.isAlpha_(c)) {
      type = TokenType.TEXT;
      value = this.readText_();
    } else if (this.isWhiteSpace_(c)) {
      return this.nextToken();
    } else if (c === "") {
      type = TokenType.EOF;
    } else {
      throw new Error("Unexpected character: " + c);
    }
    return { position, value, type };
  }
  readNumber_() {
    let c;
    const index = this.index_;
    let decimal = false;
    let scientificNotation = false;
    do {
      if (c == ".") {
        decimal = true;
      } else if (c == "e" || c == "E") {
        scientificNotation = true;
      }
      c = this.nextChar_();
    } while (this.isNumeric_(c, decimal) || !scientificNotation && (c == "e" || c == "E") || scientificNotation && (c == "-" || c == "+"));
    return parseFloat(this.wkt.substring(index, this.index_--));
  }
  readText_() {
    let c;
    const index = this.index_;
    do {
      c = this.nextChar_();
    } while (this.isAlpha_(c));
    return this.wkt.substring(index, this.index_--).toUpperCase();
  }
};
var Parser = class {
  constructor(lexer) {
    this.lexer_ = lexer;
    this.token_ = {
      position: 0,
      type: TokenType.START
    };
    this.layout_ = "XY";
  }
  consume_() {
    this.token_ = this.lexer_.nextToken();
  }
  isTokenType(type) {
    return this.token_.type == type;
  }
  match(type) {
    const isMatch = this.isTokenType(type);
    if (isMatch) {
      this.consume_();
    }
    return isMatch;
  }
  parse() {
    this.consume_();
    return this.parseGeometry_();
  }
  parseGeometryLayout_() {
    let layout = "XY";
    const dimToken = this.token_;
    if (this.isTokenType(TokenType.TEXT)) {
      const dimInfo = dimToken.value;
      if (dimInfo === Z) {
        layout = "XYZ";
      } else if (dimInfo === M) {
        layout = "XYM";
      } else if (dimInfo === ZM) {
        layout = "XYZM";
      }
      if (layout !== "XY") {
        this.consume_();
      }
    }
    return layout;
  }
  parseGeometryCollectionText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const geometries = [];
      do {
        geometries.push(this.parseGeometry_());
      } while (this.match(TokenType.COMMA));
      if (this.match(TokenType.RIGHT_PAREN)) {
        return geometries;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }
  parsePointText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates2 = this.parsePoint_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }
  parseLineStringText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates2 = this.parsePointList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }
  parsePolygonText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates2 = this.parseLineStringTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }
  parseMultiPointText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      let coordinates2;
      if (this.token_.type == TokenType.LEFT_PAREN) {
        coordinates2 = this.parsePointTextList_();
      } else {
        coordinates2 = this.parsePointList_();
      }
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }
  parseMultiLineStringText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates2 = this.parseLineStringTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }
  parseMultiPolygonText_() {
    if (this.match(TokenType.LEFT_PAREN)) {
      const coordinates2 = this.parsePolygonTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates2;
      }
    }
    throw new Error(this.formatErrorMessage_());
  }
  parsePoint_() {
    const coordinates2 = [];
    const dimensions = this.layout_.length;
    for (let i = 0; i < dimensions; ++i) {
      const token = this.token_;
      if (this.match(TokenType.NUMBER)) {
        coordinates2.push(token.value);
      } else {
        break;
      }
    }
    if (coordinates2.length == dimensions) {
      return coordinates2;
    }
    throw new Error(this.formatErrorMessage_());
  }
  parsePointList_() {
    const coordinates2 = [this.parsePoint_()];
    while (this.match(TokenType.COMMA)) {
      coordinates2.push(this.parsePoint_());
    }
    return coordinates2;
  }
  parsePointTextList_() {
    const coordinates2 = [this.parsePointText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates2.push(this.parsePointText_());
    }
    return coordinates2;
  }
  parseLineStringTextList_() {
    const coordinates2 = [this.parseLineStringText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates2.push(this.parseLineStringText_());
    }
    return coordinates2;
  }
  parsePolygonTextList_() {
    const coordinates2 = [this.parsePolygonText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates2.push(this.parsePolygonText_());
    }
    return coordinates2;
  }
  isEmptyGeometry_() {
    const isEmpty2 = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;
    if (isEmpty2) {
      this.consume_();
    }
    return isEmpty2;
  }
  formatErrorMessage_() {
    return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
  }
  parseGeometry_() {
    const token = this.token_;
    if (this.match(TokenType.TEXT)) {
      const geomType = token.value;
      this.layout_ = this.parseGeometryLayout_();
      const isEmpty2 = this.isEmptyGeometry_();
      if (geomType == "GEOMETRYCOLLECTION") {
        if (isEmpty2) {
          return new GeometryCollection_default([]);
        }
        const geometries = this.parseGeometryCollectionText_();
        return new GeometryCollection_default(geometries);
      }
      const ctor = GeometryConstructor[geomType];
      if (!ctor) {
        throw new Error("Invalid geometry type: " + geomType);
      }
      let coordinates2;
      if (isEmpty2) {
        if (geomType == "POINT") {
          coordinates2 = [NaN, NaN];
        } else {
          coordinates2 = [];
        }
      } else {
        switch (geomType) {
          case "POINT": {
            coordinates2 = this.parsePointText_();
            break;
          }
          case "LINESTRING": {
            coordinates2 = this.parseLineStringText_();
            break;
          }
          case "POLYGON": {
            coordinates2 = this.parsePolygonText_();
            break;
          }
          case "MULTIPOINT": {
            coordinates2 = this.parseMultiPointText_();
            break;
          }
          case "MULTILINESTRING": {
            coordinates2 = this.parseMultiLineStringText_();
            break;
          }
          case "MULTIPOLYGON": {
            coordinates2 = this.parseMultiPolygonText_();
            break;
          }
          default:
            break;
        }
      }
      return new ctor(coordinates2, this.layout_);
    }
    throw new Error(this.formatErrorMessage_());
  }
};
var WKT = class extends TextFeature_default {
  constructor(options) {
    super();
    options = options ? options : {};
    this.splitCollection_ = options.splitCollection !== void 0 ? options.splitCollection : false;
  }
  parse_(wkt) {
    const lexer = new Lexer(wkt);
    const parser = new Parser(lexer);
    return parser.parse();
  }
  readFeatureFromText(text, options) {
    const geom = this.readGeometryFromText(text, options);
    const feature = new Feature_default();
    feature.setGeometry(geom);
    return feature;
  }
  readFeaturesFromText(text, options) {
    let geometries = [];
    const geometry = this.readGeometryFromText(text, options);
    if (this.splitCollection_ && geometry.getType() == "GeometryCollection") {
      geometries = geometry.getGeometriesArray();
    } else {
      geometries = [geometry];
    }
    const features = [];
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      const feature = new Feature_default();
      feature.setGeometry(geometries[i]);
      features.push(feature);
    }
    return features;
  }
  readGeometryFromText(text, options) {
    const geometry = this.parse_(text);
    return transformGeometryWithOptions(geometry, false, options);
  }
  writeFeatureText(feature, options) {
    const geometry = feature.getGeometry();
    if (geometry) {
      return this.writeGeometryText(geometry, options);
    }
    return "";
  }
  writeFeaturesText(features, options) {
    if (features.length == 1) {
      return this.writeFeatureText(features[0], options);
    }
    const geometries = [];
    for (let i = 0, ii = features.length; i < ii; ++i) {
      geometries.push(features[i].getGeometry());
    }
    const collection = new GeometryCollection_default(geometries);
    return this.writeGeometryText(collection, options);
  }
  writeGeometryText(geometry, options) {
    return encode(transformGeometryWithOptions(geometry, true, options));
  }
};
function encodePointGeometry(geom) {
  const coordinates2 = geom.getCoordinates();
  if (coordinates2.length === 0) {
    return "";
  }
  return coordinates2.join(" ");
}
function encodeMultiPointGeometry(geom) {
  const array = [];
  const components = geom.getPoints();
  for (let i = 0, ii = components.length; i < ii; ++i) {
    array.push("(" + encodePointGeometry(components[i]) + ")");
  }
  return array.join(",");
}
function encodeGeometryCollectionGeometry(geom) {
  const array = [];
  const geoms = geom.getGeometries();
  for (let i = 0, ii = geoms.length; i < ii; ++i) {
    array.push(encode(geoms[i]));
  }
  return array.join(",");
}
function encodeLineStringGeometry(geom) {
  const coordinates2 = geom.getCoordinates();
  const array = [];
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    array.push(coordinates2[i].join(" "));
  }
  return array.join(",");
}
function encodeMultiLineStringGeometry(geom) {
  const array = [];
  const components = geom.getLineStrings();
  for (let i = 0, ii = components.length; i < ii; ++i) {
    array.push("(" + encodeLineStringGeometry(components[i]) + ")");
  }
  return array.join(",");
}
function encodePolygonGeometry(geom) {
  const array = [];
  const rings = geom.getLinearRings();
  for (let i = 0, ii = rings.length; i < ii; ++i) {
    array.push("(" + encodeLineStringGeometry(rings[i]) + ")");
  }
  return array.join(",");
}
function encodeMultiPolygonGeometry(geom) {
  const array = [];
  const components = geom.getPolygons();
  for (let i = 0, ii = components.length; i < ii; ++i) {
    array.push("(" + encodePolygonGeometry(components[i]) + ")");
  }
  return array.join(",");
}
function encodeGeometryLayout(geom) {
  const layout = geom.getLayout();
  let dimInfo = "";
  if (layout === "XYZ" || layout === "XYZM") {
    dimInfo += Z;
  }
  if (layout === "XYM" || layout === "XYZM") {
    dimInfo += M;
  }
  return dimInfo;
}
var GeometryEncoder = {
  "Point": encodePointGeometry,
  "LineString": encodeLineStringGeometry,
  "Polygon": encodePolygonGeometry,
  "MultiPoint": encodeMultiPointGeometry,
  "MultiLineString": encodeMultiLineStringGeometry,
  "MultiPolygon": encodeMultiPolygonGeometry,
  "GeometryCollection": encodeGeometryCollectionGeometry
};
function encode(geom) {
  const type = geom.getType();
  const geometryEncoder = GeometryEncoder[type];
  const enc = geometryEncoder(geom);
  let wktType = wktTypeLookup[type];
  if (typeof geom.getFlatCoordinates === "function") {
    const dimInfo = encodeGeometryLayout(
      geom
    );
    if (dimInfo.length > 0) {
      wktType += " " + dimInfo;
    }
  }
  if (enc.length === 0) {
    return wktType + " " + EMPTY;
  }
  return wktType + "(" + enc + ")";
}
var WKT_default = WKT;

// node_modules/ol/format/WMSCapabilities.js
var NAMESPACE_URIS4 = [null, "http://www.opengis.net/wms"];
var PARSERS2 = makeStructureNS(NAMESPACE_URIS4, {
  "Service": makeObjectPropertySetter(readService),
  "Capability": makeObjectPropertySetter(readCapability)
});
var CAPABILITY_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Request": makeObjectPropertySetter(readRequest),
  "Exception": makeObjectPropertySetter(readException),
  "Layer": makeObjectPropertySetter(readCapabilityLayer)
});
var WMSCapabilities = class extends XML_default {
  constructor() {
    super();
    this.version = void 0;
  }
  readFromNode(node) {
    this.version = node.getAttribute("version").trim();
    const wmsCapabilityObject = pushParseAndPop(
      {
        "version": this.version
      },
      PARSERS2,
      node,
      []
    );
    return wmsCapabilityObject ? wmsCapabilityObject : null;
  }
};
var SERVICE_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "KeywordList": makeObjectPropertySetter(readKeywordList),
  "OnlineResource": makeObjectPropertySetter(readHref),
  "ContactInformation": makeObjectPropertySetter(readContactInformation),
  "Fees": makeObjectPropertySetter(readString),
  "AccessConstraints": makeObjectPropertySetter(readString),
  "LayerLimit": makeObjectPropertySetter(readPositiveInteger),
  "MaxWidth": makeObjectPropertySetter(readPositiveInteger),
  "MaxHeight": makeObjectPropertySetter(readPositiveInteger)
});
var CONTACT_INFORMATION_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "ContactPersonPrimary": makeObjectPropertySetter(readContactPersonPrimary),
  "ContactPosition": makeObjectPropertySetter(readString),
  "ContactAddress": makeObjectPropertySetter(readContactAddress),
  "ContactVoiceTelephone": makeObjectPropertySetter(readString),
  "ContactFacsimileTelephone": makeObjectPropertySetter(readString),
  "ContactElectronicMailAddress": makeObjectPropertySetter(readString)
});
var CONTACT_PERSON_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "ContactPerson": makeObjectPropertySetter(readString),
  "ContactOrganization": makeObjectPropertySetter(readString)
});
var CONTACT_ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "AddressType": makeObjectPropertySetter(readString),
  "Address": makeObjectPropertySetter(readString),
  "City": makeObjectPropertySetter(readString),
  "StateOrProvince": makeObjectPropertySetter(readString),
  "PostCode": makeObjectPropertySetter(readString),
  "Country": makeObjectPropertySetter(readString)
});
var EXCEPTION_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Format": makeArrayPusher(readString)
});
var LAYER_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "KeywordList": makeObjectPropertySetter(readKeywordList),
  "CRS": makeObjectPropertyPusher(readString),
  "EX_GeographicBoundingBox": makeObjectPropertySetter(
    readEXGeographicBoundingBox
  ),
  "BoundingBox": makeObjectPropertyPusher(readBoundingBox),
  "Dimension": makeObjectPropertyPusher(readDimension),
  "Attribution": makeObjectPropertySetter(readAttribution),
  "AuthorityURL": makeObjectPropertyPusher(readAuthorityURL),
  "Identifier": makeObjectPropertyPusher(readString),
  "MetadataURL": makeObjectPropertyPusher(readMetadataURL),
  "DataURL": makeObjectPropertyPusher(readFormatOnlineresource),
  "FeatureListURL": makeObjectPropertyPusher(readFormatOnlineresource),
  "Style": makeObjectPropertyPusher(readStyle2),
  "MinScaleDenominator": makeObjectPropertySetter(readDecimal),
  "MaxScaleDenominator": makeObjectPropertySetter(readDecimal),
  "Layer": makeObjectPropertyPusher(readLayer)
});
var ATTRIBUTION_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Title": makeObjectPropertySetter(readString),
  "OnlineResource": makeObjectPropertySetter(readHref),
  "LogoURL": makeObjectPropertySetter(readSizedFormatOnlineresource)
});
var EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "westBoundLongitude": makeObjectPropertySetter(readDecimal),
  "eastBoundLongitude": makeObjectPropertySetter(readDecimal),
  "southBoundLatitude": makeObjectPropertySetter(readDecimal),
  "northBoundLatitude": makeObjectPropertySetter(readDecimal)
});
var REQUEST_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "GetCapabilities": makeObjectPropertySetter(readOperationType),
  "GetMap": makeObjectPropertySetter(readOperationType),
  "GetFeatureInfo": makeObjectPropertySetter(readOperationType)
});
var OPERATIONTYPE_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Format": makeObjectPropertyPusher(readString),
  "DCPType": makeObjectPropertyPusher(readDCPType)
});
var DCPTYPE_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "HTTP": makeObjectPropertySetter(readHTTP)
});
var HTTP_PARSERS2 = makeStructureNS(NAMESPACE_URIS4, {
  "Get": makeObjectPropertySetter(readFormatOnlineresource),
  "Post": makeObjectPropertySetter(readFormatOnlineresource)
});
var STYLE_PARSERS2 = makeStructureNS(NAMESPACE_URIS4, {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "LegendURL": makeObjectPropertyPusher(readSizedFormatOnlineresource),
  "StyleSheetURL": makeObjectPropertySetter(readFormatOnlineresource),
  "StyleURL": makeObjectPropertySetter(readFormatOnlineresource)
});
var FORMAT_ONLINERESOURCE_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Format": makeObjectPropertySetter(readString),
  "OnlineResource": makeObjectPropertySetter(readHref)
});
var KEYWORDLIST_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Keyword": makeArrayPusher(readString)
});
function readAttribution(node, objectStack) {
  return pushParseAndPop({}, ATTRIBUTION_PARSERS, node, objectStack);
}
function readBoundingBox(node, objectStack) {
  const extent = [
    readDecimalString(node.getAttribute("minx")),
    readDecimalString(node.getAttribute("miny")),
    readDecimalString(node.getAttribute("maxx")),
    readDecimalString(node.getAttribute("maxy"))
  ];
  const resolutions = [
    readDecimalString(node.getAttribute("resx")),
    readDecimalString(node.getAttribute("resy"))
  ];
  return {
    "crs": node.getAttribute("CRS"),
    "extent": extent,
    "res": resolutions
  };
}
function readEXGeographicBoundingBox(node, objectStack) {
  const geographicBoundingBox = pushParseAndPop(
    {},
    EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS,
    node,
    objectStack
  );
  if (!geographicBoundingBox) {
    return void 0;
  }
  const westBoundLongitude = geographicBoundingBox["westBoundLongitude"];
  const southBoundLatitude = geographicBoundingBox["southBoundLatitude"];
  const eastBoundLongitude = geographicBoundingBox["eastBoundLongitude"];
  const northBoundLatitude = geographicBoundingBox["northBoundLatitude"];
  if (westBoundLongitude === void 0 || southBoundLatitude === void 0 || eastBoundLongitude === void 0 || northBoundLatitude === void 0) {
    return void 0;
  }
  return [
    westBoundLongitude,
    southBoundLatitude,
    eastBoundLongitude,
    northBoundLatitude
  ];
}
function readCapability(node, objectStack) {
  return pushParseAndPop({}, CAPABILITY_PARSERS, node, objectStack);
}
function readService(node, objectStack) {
  return pushParseAndPop({}, SERVICE_PARSERS, node, objectStack);
}
function readContactInformation(node, objectStack) {
  return pushParseAndPop({}, CONTACT_INFORMATION_PARSERS, node, objectStack);
}
function readContactPersonPrimary(node, objectStack) {
  return pushParseAndPop({}, CONTACT_PERSON_PARSERS, node, objectStack);
}
function readContactAddress(node, objectStack) {
  return pushParseAndPop({}, CONTACT_ADDRESS_PARSERS, node, objectStack);
}
function readException(node, objectStack) {
  return pushParseAndPop([], EXCEPTION_PARSERS, node, objectStack);
}
function readCapabilityLayer(node, objectStack) {
  const layerObject = pushParseAndPop({}, LAYER_PARSERS, node, objectStack);
  if (layerObject["Layer"] === void 0) {
    return Object.assign(layerObject, readLayer(node, objectStack));
  }
  return layerObject;
}
function readLayer(node, objectStack) {
  const parentLayerObject = objectStack[objectStack.length - 1];
  const layerObject = pushParseAndPop({}, LAYER_PARSERS, node, objectStack);
  if (!layerObject) {
    return void 0;
  }
  let queryable = readBooleanString(node.getAttribute("queryable"));
  if (queryable === void 0) {
    queryable = parentLayerObject["queryable"];
  }
  layerObject["queryable"] = queryable !== void 0 ? queryable : false;
  let cascaded = readNonNegativeIntegerString(node.getAttribute("cascaded"));
  if (cascaded === void 0) {
    cascaded = parentLayerObject["cascaded"];
  }
  layerObject["cascaded"] = cascaded;
  let opaque = readBooleanString(node.getAttribute("opaque"));
  if (opaque === void 0) {
    opaque = parentLayerObject["opaque"];
  }
  layerObject["opaque"] = opaque !== void 0 ? opaque : false;
  let noSubsets = readBooleanString(node.getAttribute("noSubsets"));
  if (noSubsets === void 0) {
    noSubsets = parentLayerObject["noSubsets"];
  }
  layerObject["noSubsets"] = noSubsets !== void 0 ? noSubsets : false;
  let fixedWidth = readDecimalString(node.getAttribute("fixedWidth"));
  if (!fixedWidth) {
    fixedWidth = parentLayerObject["fixedWidth"];
  }
  layerObject["fixedWidth"] = fixedWidth;
  let fixedHeight = readDecimalString(node.getAttribute("fixedHeight"));
  if (!fixedHeight) {
    fixedHeight = parentLayerObject["fixedHeight"];
  }
  layerObject["fixedHeight"] = fixedHeight;
  const addKeys = ["Style", "CRS", "AuthorityURL"];
  addKeys.forEach(function(key) {
    if (key in parentLayerObject) {
      const childValue = layerObject[key] || [];
      layerObject[key] = childValue.concat(parentLayerObject[key]);
    }
  });
  const replaceKeys = [
    "EX_GeographicBoundingBox",
    "BoundingBox",
    "Dimension",
    "Attribution",
    "MinScaleDenominator",
    "MaxScaleDenominator"
  ];
  replaceKeys.forEach(function(key) {
    if (!(key in layerObject)) {
      const parentValue = parentLayerObject[key];
      layerObject[key] = parentValue;
    }
  });
  return layerObject;
}
function readDimension(node, objectStack) {
  const dimensionObject = {
    "name": node.getAttribute("name"),
    "units": node.getAttribute("units"),
    "unitSymbol": node.getAttribute("unitSymbol"),
    "default": node.getAttribute("default"),
    "multipleValues": readBooleanString(node.getAttribute("multipleValues")),
    "nearestValue": readBooleanString(node.getAttribute("nearestValue")),
    "current": readBooleanString(node.getAttribute("current")),
    "values": readString(node)
  };
  return dimensionObject;
}
function readFormatOnlineresource(node, objectStack) {
  return pushParseAndPop({}, FORMAT_ONLINERESOURCE_PARSERS, node, objectStack);
}
function readRequest(node, objectStack) {
  return pushParseAndPop({}, REQUEST_PARSERS, node, objectStack);
}
function readDCPType(node, objectStack) {
  return pushParseAndPop({}, DCPTYPE_PARSERS, node, objectStack);
}
function readHTTP(node, objectStack) {
  return pushParseAndPop({}, HTTP_PARSERS2, node, objectStack);
}
function readOperationType(node, objectStack) {
  return pushParseAndPop({}, OPERATIONTYPE_PARSERS, node, objectStack);
}
function readSizedFormatOnlineresource(node, objectStack) {
  const formatOnlineresource = readFormatOnlineresource(node, objectStack);
  if (formatOnlineresource) {
    const size = [
      readNonNegativeIntegerString(node.getAttribute("width")),
      readNonNegativeIntegerString(node.getAttribute("height"))
    ];
    formatOnlineresource["size"] = size;
    return formatOnlineresource;
  }
  return void 0;
}
function readAuthorityURL(node, objectStack) {
  const authorityObject = readFormatOnlineresource(node, objectStack);
  if (authorityObject) {
    authorityObject["name"] = node.getAttribute("name");
    return authorityObject;
  }
  return void 0;
}
function readMetadataURL(node, objectStack) {
  const metadataObject = readFormatOnlineresource(node, objectStack);
  if (metadataObject) {
    metadataObject["type"] = node.getAttribute("type");
    return metadataObject;
  }
  return void 0;
}
function readStyle2(node, objectStack) {
  return pushParseAndPop({}, STYLE_PARSERS2, node, objectStack);
}
function readKeywordList(node, objectStack) {
  return pushParseAndPop([], KEYWORDLIST_PARSERS, node, objectStack);
}
var WMSCapabilities_default = WMSCapabilities;

// node_modules/ol/format/WMSGetFeatureInfo.js
var featureIdentifier = "_feature";
var layerIdentifier = "_layer";
var WMSGetFeatureInfo = class extends XMLFeature_default {
  constructor(options) {
    super();
    options = options ? options : {};
    this.featureNS_ = "http://mapserver.gis.umn.edu/mapserver";
    this.gmlFormat_ = new GML2_default();
    this.layers_ = options.layers ? options.layers : null;
  }
  getLayers() {
    return this.layers_;
  }
  setLayers(layers) {
    this.layers_ = layers;
  }
  readFeatures_(node, objectStack) {
    node.setAttribute("namespaceURI", this.featureNS_);
    const localName = node.localName;
    let features = [];
    if (node.childNodes.length === 0) {
      return features;
    }
    if (localName == "msGMLOutput") {
      for (let i = 0, ii = node.childNodes.length; i < ii; i++) {
        const layer = node.childNodes[i];
        if (layer.nodeType !== Node.ELEMENT_NODE) {
          continue;
        }
        const layerElement = layer;
        const context = objectStack[0];
        const toRemove = layerIdentifier;
        const layerName = layerElement.localName.replace(toRemove, "");
        if (this.layers_ && !this.layers_.includes(layerName)) {
          continue;
        }
        const featureType = layerName + featureIdentifier;
        context["featureType"] = featureType;
        context["featureNS"] = this.featureNS_;
        const parsers = {};
        parsers[featureType] = makeArrayPusher(
          this.gmlFormat_.readFeatureElement,
          this.gmlFormat_
        );
        const parsersNS = makeStructureNS(
          [context["featureNS"], null],
          parsers
        );
        layerElement.setAttribute("namespaceURI", this.featureNS_);
        const layerFeatures = pushParseAndPop(
          [],
          parsersNS,
          layerElement,
          objectStack,
          this.gmlFormat_
        );
        if (layerFeatures) {
          extend2(features, layerFeatures);
        }
      }
    }
    if (localName == "FeatureCollection") {
      const gmlFeatures = pushParseAndPop(
        [],
        this.gmlFormat_.FEATURE_COLLECTION_PARSERS,
        node,
        [{}],
        this.gmlFormat_
      );
      if (gmlFeatures) {
        features = gmlFeatures;
      }
    }
    return features;
  }
  readFeaturesFromNode(node, options) {
    const internalOptions = {};
    if (options) {
      Object.assign(internalOptions, this.getReadOptions(node, options));
    }
    return this.readFeatures_(node, [internalOptions]);
  }
};
var WMSGetFeatureInfo_default = WMSGetFeatureInfo;

// node_modules/ol/format/WMTSCapabilities.js
var NAMESPACE_URIS5 = [null, "http://www.opengis.net/wmts/1.0"];
var OWS_NAMESPACE_URIS = [null, "http://www.opengis.net/ows/1.1"];
var PARSERS3 = makeStructureNS(NAMESPACE_URIS5, {
  "Contents": makeObjectPropertySetter(readContents)
});
var WMTSCapabilities = class extends XML_default {
  constructor() {
    super();
    this.owsParser_ = new OWS_default();
  }
  readFromNode(node) {
    let version = node.getAttribute("version");
    if (version) {
      version = version.trim();
    }
    let WMTSCapabilityObject = this.owsParser_.readFromNode(node);
    if (!WMTSCapabilityObject) {
      return null;
    }
    WMTSCapabilityObject["version"] = version;
    WMTSCapabilityObject = pushParseAndPop(
      WMTSCapabilityObject,
      PARSERS3,
      node,
      []
    );
    return WMTSCapabilityObject ? WMTSCapabilityObject : null;
  }
};
var CONTENTS_PARSERS = makeStructureNS(NAMESPACE_URIS5, {
  "Layer": makeObjectPropertyPusher(readLayer2),
  "TileMatrixSet": makeObjectPropertyPusher(readTileMatrixSet)
});
var LAYER_PARSERS2 = makeStructureNS(
  NAMESPACE_URIS5,
  {
    "Style": makeObjectPropertyPusher(readStyle3),
    "Format": makeObjectPropertyPusher(readString),
    "TileMatrixSetLink": makeObjectPropertyPusher(readTileMatrixSetLink),
    "Dimension": makeObjectPropertyPusher(readDimensions),
    "ResourceURL": makeObjectPropertyPusher(readResourceUrl)
  },
  makeStructureNS(OWS_NAMESPACE_URIS, {
    "Title": makeObjectPropertySetter(readString),
    "Abstract": makeObjectPropertySetter(readString),
    "WGS84BoundingBox": makeObjectPropertySetter(readBoundingBox2),
    "Identifier": makeObjectPropertySetter(readString)
  })
);
var STYLE_PARSERS3 = makeStructureNS(
  NAMESPACE_URIS5,
  {
    "LegendURL": makeObjectPropertyPusher(readLegendUrl)
  },
  makeStructureNS(OWS_NAMESPACE_URIS, {
    "Title": makeObjectPropertySetter(readString),
    "Identifier": makeObjectPropertySetter(readString)
  })
);
var TMS_LINKS_PARSERS = makeStructureNS(NAMESPACE_URIS5, {
  "TileMatrixSet": makeObjectPropertySetter(readString),
  "TileMatrixSetLimits": makeObjectPropertySetter(readTileMatrixLimitsList)
});
var TMS_LIMITS_LIST_PARSERS = makeStructureNS(NAMESPACE_URIS5, {
  "TileMatrixLimits": makeArrayPusher(readTileMatrixLimits)
});
var TMS_LIMITS_PARSERS = makeStructureNS(NAMESPACE_URIS5, {
  "TileMatrix": makeObjectPropertySetter(readString),
  "MinTileRow": makeObjectPropertySetter(readPositiveInteger),
  "MaxTileRow": makeObjectPropertySetter(readPositiveInteger),
  "MinTileCol": makeObjectPropertySetter(readPositiveInteger),
  "MaxTileCol": makeObjectPropertySetter(readPositiveInteger)
});
var DIMENSION_PARSERS = makeStructureNS(
  NAMESPACE_URIS5,
  {
    "Default": makeObjectPropertySetter(readString),
    "Value": makeObjectPropertyPusher(readString)
  },
  makeStructureNS(OWS_NAMESPACE_URIS, {
    "Identifier": makeObjectPropertySetter(readString)
  })
);
var WGS84_BBOX_READERS = makeStructureNS(OWS_NAMESPACE_URIS, {
  "LowerCorner": makeArrayPusher(readCoordinates),
  "UpperCorner": makeArrayPusher(readCoordinates)
});
var TMS_PARSERS = makeStructureNS(
  NAMESPACE_URIS5,
  {
    "WellKnownScaleSet": makeObjectPropertySetter(readString),
    "TileMatrix": makeObjectPropertyPusher(readTileMatrix)
  },
  makeStructureNS(OWS_NAMESPACE_URIS, {
    "SupportedCRS": makeObjectPropertySetter(readString),
    "Identifier": makeObjectPropertySetter(readString),
    "BoundingBox": makeObjectPropertySetter(readBoundingBox2)
  })
);
var TM_PARSERS = makeStructureNS(
  NAMESPACE_URIS5,
  {
    "TopLeftCorner": makeObjectPropertySetter(readCoordinates),
    "ScaleDenominator": makeObjectPropertySetter(readDecimal),
    "TileWidth": makeObjectPropertySetter(readPositiveInteger),
    "TileHeight": makeObjectPropertySetter(readPositiveInteger),
    "MatrixWidth": makeObjectPropertySetter(readPositiveInteger),
    "MatrixHeight": makeObjectPropertySetter(readPositiveInteger)
  },
  makeStructureNS(OWS_NAMESPACE_URIS, {
    "Identifier": makeObjectPropertySetter(readString)
  })
);
function readContents(node, objectStack) {
  return pushParseAndPop({}, CONTENTS_PARSERS, node, objectStack);
}
function readLayer2(node, objectStack) {
  return pushParseAndPop({}, LAYER_PARSERS2, node, objectStack);
}
function readTileMatrixSet(node, objectStack) {
  return pushParseAndPop({}, TMS_PARSERS, node, objectStack);
}
function readStyle3(node, objectStack) {
  const style = pushParseAndPop({}, STYLE_PARSERS3, node, objectStack);
  if (!style) {
    return void 0;
  }
  const isDefault = node.getAttribute("isDefault") === "true";
  style["isDefault"] = isDefault;
  return style;
}
function readTileMatrixSetLink(node, objectStack) {
  return pushParseAndPop({}, TMS_LINKS_PARSERS, node, objectStack);
}
function readDimensions(node, objectStack) {
  return pushParseAndPop({}, DIMENSION_PARSERS, node, objectStack);
}
function readResourceUrl(node, objectStack) {
  const format = node.getAttribute("format");
  const template = node.getAttribute("template");
  const resourceType = node.getAttribute("resourceType");
  const resource = {};
  if (format) {
    resource["format"] = format;
  }
  if (template) {
    resource["template"] = template;
  }
  if (resourceType) {
    resource["resourceType"] = resourceType;
  }
  return resource;
}
function readBoundingBox2(node, objectStack) {
  const coordinates2 = pushParseAndPop(
    [],
    WGS84_BBOX_READERS,
    node,
    objectStack
  );
  if (coordinates2.length != 2) {
    return void 0;
  }
  return boundingExtent(coordinates2);
}
function readLegendUrl(node, objectStack) {
  const legend = {};
  legend["format"] = node.getAttribute("format");
  legend["href"] = readHref(node);
  return legend;
}
function readCoordinates(node, objectStack) {
  const coordinates2 = readString(node).split(/\s+/);
  if (!coordinates2 || coordinates2.length != 2) {
    return void 0;
  }
  const x = +coordinates2[0];
  const y = +coordinates2[1];
  if (isNaN(x) || isNaN(y)) {
    return void 0;
  }
  return [x, y];
}
function readTileMatrix(node, objectStack) {
  return pushParseAndPop({}, TM_PARSERS, node, objectStack);
}
function readTileMatrixLimitsList(node, objectStack) {
  return pushParseAndPop([], TMS_LIMITS_LIST_PARSERS, node, objectStack);
}
function readTileMatrixLimits(node, objectStack) {
  return pushParseAndPop({}, TMS_LIMITS_PARSERS, node, objectStack);
}
var WMTSCapabilities_default = WMTSCapabilities;
export {
  EsriJSON_default as EsriJSON,
  GML_default as GML,
  GPX_default as GPX,
  GeoJSON_default as GeoJSON,
  IGC_default as IGC,
  IIIFInfo_default as IIIFInfo,
  KML_default as KML,
  MVT_default as MVT,
  OWS_default as OWS,
  Polyline_default as Polyline,
  TopoJSON_default as TopoJSON,
  WFS_default as WFS,
  WKB_default as WKB,
  WKT_default as WKT,
  WMSCapabilities_default as WMSCapabilities,
  WMSGetFeatureInfo_default as WMSGetFeatureInfo,
  WMTSCapabilities_default as WMTSCapabilities
};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
//# sourceMappingURL=ol_format.js.map
